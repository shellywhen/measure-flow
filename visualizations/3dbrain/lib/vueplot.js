//****************************************************************************************************
//* *
//* Copyright (C) Microsoft. All rights reserved. *
//* *
//****************************************************************************************************
/// vuePlot.js.  - a charting library from the MSR Vue (VIBE) team.
//****************************************************************************************************
/// vuePlot is a JavaScript library consisting of jQuery (1.7.1) and Microsoft code
/// for building HTML 5 based charts and visualizations.  vuePlot uses the chaining method
/// style of setting data-bound attributes to specify visualizations and related
/// animations more concisely.  Besides providing low level tools for building visualizations,
/// it also comes with a set of popular reusable visualizations.
///---------------------------------------------------------------------------------------------------
/// NOTE: be sure to include jQuery 1.7.1 in your pages that use vuePlot.
///---------------------------------------------------------------------------------------------------
/// VuePlot programming model:
//
///     - A common shape programming model that spans SVG, Canvas, and WebGL.  This allows you
///       to switch the underlying shape engine for your app using the same app code.
///---------------------------------------------------------------------------------------------------
/// A central object in vuePlot is the selected set.  A selected set is a set of elements that
/// can be operated on with fluent-style method chaining.  For example:
///
///     vp.select("div")
///         .css("border", "1px solid black")
///         .css("background", "gray")
///         .show();
///
/// In the above example, the first line creates a new selected set consisting of all <div> elements
/// in the HTML document (DOM).  The 2nd line sets the css "border" property for each element in the
/// set to "1px solid black".  The 3rd line sets the css "background" property of each element to
/// "gray".  The 4th line changes the visibility of each element to "visible".
///
/// For lighter-weight code, "$" is defined as an alias for the "vp" namespace object AND the
/// vp.select() function.  So, the following are allowed:
///
///     $.xxx(args)    // calls vuePlot.xxx(args) 
///
///     $(args)        // "$" object is really the vuePlot.select function, so this calls vuePlot.select(args)
///---------------------------------------------------------------------------------------------------
///$startDoc
///---------------------------------------------------------------------------------------------------
/// select functions:     functions to create and manage selection sets
///                       ("ss" in the functions refers to a selected set object)
///
///                       "+" below signifies that the function has a set of unit tests.
///                       "-" below signifies that the function has not yet been implemented.
///
///     $.select()        creates a selection set based using a css selection string and/or element
///   + $()               a synonym for $.select()
///     ss.get()          returns the item at the specified index in the set
///     ss.wrap()         returns a selected set of just the item at the specified index in the set
///     ss.toArray()      return an array of the items in the set
///     ss.add()          add items(s) to the set
///     ss.each()         call the callback function for each item in the set
///---------------------------------------------------------------------------------------------------
/// property functions:   functions to get and set element proerties
///                       (available to both single elements (using $.funcName) and
///                       selected sets (using ss.funcName)
///
///     ss.attr()           get/set the specified attribute for the items
///     ss.attrNS()         get/set the namespace-qualified attribute property for the items
///     ss.attrXlink()      get/set the xlink attribute property for the items
///     ss.prop()           get/set the specified property for the items
///     ss.removeAttr()     remove the specified attribute from the items
///     ss.removeProp()     remove the specified property from the items
///     ss.css()            get/set the specified css property for the items
///     ss.width()          get/set the width for the items
///     ss.height()         get/set the width for the items
///     ss.left()           for HTML elements: sets the CSS left or gets the actual left (pixels from parent)
///     ss.top()            for HTML elements: sets the CSS top or gets the actual top (pixels from parent)
///   - ss.scrollLeft()     get/set the horizontal scroll offset of the items
///   - ss.scrollTop()      get/set the vertial scroll offset of the items
///     ss.html()           get/set the HTML content of the items
///     ss.text()           get/set the text content of the items
///     ss.append()         add the specified content to the items (at the end of its children)
///     ss.prepend()        add the specified content to the items (at the beginning of its children)
///     ss.insertBefore()   add the specified content to the items (just before the specified child item)
///     ss.insertAfter()    add the specified content to the items (just after the specified child item)
///     ss.remove()         removed the items from the DOM
///     ss.clear()          removes all child elements from the item(s)
///     ss.value()          get/set the "value" attribute of the input items
///     ss.href()           get/set the "href" attribute of the items
///     ss.id()             get/set the "id" attribute of the items
///     ss.addClass()       add the specified class names for the items
///     ss.removeClass()    remove the specified class names from the items
///     ss.toggleClass()    add/remove the specified class names from the items
///     ss.hasClass()       returns true if the item has the specified class name
///     $.keys()            returns the property keys of the item as an array
///     $.hasKeys()         returns true if the item has one or more properties
///     $.docOffset()       gets the {left, top} offset of the item (pixels relative to document origin)
///     $.parentOffset()    gets the {left, top} offset of the item (pixels relative to element's parent)
///     $.windowSize()      returns the {width, height} of the document window
///     $.getWindowScroll() returns the {width, height} of the scroll position of the document window
///
/// property shortcuts:   functions that make it easier to get/set popular properties
///
///     ss.opacity()        get/set the opacity property for the items (css for HTML; attr for SVG/canvas)
///     ss.dataItem()       get/set the "dataIndex" property for the items (usually the associated data record)
///     ss.dataIndex()      get/set the "dataItem" property for the items (usually the associated data record index)
///     ss.bounds()         sets the position and size attributes of the items
///     ss.position()       sets the x and y attributes for the items
///     ss.center()         sets the cx,cy attributes for the items
///     ss.colors()         sets the CSS fill, stroke, and strokeWidth properties for the items
///     ss.from()           sets the x1, y1 attributes for the items
///     ss.to()             sets the x2, y2 attributes for the items
///     ss.font()           sets the CSS fontFamily, fontSize, bold, and italic properties for the items
///     ss.toolTipEnabled() sets the vuePlot "toolTipEnabled" property for the items
///     ss.radius()         sets the radius attribute for the items
///     ss.transform()      sets the transform attribute for the items
///     ss.checked()        get/set the "checked" property (for checkboxes, radiobuttons)
///---------------------------------------------------------------------------------------------------
/// event functions:      functions to help manage and process DOM events
///
///     ss.attach()             attach the specified callback to the named event for the items
///     ss.detach()             unattach the specified callback to the named event for the items
///     ss.toolTip()            creates a rich tooltip callback for the specified items
///     $.elementFromPoint()    return the element at the specified x, y positon
///     $.attachTouchEvents()   attached the specifiec callbacks to the touch events for the items
///     $.monitorKeyboard()     enables or disables the monitoring of keyboard key states
///     $.mousePosition()       returns the {x, y} position of the mouse
///     $.isKeyPressed()        return true if the specified key is pressed
///     $.zoomBoxHelper()       creates a helper class for zooming and panning with the mouse
///     $.setCapture()          capture the mouse (if agent allows)
///     $.releaseCapture()      release the mouse (if agent allows)
///---------------------------------------------------------------------------------------------------
/// animate functions:      functions for creating and managing cross-browser animations
///
///     ss.hide()                 hide the items, with optional animation
///     ss.collapse()             collapse the items (hide with layout impact)
///     ss.show()                 show the items, with optional animation
///     ss.animate()              applies an animation to the items using properties, duration, easing, and a completion callback
///   - ss.showToggle()           toggle the visbility of the items, with optional animation
///   - ss.fadeIn()               fade in the opacity of the items with specified duration
///   - ss.fadeOut()              fade out the opacity of the items with specified duration
///   - ss.fadeTo()               animate the opacity to the specified value for the items
///   - ss.slideDown()            animate the showing of the items, increasing their height
///   - ss.slideUp()              animate the hiding of the items, decreasing their height
///   - ss.slideToggle()          toggle the visibility of the items calling slideDown() or slideUp()
///   - ss.stop()                 stop all animations for the items
///   - ss.startAnimation()       starts an animaton, so that subsequent property settings on this set are animated
///   - $.enableAnimation()       enables or disables all vuePlot controlled animation
///---------------------------------------------------------------------------------------------------
/// path generators:        functions for generating SVG paths
///
///   - $.lineGenerator()       creates a line generator function that can be used to set the "d" attribute of paths
///   - $.areaGenerator()       creates an area generator function that can be used to set the "d" attribute of paths
///   - $.arcGenerator()        creates an arc generator function that can be used to set the "d" attribute of paths
///   - $.symbolGenerator()     creates a symbol generator function that can be used to set the "d" attribute of paths
///---------------------------------------------------------------------------------------------------
/// utility functions:          functions that make it easier to write general javascript
///
///     + $.isUndefined()      returns true if the object is not defined
///     + $.isDefined()        returns true if the object is defined
///     + $.isSvgElement()     return true if object is an svg document or an svg element
///     + $.isCanvas()         return true if object is an HTML 5 canvas
///     + $.isCanvasChild()    return true if object is a lightweight canvas child
///     + $.isCanvasContainer()    return true if object is a lightweight canvas child
///     + $.isVuePlotControl() return true if object is a vuePlot visualization element
///     + $.isArray()          returns true if object is an array
///     + $.isFunction()       returns true if object is an function
///     + $.isString()         returns true if object is a string
///     + $.isNumber()         returns true if object is a number
///     + $.isValidNumber()    returns true if object is a number and not a NAN
///
///     + string.startsWith()   returns true if string starts with the specified string
///     + string.endsWith()     returns true if string ends with the specified string
///     + string.ltrim()        returns copy of string with leading spaces removed
///     + string.rtrim()        returns copy of string with trailing spaces removed
///     + string.trim()         returns copy of string with both leading and trailing spaces removed
///
///     + array.max()           returns maximum value of array
///     + array.min()           returns minimum value of array
///     + array.remove()        removes the specified from the array
///     + array.removeAt()      returns the entry at the specified index
///     + array.selectWithFunc()        returns a new array formed by calling the callback on each item in the original array
///     + array.where()         returns an array of the items that evaluate to true, using the callback for each item
///     + array.orderBy()       returns a sorted copy of the array
///     + array.distinct()      returns copy of array with duplicate entries removed
///
///     $.ready()              registers the callback to be called when the document is fully loaded
///     $.setThis()            wraps a function so that when called, it's this pointer will be set correctly
///     $.range()              returns an array of numbers from min to max, by increment
///     $.children()           returns an array of the direct child elements of the specified parent
///     $.debug()              writes the specified string to the debug console, if it exists
///     $.floatEq()            returns true if 2 numbers are equal (or within a prefined epsilon value)
///     $.floatLessEq()        returns true if the 1st number is less than or equal to the 2nd number (within epsilon)
///     $.floatGtrEq()         returns true if the 1st number is greater than or equal to the 2nd number (within epsilon)
///     $.getUrlParams()       returns a hash of parameter name/value pairs for this document's URL
///     $.startScriptLoad()    start downloading a script in the background.
///     $.globalEval()         evaluate the js string at the global context.
///     $.getNamedColors()     get json object with name/value pairs for all SVG/HTML color names & RGB values.
///     $.colorHelper          helps to parse color strings
///     $.clamp()              ensure value is between specified minimum and maximum.
///     $.routeCalls()         route a set of method calls from one object to another (subclass to baseclass)
///     $.routeCallsPost()     route a set of method calls from one object to another and call a "post" call after
///---------------------------------------------------------------------------------------------------
///---------------------------------------------------------------------------------------------------
/// data utilities:
///     vp.createXMLHttpRequest()   create an XMLHttpRequest object to download text asyncronously.
///     vp.csvToJson()              converts a CSV text string to a json object.
///     vp.format()                 format the specified number nicely (minimize decimals, add commas, etc)
///     vp.getJsonFromResponseXml() gets json object from responseXML string.
///     vp.getJsonFromResponse()    gets json object from response string.
///     vp.httpCrossDomainRead()    downloads text from another domain, if host supports CDR's.
///     vp.httpRead()               downloads text from specified url as json or xml.
///     vp.httpPost()               uploads text to specified url.
///     vp.httpReadViaService()     downloads text from specified URL using the current host's "DowloadText" service
///     vp.oDataRead()              downloads data from an OData source
///     vp.oDataReadAll()           downloads all data from the specified OData query/entity.
///---------------------------------------------------------------------------------------------------
/// fast shape drawing:
///     vp.canvasCircleElement     lightweight object for circle rectangle
///     vp.canvasContainerElement  used to manage children elements of a canvas
///     vp.canvasElement           base class for canvas container & its children classes
///     vp.canvasLineElement       lightweight object for line rectangle
///     vp.canvasRectElement       lightweight object for canvas rectangle
///     vp.canvasTextElement       lightweight object for text rectangle
///     vp.matrix4                 4x4 matrix class (for 3D math)
///     vp.vector2                 2x vector class (for 2D math)
///---------------------------------------------------------------------------------------------------
/// vp.scales:                      
///     .bar                       used for x axis of bar-type plots
///     .linear                    used for scaling continous numbers (y scale, etc)
///---------------------------------------------------------------------------------------------------
/// plotting:                       
///     vp.createBins()            creates binned data from an array of data
///---------------------------------------------------------------------------------------------------
/// helper functions:
///     vp.scanner                 general purpose token/string/number/operator scanner
///---------------------------------------------------------------------------------------------------
/// vp.layouts:
///     .vertical                  layout items from top to bottom
///     .horizontal                layout items from left to right
///     .grid                      layout items in n x m matrix
///     .random                    layout items in random locations within a rectangle
///     .path                      layout items along a path
///     .dock                      layout items in a docking container (left, top, right, bottom, fill)
///     .force                     layout items non-overlapping at random
///     .tree                      layout items in a tree map
///     .circlePacking             pack items closely together without overlap
///     .msagl                     layout node/link graph
///---------------------------------------------------------------------------------------------------
/// vp.visuals:
///     .dataGrid                   builds a readonly dataGrid control 
///     .slider                     builds a slider control
///     .horizontalAxis             build a horizontal axis
///     .verticalAxis               build a vertical axis
///     .histogram()                builds a histogram chart
///---------------------------------------------------------------------------------------------------
///$endDoc
///---------------------------------------------------------------------------------------------------

"use strict"    // apply max error checking

// preserve any namespaces we might overwrite.
var _vuePlotNamespacePreserver_ = { vp: window.vp, vuePlot: window.vuePlot};

//---- vuePlot ROOT CLASS ----
//var vp = function (p1, p2)
//{
//    return vp.select(p1, p2);
//};

if (!vp)
{
    //---- this should be defined by VuePlotCore ----
    vp = {};
}

var vuePlot = vp;

vp.strict = false;      // set this to "true" for more error checking
vp.onError = null;

vp.getErrorInfo = function ()
{
    var error = null;

    try
    {
        var x = window.thisNameDoesNotExist;
    }
    catch (ex)
    {
        error = ex;
    }

    return error;
}

vp.error = function (msg, lineNum)
{
    var omitThrow = false;

    if (lineNum)
    {
        msg += " [line: " + lineNum + "]";
    }

    if (vp.onError)
    {
        omitThrow = vp.onError(msg);
    }

    if (!omitThrow)
    {
        throw msg;
    }
}

vp.argToStr = function(arg)
{
    var str = arg;

    if (vp.isString(arg))
    {
        str = "\"" + arg + "\"";
    }

    return str;
}

vp.checkArgCompat = function(funcName, argIndex, arg, type)
{
    if (type)
    {
        if (type == "bool")
        {
            if ((arg != 0) && (arg != 1) && (arg != true) && (arg != false))
            {
                vp.error("Function '" + funcName + "', argument[" + argIndex + "] must be of type '" + type + "' (arg passed: " + vp.argToStr(arg) + ")");
            }
        }
    }
}

vp.argCheck = function (args, funcName, minArgs, maxArgs, argTypes)
{
    if (vp.strict)
    {
        var len = args.length;
        var lineNum = vp.getErrorInfo();

        if (len < minArgs)
        {
            vp.error("Function '" + funcName + "' requires at least " + minArgs + " (received=" + len + ")", lineNum);
        }
        else if (len > maxArgs)
        {
            vp.error("Function '" + funcName + "' can only accept up to " + maxArgs + " (received=" + len + ")", lineNum);
        }

        for (var i = 0; i < len; i++)
        {
            vp.checkArgCompat(funcName, i, args[i], argTypes[i]);
        }
    }

}

//---- create namespace objects ----
vp.scales = {};        
vp.layouts = {};
vp.layers = {};
vp.visuals = {};
vp.dataStuff = {};
vp.colorStuff = {};

vp.shaderAnimationMgr = null;

//---- class: selectedSet (not directly created by callers) ----
vp.selectedSet = function (elements)
{
    this.ctr = "vp.selectedSet";
    this.length = 0;

    //---- make "selectedSet" look/act like an array object ---
    this.push = Array.prototype.push;
    this.splice = Array.prototype.splice;
    this.indexOf = Array.prototype.indexOf;
    this.select = Array.prototype.select;

    if (elements)
    {
        var sameCtr = true;         // initially
        var lastCtr = "";

        for (var i = 0; i < elements.length; i++)
        {
            var elem = elements[i];

            this.push(elem);

            if (i == 0)
            {
                lastCtr = elem.ctr;
            }
            else
            {
                if (elem.ctr != lastCtr)
                {
                    sameCtr = false;
                }
            }
        }

        //---- extend this wrapper if elem with custom control properties ----
        if ((elements.length > 0) && (sameCtr))
        {
            var elem = elements[0];

            if ((elem.control) && (elem.control.extendWrapper))
            {
                elem.control.extendWrapper(this);
            }
        }
    }
};

//---- shortcut for adding selected set functions ----
vp.fn = vp.selectedSet.prototype;
﻿///-----------------------------------------------------------------------------------------------------------------
/// array.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - array helper functions.
///-----------------------------------------------------------------------------------------------------------------

vp.arrayHelpers = {};

//---- ARRAY helper functions ----
vp.arrayHelpers.clone = function ()
{
    var newAray = null;

    if (this.slice)
    {
        newAray = this.slice(0);
    }
    else
    {
        newAray = [];

        for (var i = 0; i < this.length; i++)
        {
            newAray[i] = this[i];
        }
    }

    return newAray;
}

vp.arrayHelpers.take = function (count)
{
    var newArray = this.slice(0, count);
    return newArray;
}

vp.arrayHelpers.remove = function (elem)
    /// signature:  remove(item)
    ///     summary:    removes the specified item from the array.
    ///     paramType(item): object
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    aray.remove(6);         // aray should now contain [3, 4, 5]
    ///     returns:    null.
{
    var index = this.indexOf(elem);
    if (index > -1)
    {
        this.splice(index, 1);
    }
}

vp.arrayHelpers.removeAt = function (index)
    /// signature:  removeAt(index)
    ///     summary:    removes the item at the specified index from the array.
    ///     paramType(index): integer number
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    aray.remove(0);         // aray should now contain [4, 5, 6]
    ///     returns:    null.
{
    if (index > -1)
    {
        this.splice(index, 1);
    }
}

vp.arrayHelpers.insert = function (index, value)
{
    if (index > -1)
    {
        this.splice(index, 0, value);
    }
}

vp.arrayHelpers.max = function (itemFunc)
    /// signature:  max()
    ///     summary: returns the item in the array with the largest value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var myMax = aray.max();        // myMax will be set to 5.
    ///     returns: the item in the array with the largest value
    /// signature: max(func)
    ///     summary: returns the item in the array for which calling func produces the largest value
    ///     paramType(func): function
    ///     snippet: var aray = [-5, 3, 0, 3];
    ///     snippet: var myMax = aray.max(Math.abs);        // myMax will be set to -5
    ///     returns: the item in the array for which calling func produces the largest value
{
    //var startTime = new Date().getTime();
    var mm = -Number.MAX_VALUE;      // Number.MIN_VALUE;

    if (vp.isFunction(itemFunc))
    {
        for (var i = 0; i < this.length; i++)
        {
            var value = itemFunc(this[i]);

            // the below code is 2x faster than: mm = Math.max(mm, this[i]);
            if (value > mm)
            {
                mm = value;
            }
        }
    }
    else
    {
        //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
        if (this.length <= 125 * 1000)      // just to be safe
        {
            mm = Math.max.apply(Math, this);
        }
        else
        {
            for (var i = 0; i < this.length; i++)
            {
                // the below code is 2x faster than: mm = Math.max(mm, this[i]);
                if (this[i] > mm)
                {
                    mm = this[i];
                }
            }
        }
    }

    //var elapsedMs = new Date().getTime() - startTime;
    return mm;
}

///
/// timing: min(1 million item array) takes 239ms on roland's home machine (3/23/2012).
///
vp.arrayHelpers.min = function (itemFunc)
    /// signature:  min()
    ///     summary: returns the item in the array with the smallest value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var myMax = aray.min();        // myMax will be set to 1.
    ///     returns: the item in the array with the smallest value
    /// signature: min(func)
    ///     summary: returns the item in the array for which calling func produces the smallest value
    ///     paramType(func): function
    ///     snippet: var aray = [-5, 3, 0, 3];
    ///     snippet: var myMax = aray.max(Math.abs);        // myMax will be set to 0
    ///     returns: the item in the array for which calling func produces the smallest value
{
    //var startTime = new Date().getTime();
    var mm = Number.MAX_VALUE;

    if (vp.isFunction(itemFunc))
    {
        for (var i = 0; i < this.length; i++)
        {
            var value = itemFunc(this[i]);

            // the below code is 2x faster than: mm = Math.max(mm, this[i]);
            if (value < mm)
            {
                mm = value;
            }
        }
    }
    else
    {
        //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
        if (this.length <= 125 * 1000)      // just to be safe
        {
            mm = Math.min.apply(Math, this);
        }
        else
        {
            for (var i = 0; i < this.length; i++)
            {
                // the below code is 2x faster than: mm = Math.min(mm, this[i]);
                if (this[i] < mm)
                {
                    mm = this[i];
                }
            }
        }
    }

    //var elapsedMs = new Date().getTime() - startTime;
    return mm;
}

/// "select" uses the callback function to generate a value for each item in the array.  One of our
/// lightweight linq functions.
///
/// timing: select(1 million items with random() call in function) takes 1411ms on roland's home machine (3/23/2012).
///

/// renamed from "select" to "selectWithFunc" to avoid conflict with d3.
vp.arrayHelpers.selectWithFunc = function (selectFunc)
    /// signature:  selectWithFunc(func)
    ///     summary: creates a new array by calling the specified function with each element of the array
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = aray.selectWithFunc(function(n) { return 10*n; });  // newAray will be: [30, 50, 20, 10]
    ///     returns: the new array
{
    //var startTime = new Date().getTime();
    var newValues = [];

    if (!vp.isFunction(selectFunc))
    {
        throw new TypeError();
    }

    for (var i = 0; i < this.length; i++)
    {
        var elem = this[i];
        var value = selectFunc(elem, i);
        newValues.push(value);
    }

    //var elapsedMs = new Date().getTime() - startTime;

    return newValues;
}

/// "where" uses the callback function to conditionally include each record of the array in the output stream.
/// One of our lightweight linq functions.
vp.arrayHelpers.where = function (whereFunc)
    /// signature:  where(func)
    ///     summary: creates a new array by only including elements of the current array that return true for the specified function
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = aray.where(function(n) { return n >= 3; });  // newAray will be: [3, 5]
    ///     returns: the new array
{
    //var startTime = new Date().getTime();
    var newValues = [];

    for (var i = 0; i < this.length; i++)
    {
        var value = this[i];
        if (whereFunc(value, i))
        {
            newValues.push(value);
        }
    }

    //var elapsedMs = new Date().getTime() - startTime;
    return newValues;
}

/// "orderBy" uses the callback function to produce a key for each record in the array so the array can be sorted.
/// One of our lightweight linq functions.
vp.arrayHelpers.orderBy = function (keyFunc)
    /// signature:  orderBy()
    ///     summary: creates a copy of the current array with the items sorted in increasing value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = aray.orderBy();     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
    /// signature:  orderBy(func)
    ///     summary: creates a copy of the current array with the items sorted in increasing value when calling func
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, -2, 1];
    ///     snippet: var newAray = aray.orderBy(Math.abs);     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
{
    //var startTime = new Date().getTime();
    var newValues = this.slice(0);     // copy array

    if (keyFunc === undefined)
    {
        newValues.sort();
    }
    else
    {
        newValues.sort(function (a, b)
        {
            var ka = keyFunc(a);
            var kb = keyFunc(b);

            return (ka > kb) ? 1 : -1;
        });
    }

    //var elapsedMs = new Date().getTime() - startTime;
    return newValues;
}

/// "distinct" returns the values in the array with duplicates removed, based on the values returned for each
/// array entry by the idFunc.
vp.arrayHelpers.distinct = function (idFunc)
    /// signature:  distinct()
    ///     summary: creates a copy of the current array with duplicated items removed
    ///     snippet: var aray = [3, 5, 3, 1];
    ///     snippet: var newAray = aray.distinct();     // newAray will be: [3, 5, 1]
    ///     returns: the new array
    /// signature:  distinct(func)
    ///     summary: creates a copy of the current array with items that produce duplicates values (when calling func) removed
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, 3, 1];
    ///     snippet: var newAray = aray.distinct();     // newAray will be: [-3, 5, 1]
    ///     returns: the new array
{
    var dict = {};
    var newValues = [];

    for (var i = 0; i < this.length; i++)
    {
        var value = this[i];

        var id = (idFunc) ? idFunc(value) : value;
        if (!dict.hasOwnProperty(id))
        {
            //---- its unique; add it ----
            dict[id] = 1;
            newValues.push(this[i]);
        }
    }

    return newValues;
}

vp.arrayHelpers.generate = function (root, tagName, callBack)
{
    var ss = null;

    var ss = vp.generateItems(root, tagName, this);

    if (callBack)
    {
        //---- for best perf, share one singleWrapper to wrap all objects ----
        var wrapper = vp.visuals.createSingleWrapper(null);

        for (var i = 0; i < this.length; i++)
        {
            var dataItem = this[i];

            wrapper.elem = ss[i]
            wrapper[0] = ss[i];

            callBack(wrapper, dataItem, i);
        }
    }

    return ss;
}

    /// colName is optional; if specified, array entires will be treated as records and colName will be used a key
    /// to extract the value to be summed.  If not specified, array entries will be treated like numbers and summed directly.
vp.arrayHelpers.sum = function (colName)
{
    var total = 0;

    if (colName)
    {
        for (var i = 0; i < this.length; i++)
        {
            total += this[i][colName];
        }
    }
    else
    {
        for (var i = 0; i < this.length; i++)
        {
            total += this[i];
        }
    }

    return total;
}

/// this function groups data by 1 or more grouping columns.  returns an 
/// array of records:  { key: keyValue, values: recordArray }
vp.arrayHelpers.groupBy = function (groupCol1)
{
    var groupObj = {};

    //---- group the records by the specified colNames ----
    for (var i = 0; i < this.length; i++)
    {
        var record = this[i];
        var key = "";

        if (arguments.length)
        {
            //---- build key for this record ----
            for (var k = 0; k < arguments.length; k++)
            {
                var colName = arguments[k];

                if (k > 0)
                {
                    key += "^";
                }

                key += record[colName];
            }
        }
        else
        {
            //---- assume this is a vector ----
            key = record.toString();
        }

        var list = groupObj[key];
        if (list === undefined)
        {
            list = [];
            groupObj[key] = list;
        }

        list.push(record);
    }

    //---- now build list of groups to return ----
    var groups = [];
    for (var key in groupObj)
    {
        var list = groupObj[key];

        var group = { key: key, values: list };
        groups.push(group);
    }

    return groups;
}

/// this function coverts a dataset in "wide" format to "long" format.
///     - "wide" format is where each attribute is in its own column.
///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
///
/// parameters: list of id columns (those that are preserved).  Other columns are transformed into name/value columns

vp.arrayHelpers.wideToLong = function (col1)
{
    var records = [];

    if (this.length > 0)
    {
        //---- build list of OTHER columns ----
        var others = [];
        var curr = this[0];
        var preserved = vp.argumentsAsArray(arguments);

        for (var cn in curr)
        {
            if (preserved.indexOf(cn) == -1)
            {
                others.push(cn);
            }
        }

        //---- process each INPUT record ----
        for (var i = 0; i < this.length; i++)
        {
            var curr = this[i];      // input record

            //---- create an output record for each OTHER column ----
            for (var j = 0; j < others.length; j++)
            {
                var other = others[j];
                var record = {};         // output record

                //---- transfer preserved columns ----
                for (var a = 0; a < preserved.length; a++)
                {
                    var colName = preserved[a];
                    record[colName] = curr[colName];
                }

                //---- transfer OTHER column ----
                record.attribute = other;
                record.value = curr[other];
                   
                records.push(record);
            }
        }
    }

    return records;
}

/// this function coverts a dataset in "long" format to "wide" format.
///     - "wide" format is where each attribute is in its own column.
///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
///
/// parameters: 
///     - array of id columns (to define a change in the logical record)
///     - attributeColName
///     - valueColName
vp.arrayHelpers.longToWide = function (idColList, attributeColName, valueColName)
{
    var records = [];

    if (this.length > 0)
    {
        //---- emit an OUTPUT record whenever the key changes or an attribute repeats ----
        var record = {};
        var newRecord = true;

        for (var i = 0; i < this.length; i++)
        {
            var curr = this[i];
            var changed = false;

            //---- has a column in id changed? ----
            for (var a = 0; a < idColList.length; a++)
            {
                var colName = idColList[a];
                if (curr[colName] != record[colName])
                {
                    changed = true;
                    break;
                }
            }

            //---- have this record seen this attribue before? ----
            var attrName = curr.attribute;
            if (record[attrName])
            {
                changed = true;
            }

            if (changed)
            {
                if (i > 0)
                {
                    //---- output previous record ----
                    records.push(record);
                }

                record = {};
                newRecord = true;
            }

            if (newRecord)
            {
                //---- transfer id columns to new record ----
                for (var a = 0; a < idColList.length; a++)
                {
                    var colName = idColList[a];
                    record[colName] = curr[colName];
                }

                newRecord = false;
            }

            //---- transfer name/value pairs from this record ----
            record[attrName] = curr.value;
        }

        //---- add last record ----
        records.push(record);
    }

    return records;
}

//---- we extend array with each helper function using this method, so our help functions won't show up during a "for in" operation ----
vp.addMethodToPrototype = function (object, helperName, helperFunc)
{
    var prototype = object.prototype;
    if (prototype === undefined)
    {
        prototype = object;
    }

    if (prototype[helperName] === undefined)
    {
        Object.defineProperty(prototype, helperName, { enumerable: false, value: helperFunc });
    }
}

vp.addVuePlotMethodsToArray = function (arayObj)
{
    //---- now add our array helper functions ----
    vp.addMethodToPrototype(arayObj, "clone", vp.arrayHelpers.clone);
    vp.addMethodToPrototype(arayObj, "take", vp.arrayHelpers.take);
    vp.addMethodToPrototype(arayObj, "remove", vp.arrayHelpers.remove);
    vp.addMethodToPrototype(arayObj, "removeAt", vp.arrayHelpers.removeAt);
    vp.addMethodToPrototype(arayObj, "insert", vp.arrayHelpers.insert);
    vp.addMethodToPrototype(arayObj, "max", vp.arrayHelpers.max);
    vp.addMethodToPrototype(arayObj, "min", vp.arrayHelpers.min);

    vp.addMethodToPrototype(arayObj, "selectWithFunc", vp.arrayHelpers.selectWithFunc);
    vp.addMethodToPrototype(arayObj, "where", vp.arrayHelpers.where);
    vp.addMethodToPrototype(arayObj, "orderBy", vp.arrayHelpers.orderBy);
    vp.addMethodToPrototype(arayObj, "distinct", vp.arrayHelpers.distinct);
    vp.addMethodToPrototype(arayObj, "generate", vp.arrayHelpers.generate);
    vp.addMethodToPrototype(arayObj, "sum", vp.arrayHelpers.sum);
    vp.addMethodToPrototype(arayObj, "groupBy", vp.arrayHelpers.groupBy);
    vp.addMethodToPrototype(arayObj, "wideToLong", vp.arrayHelpers.wideToLong);
    vp.addMethodToPrototype(arayObj, "longToWide", vp.arrayHelpers.longToWide);
}

//---- if you pass pseudo arrays to vuePlot, call this method on one of the objects ----
vp.addVuePlotMethodsToArray(Array);

////---- short test of enumeration ----
//var myarray = [3, 5, 7];

//if (myarray.take(1).length == 1)
//{
//    for (var x in myarray)
//    {
//        if (x == "take")
//        {
//            alert("error - helper TAKE found during enumeration");
//        }
//    }
//}




﻿///-----------------------------------------------------------------------------------------------------------------
/// math.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - math helper functions.
///-----------------------------------------------------------------------------------------------------------------
//---- MATH PROTOTYPES ----
if (!Math.log10)
{
    Math.log10 = function (arg)
    {
        var result = Math.log(arg) / Math.LN10;
        return result;
    };
}





﻿///-----------------------------------------------------------------------------------------------------------------
/// rect.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - small library of flat rectangle functions   {left, top, right, bottom, width, height}
///-----------------------------------------------------------------------------------------------------------------

vp.rect = function (left, top, w, h)
{
    var rc = { left: left, top: top, width: w, height: h, right: left + w, bottom: top + h };
    return rc;
};

vp.rectFromPoints = function (pt1, pt2)
{
    var x = Math.min(pt1.x, pt2.x);
    var y = Math.min(pt1.y, pt2.y);
    var w = Math.abs(pt1.x - pt2.x);
    var h = Math.abs(pt1.y - pt2.y);

    var rc = { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };

    return rc;
};

vp.rectContainsPoint = function (rc, pt)
{
    var contains = ((pt.x >= rc.left) && (pt.x <= rc.right) && (pt.y >= rc.top) && (pt.y <= rc.bottom));
    return contains;
};

vp.rectContainsRect = function (rcOuter, rcInner)
{
    var contains = false;

    if (rcInner.left >= rcOuter.left)
    {
        if (rcInner.right <= rcOuter.right)
        {
            if (rcInner.top >= rcOuter.top)
            {
                if (rcInner.bottom <= rcOuter.bottom)
                {
                    contains = true;
                }
            }
        }
    }

    return contains;
};

vp.rectIntersectsRect = function (rc1, rc2)
{
    var overlaps = true;

    if (rc1.right < rc2.left)
    {
        overlaps = false;
    }
    else if (rc1.left > rc2.right)
    {
        overlaps = false;
    }
    else if (rc1.bottom < rc2.top)
    {
        overlaps = false;
    }
    else if (rc1.top > rc2.bottom)
    {
        overlaps = false;
    }

    return overlaps;
};

vp.rectIntersectsSvgShape = function (rc, shape)
{
    var tag = shape.tagName;
    var intersects = false;

    if (tag == "line")
    {
        var x1 = vp.attr(shape, "x1");
        var y1 = vp.attr(shape, "y1");

        var x2 = vp.attr(shape, "x2");
        var y2 = vp.attr(shape, "y2");

        intersects = vp.rectIntersectsLine(rc, x1, y1, x2, y2);
    }
    else if (tag == "polygon")
    {
        var pts = vp.attr(shape, "points");
        intersects = vp.rectIntersectsAreaPolygon(rc, pts);
    }
    else
    {
        //---- use bounding box test for all other shapes ----
        var rc2 = vp.getBounds(shape, true);

        intersects = vp.rectIntersectsRect(rc, rc2);
    }

    return intersects;
};

vp.rectIntersectsLine = function (rc, x1, y1, x2, y2)
{
    var overlaps = true;

    //---- try to reject based on x bounds of line ----
    var maxX = Math.max(x1, x2);
    var minX = Math.min(x1, x2);

    if (maxX < rc.left)
    {
        overlaps = false;
    }
    else if (minX > rc.right)
    {
        overlaps = false;
    }
    else
    {
        //--- reject based on y bounds of line ----
        var maxY = Math.max(y1, y2);
        var minY = Math.min(y1, y2);

        if (maxY < rc.top)
        {
            overlaps = false;
        }
        else if (minY > rc.bottom)
        {
            overlaps = false;
        }
        else
        {
            //---- find where line intersects left & right of rect ----
            var m = (y2 - y1) / (x2 - x1);
            var b = y2 - m * x2;

            var yLeft = m * rc.left + b;
            var yRight = m * rc.right + b;

            //---- if both are ABOVE the rect, they do not intercept ----
            if ((yLeft < rc.top) && (yRight < rc.top))
            {
                overlaps = false;
            }

            //---- if both are BELOW the rect, they do not intercept ----
            if ((yLeft > rc.bottom) && (yRight > rc.bottom))
            {
                overlaps = false;
            }
        }
    }

    return overlaps;
};

vp.parsePoints = function (str)
    /// param: str - space separated list of comma-separated number pairs
    /// returns: array of points parsed from "str".
{
    var pts = [];

    str = str.replace(/, /g, ",");      // replace all ", " chars with just comma
    str = str.replace(/  /g, " ");      // replace all double spaces with a single space

    var parts = str.split(" ");
    for (var i = 0; i < parts.length; i++)
    {
        var pps = parts[i].split(",");
        if (pps.length != 2)
        {
            vp.error("unsupported point format in shape");
        }

        var pt = { x: pps[0], y: pps[1] };
        pts.push(pt);
    }

    return pts;
};

vp.rectIntersectsAreaPolygon = function (rc, pointStr)
    /// returns true if the area polygon in "pointStr" intersects with rectangle "rc".  Note
    /// that the area polygon has 2 unique x values and 2-4 unique y values ("stacked area").
{
    var overlaps = true;
    var pts = vp.parsePoints(pointStr);

    var x1 = pts[0].x;
    var x2 = pts[2].x;

    var y1 = pts[0].y;          // left bottom
    var y2 = pts[1].y;
    var y3 = pts[2].y;
    var y4 = pts[3].y;          // right bottom

    //---- try to reject based on x bounds of area ----
    var maxX = Math.max(x1, x2);
    var minX = Math.min(x1, x2);

    if (maxX < rc.left)
    {
        overlaps = false;
    }
    else if (minX > rc.right)
    {
        overlaps = false;
    }
    else
    {
        //--- reject based on y bounds of area ----
        var maxY = Math.max(y1, y4);
        var minY = Math.min(y2, y3);

        if (maxY < rc.top)
        {
            //--- bottom of area is above top of rect ----
            overlaps = false;
        }
        else if (minY > rc.bottom)
        {
            //---- top of area is below bottom of rect ----
            overlaps = false;
        }
        else if (x1 != x2)
        {
            //---- find where TOP diagonal line (x1,y2)..(x2,y3) intersects left & right of rect ----
            var m = (y3 - y2) / (x2 - x1);
            var b = y3 - m * x2;

            var yLeft = m * rc.left + b;
            var yRight = m * rc.right + b;

            //---- if both are below the rect, they do not intercept ----
            if ((yLeft > rc.bottom) && (yRight > rc.bottom))
            {
                overlaps = false;
            }
            else
            {
                //---- find where BOTTOM diagonal line (x1,y1)..(x2,y4) intersects left & right of rect ----
                var m = (y4 - y1) / (x2 - x1);
                var b = y4 - m * x2;

                var yLeft = m * rc.left + b;
                var yRight = m * rc.right + b;

                //---- if both are above the rect, they do not intercept ----
                if ((yLeft < rc.top) && (yRight < rc.top))
                {
                    overlaps = false;
                }
            }
        }
    }

    return overlaps;
};

vp.offsetRect = function (rc, xoff, yoff)
{
    var x = rc.left + xoff;
    var y = rc.top + yoff;
    var w = rc.width;
    var h = rc.height;

    return { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// scanner.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - general purpose text scanner class
///-----------------------------------------------------------------------------------------------------------------
//---- enum: tokenType ----
vp.tokenType = { none: 0, operator: 1, id: 2, string: 3, number: 4, comment: 5, newLine: 6, eof: 7 };

//---- class: scanner ----
vp.scanner = function (str)
{
    //---- private state ----
    var index = 0;
    var tokenType = vp.tokenType.none;
    var token = "";
    var spacesSkipped = 0;

    /// closure
    var closure = function ()
    {
    };

    /// public readonly: tokenType
    closure.tokenType = function ()
    {
        return tokenType;
    };

    /// public readonly: token
    closure.token = function ()
    {
        return token;
    };

    /// public: scan()
    closure.scan = function ()
    {
        spacesSkipped = 0;

        //---- skip spaces ----
        //---- note: "160" is the ISO 8859-1 char code for "non breaking space" ----
        while ((index < str.length) && ((str[index] == " ") || (str[index] == "\t") || (str[index].charCodeAt() == 160)))
        {
            index++;
            spacesSkipped++;
        }

        if (index >= str.length)
        {
            tokenType = vp.tokenType.eof;
        }
        else
        {
            var ch = str[index];

            if (ch == "\n")
            {
                index++;
                tokenType = vp.tokenType.newLine;
            }
            else if ((index < str.length - 1) && (str[index] == "/") && (str[index + 1] == "/"))
            {
                var start = index;
                index += 2;
                while ((index < str.length) && (str[index] != "\n"))
                {
                    index++;
                }

                token = str.substring(start, index);
                tokenType = vp.tokenType.comment;
            }
            else if ((ch == "\"") | (ch == "\'"))
            {
                var quote = str[index];
                var start = index;
                index++;

                while ((index < str.length) && (str[index] != quote) && (str[index] != "\n"))
                {
                    index++;
                }

                //---- skip over ending quote ----
                if ((index < str.length) && (str[index] == quote))
                {
                    index++;
                }

                token = str.substring(start, index);
                tokenType = vp.tokenType.string;
            }
            else if ((ch >= '0') && (ch <= '9'))
            {
                var start = index;

                while ((index < str.length) && ((str[index] >= '0') && (str[index] <= '9')))
                {
                    index++;
                }

                //---- see if there is a factional part ----
                if ((index < str.length) && (str[index] == '.'))
                {
                    index++;

                    while ((index < str.length) && ((str[index] >= '0') && (str[index] <= '9')))
                    {
                        index++;
                    }
                }

                token = str.substring(start, index);
                tokenType = vp.tokenType.number;
            }
            else if ((str[index].toLowerCase() >= 'a') && (str[index].toLowerCase() <= 'z'))
            {
                var start = index;

                while (index < str.length)
                {
                    if ((str[index] >= '0') && (str[index] <= '9'))
                    {
                    }
                    else if ((str[index].toLowerCase() >= 'a') && (str[index].toLowerCase() <= 'z'))
                    {
                    }
                    else
                    {
                        break;
                    }

                    index++;
                }

                token = str.substring(start, index);
                tokenType = vp.tokenType.id;
            }
            else
            {
                token = str[index];
                index++;
                tokenType = vp.tokenType.operator;
            }
        }

        index = index;         // update our class field

        return tokenType;
    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// string.js.  Copyright (c) 2012 Microsoft Corporation.
///             part of the vuePlot library - string helper functions.
///-----------------------------------------------------------------------------------------------------------------
//---- STRING PROTOTYPES ----
if (!String.prototype.startsWith)
{
    String.prototype.startsWith = function (str)
        /// signature:  startsWith(prefix)
        ///     summary: returns true if the string starts with the specified prefix
        ///     paramType(prefix): string
        ///     snippet: var name = "Dr. Smith";
        ///     snippet: var isDoctor = name.startsWith("Dr. ");        // isDoctor will be true
        ///     returns: true if the string starts with the prefix; false otherwise
    {
        var found = false;

        if (this.substr(0, str.length) == str)
        {
            found = true;
        }

        return found;
    };
}

if (!String.prototype.endsWith)
{
    String.prototype.endsWith = function (str)
        /// signature:  endsWith(suffix)
        ///     summary: returns true if the string ends with the specified suffix
        ///     paramType(suffix): string
        ///     snippet: var animal = "cats";
        ///     snippet: var isPlural = animal.endsWith("s");        // isPlural will be true
        ///     returns: true if the string ends with the suffix; false otherwise
    {
        var found = false;

        if (this.substr(this.length - str.length, str.length) == str)
        {
            found = true;
        }

        return found;
    };
}

if (!String.prototype.ltrim)
{
    String.prototype.ltrim = function ()
        /// signature:  ltrim()
        ///     summary: return the string with the leading spaces removed
        ///     snippet: var name = " cat ";
        ///     snippet: var newName = name.ltrim();         // newName will be "cat "
        ///     returns: returns the newly trimmed string
    {
        var value = this;
        if (value.length > 0)
        {
            var i = 0;

            while ((value[i] == ' ') || (value[i] == '\t'))
            {
                i++;
                if (i >= value.length)
                {
                    break;
                }
            }

            value = this.substring(i);
        }

        return value;
    };
}

if (!String.prototype.rtrim)
{
    String.prototype.rtrim = function ()
        /// signature:  rtrim()
        ///     summary: return the string with the trailing spaces removed
        ///     snippet: var name = " cat ";
        ///     snippet: var newName = name.rtrim();         // newName will be " cat"
        ///     returns: returns the newly trimmed string
    {
        var value = this;
        if (value.length > 0)
        {
            var i = value.length - 1;

            while ((value[i] == ' ') || (value[i] == '\t'))
            {
                i--;
                if (i < 0)
                {
                    break;
                }
            }

            value = this.substring(0, i + 1);
        }

        return value;
    };
}

if (!String.prototype.trim)
{
    String.prototype.trim = function ()
        /// signature:  trim()
        ///     summary: return the string with the leading and trailing spaces removed
        ///     snippet: var name = " cat ";
        ///     snippet: var newName = name.trim();         // newName will be "cat"
        ///     returns: returns the newly trimmed string
    {
        var value = this.ltrim();
        value = value.rtrim();

        return value;
    };
}

if (!String.prototype.contains)
{
    String.prototype.contains = function (substr)
        /// signature:  contains(str)
        ///     summary: return true if the string contains the "str" substring
        ///     paramType(str): string
        ///     snippet: var animals = "dog, cat, rabbit";
        ///     snippet: var hasCat = animals.contains("cat");         // hasCat will be true
        ///     returns: returns true if the string contains the substring; false otherwise
    {
        var index = this.indexOf(substr);
        return index > -1;
    };
}

﻿///-----------------------------------------------------------------------------------------------------------------
/// utilities.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------

///---- wrap call to func so that its "this" is set correctly ----
vp.cb = function (thisObj, func)
    /// signature:  cb(func, thisObj)
    ///     summary: creates a wrapper function that will call "func" with its this pointer set to "thisObj"
    ///     paramType(thisObj): object
    ///     paramType(func): function
    ///     snippet: setTimeout(vp.cb(this, myFunc), 200);   // will call "myFunc" in 200 ms with this set correctly
    ///     returns: the newly created wrapper function
{
    var wrapper = function (thisObj, func)
    {
        if ((!thisObj) || (!func))
        {
            vp.error("Bad vp.cb() call: both arguments must be non-null");
        }

        this.thisObj = thisObj;
        this.func = func;
        var self = this;

        this.callIt = function ()
        {
            return self.func.apply(self.thisObj, arguments);
        };
    };

    var wrapFunc = new wrapper(thisObj, func);
    return wrapFunc.callIt;
};

vp.createHtml = function (tagName)
/// public: createHtml(tagName)
/// action: creates an HTML element with the specified tagName.
/// returns: the newly created element (unwrapped)
{
    var element = document.createElement(tagName);
    return element;
};

vp.createSvg = function (tagName)
/// public: createSvg(tagName)
/// action: creates an SVG document or element with the specified tagName.
/// returns: the newly created element (unwrapped)
{
    var nsSvg = "http://www.w3.org/2000/svg";
    var svgElem = document.createElementNS(nsSvg, tagName);

    return svgElem;
};

vp.createElement = function(parent, tagName)
/// public: createElement(parent, tagName)
/// action: creates an HTML, SVG, or CANVAS element with the specified tagName.
/// returns: the newly created element (unwrapped)
{
    var element = null;

    var parentElem = (parent.element) ? parent.element() : parent;

    if ((tagName.toLowerCase() == "svg") || (vp.isSvgDocOrElement(parentElem)))
    {
        //---- normal SVG container ----
        element = document.createElementNS('http://www.w3.org/2000/svg', tagName);
    }
    else
    {
        var tagNameLower = tagName.toLowerCase();
        var element = null;

        if (tagNameLower.startsWith("vp."))
        {
            var ctr = eval(tagName);
            if (vp.isFunction(ctr))
            {
                //---- create the vuePlot visual control ----
                var obj = ctr.call();
                if (vp.isDefined(obj.tagName))      // its an element
                {
                    element = obj;
                }
                else
                {
                    element = obj.domElement;
                }
            }
        }
        else
        {
            //---- regular HTML element ----
            element = document.createElement(tagName);
        }
    }

    return element;
};

/// this was created to help speed up our slow create and append routines by looping at the 
/// lowest level possible.
vp.createElements = function (parent, tagName, count)
    /// public: createElements(parent, tagName)
    /// action: creates the specific "count" of HTML, SVG, or CANVAS element with the specified tagName.
    /// returns: the newly created elements (unwrapped)
{
    var elements = [];

    var parentElem = (parent.element) ? parent.element() : parent;

    if ((tagName.toLowerCase() == "svg") || (vp.isSvgDocOrElement(parentElem)))
    {
        //---- normal SVG container ----
        for (var i = 0; i < count; i++)
        {
            var element = document.createElementNS('http://www.w3.org/2000/svg', tagName);
            elements[i] = element;
        }
    }
    else
    {
        var tagNameLower = tagName.toLowerCase();
        var element = null;

        if (tagNameLower.startsWith("vp."))
        {
            var ctr = eval(tagName);
            if (vp.isFunction(ctr))
            {
                for (var i = 0; i < count; i++)
                {
                    //---- create the vuePlot visual control ----
                    var obj = ctr.call();
                    if (vp.isDefined(obj.tagName))      // its an element
                    {
                        element = obj;
                    }
                    else
                    {
                        element = obj.domElement;
                    }

                    elements[i] = element;
                }
            }
        }
        else
        {
            //---- regular HTML element ----
            for (var i = 0; i < count; i++)
            {
                element = document.createElement(tagName);
                elements[i] = element;
            }
        }
    }

    return elements;
};

vp.mapValue = function (value, fromMin, fromMax, toMin, toMax)
{
    var range = fromMax - fromMin;
    var percent = (range) ? (value - fromMin) / range : 1;

    var newValue = toMin + percent * (toMax - toMin);
    return newValue;
};

///
/// timing: range(1000*1000) takes 842ms on roland's home machine (3/23/2012).
///
vp.range = function (from, to, incr)
{
    //var startTime = new Date().getTime();
    var values = [];

    if (vp.isUndefined(incr))
    {
        incr = 1;
    }

    if (vp.isUndefined(to))
    {
        to = from;
        from = 1;
    }

    //---- guard against infinite loops ----
    if (incr == 0)
    {
    }
    else if ((from < to) && (incr < 0))
    {
    }
    else if ((from > to) && (incr > 0))
    {
    }
    else
    {
        //---- emit normal range ----
        for (var value = from; vp.floatLeq(value, to) ; value += incr)
        {
            values.push(value);
        }
    }

    //var elapsedMs = new Date().getTime() - startTime;
    return values;
};


/// get a list of the key/value parameters for the current page url.
vp.getCmdParams = function (cmd)
{
    var params = {};

    if (cmd)
    {
        var pairs = cmd.split("&");
        for (var i = 0; i < pairs.length; i++)
        {
            var pair = pairs[i];
            var pp = pair.split("=");

            if (pp.length > 1)
            {
                params[pp[0]] = pp[1];
            }
            else
            {
                params[pp] = "";
            }
        }
    }

    return params;
};

/// get a list of the key/value parameters for the current page url.
vp.getUrlParams = function ()
{
    var url = window.location.href;
    var params = {};

    var index = url.indexOf("?");
    if (index == -1)
    {
        //---- using hash tag to save state? ----
        index = url.indexOf("#");
    }

    if (index > -1)
    {
        params = vp.getCmdParams(url.substring(index + 1));
    }

    return params;
};

/// returns the directory portion of the current page's URL (excludes the page name)
vp.getUrlDirectory = function ()
{
    var url = window.location.href;
    var index = url.lastIndexOf("/");
    if (index > -1)
    {
        url = url.substr(0, index);
    }

    return url;  
};

/// send "msg" to the browser debug console, if present. 
vp.debug = function (msg)
{
    if (window.console && window.console.log)
    {
        console.log(msg);
    }
};

/// test condition - use alert if false
vp.assert = function (cond, msg)
{
    if (! cond)
    {
        alert("vp.assert: conditon failed");
    }
};

/// used for floating point comparisons.
vp.epsilon = .00001;

/// return true if a <= b (using floating point comparison).
vp.floatLeq = function (a, b)
{
    return (b - a) >= -vp.epsilon;
}

vp.floatLess = function (a, b)
{
    return (! vp.floatGeq(a, b));
}

/// return true if a >= b (using floating point comparison).
vp.floatGeq = function (a, b)
{
    return (a - b) >= -vp.epsilon;
}

/// return true if a == b (using floating point comparison).
vp.floatEq = function (a, b)
{
    return Math.abs(a - b) <= vp.epsilon;
}

/// add "keys" (list of dict properties) for browsers (like IE) that don't yet implement it.
vp.keys = function (obj)
{
    var keys = [];

    if (obj)
    {
        if (obj.keys)
        {
            keys = obj.keys;
        }
        else
        {
            for (var k in obj)
            {
                if (obj.hasOwnProperty(k))
                {
                    keys.push(k);
                }
            }
        }
    }

    return keys;
}

/// return true if object has one or more dictionary keys.
vp.hasKeys = function (obj)
{
    /// fastest cross-browser test
    var count = 0;

    for (var k in obj)
    {
        count++;
        break;
    }

    return (count > 0);
};


//--- opera doesn't have Object.keys so we use this wrapper ----
vp.numberOfKeys = function (theObject)
{
    if (Object.keys)
        return Object.keys(theObject).length;

    var n = 0;
    for (var key in theObject)
        ++n;

    return n;
};

vp.clamp = function (value, min, max)
{
    if (value < min)
    {
        value = min;
    }
    else if (value > max)
    {
        value = max;
    }

    return value;
};


/// return the size of the text in a SPAN element whose class is the specified class.
vp.measureText = function (text, spanClass)
{
    var span = document.createElement("span");
    document.body.appendChild(span);
    vp.text(span, text);
    vp.setClass(span, spanClass);

    var sz = { width: vp.width(span), height: vp.height(span) };
    document.body.removeChild(span);

    return sz;
};

/// return the size of the text in an SVG element whose class is the specified class.
vp.measureSvgText = function (svgNode, text, className)
{
    var textElem = document.createElementNS('http://www.w3.org/2000/svg', "text");
    svgNode.append(textElem);
    vp.setClass(textElem, className);

    var xx = vp.getBounds(textElem);

    var rect = textElem.getBoundingClientRect();
    svgNode.remove(textElem);

    var sz = { width: rect.width, height: rect.height };
    return sz;
};

vp.argumentsAsArray = function (args)
{
    var array = [];

    for (var a = 0; a < args.length; a++)
    {
        array.push(args[a]);
    }
    return array;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// basicSelect.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - select function and related support.
///              Note: this file must be processed first in its folder.
///-----------------------------------------------------------------------------------------------------------------

/// internal.
/// elements: the list of collected elements to add matches to.
vp.getElementsCore = function (elements, parentElem, byId, byClass, byTag, byColon, name)
{
    //vp.debug("getElementsCore: parentElem=" + parentElem + ", parentElem.tagName=" + parentElem.tagName);

    if ((parentElem.id == "canvases") || (parentElem.id == "2dRect"))
    {
        var dummy2 = 0;
    }

    var kids = vp.children(parentElem);
    if ((kids) && (kids.length > 0))
    {
        for (var i = 0; i < kids.length; i++)
        {
            var elem = kids[i];

            if (elem.tagName == "svg")
            {
                var a = 9;
            }

            if (byId)
            {
                if (elem.id == name)
                {
                    elements.push(elem);
                }
            }
            else if (byTag)
            {
                if ((elem.tagName) && (elem.tagName.toLowerCase() == name))
                {
                    elements.push(elem);
                }
            }
            else if (byColon)
            {
                if (vp.colonTest(elem, name))
                {
                    elements.push(elem);
                }
            }
            else if (byClass)
            {
                if (vp.hasClass(elem, name))
                {
                    elements.push(elem);
                }
            }
            else
            {
                //---- must be "*" (include everything) ----
                elements.push(elem);
            }

            var grandKids = vp.children(elem);
            if ((grandKids) && (grandKids.length > 0))
            {
                //---- search the children of "elem" and add the matches to "elements" ----
                vp.getElementsCore(elements, elem, byId, byClass, byTag, byColon, name);
            }
        }
    }
};

/// internal: return true if element meets condition of specified colon filter
vp.colonTest = function (elem, name)
{
    var meets = false;

    /// for perf reasons, we don't call out to utility functions to check for values; that
    /// cross-browser code is duplicated here.
    if (elem != null)
    {
        if (name == "checked")
        {
            meets = elem.checked;
        }
        else if (name == "hidden")
        {
            meets = (elem.visibility == "hidden");
        }
        else if (name == "visible")
        {
            meets = (elem.visibility != "hidden");
        }
        else if (name == "selected")
        {
            meets = (elem.selected === true);
        }
        else if (name == "checked")
        {
            meets = (elem.checked === true);
        }
        else if (name == "disabled")
        {
            meets = (elem.disabled)
        }
        else if (name == "enabled")
        {
            meets = (elem.disabled === undefined);
        }
        else if (name == "input")
        {
            meets = (elem.tagName.toLowerCase() == "input");
        }
        else if (name == "radio")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "radio"));
        }
        else if (name == "button")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
        }
        else if (name == "checkbox")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "checkbox"));
        }
        else if (name == "button")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
        }
        else if (name == "password")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "password"));
        }
        else if (name == "text")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "text"));
        }
        else if (name == "submit")
        {
            meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "submit"));
        }
    }
    return meets;
};

/// internal
vp.getElementsInSelectorString = function (parentElem, selector)
{
    var ss = selector.trim();
    var elements = [];
    var byId = false;
    var byTag = false;
    var byClass = false;
    var byColon = false;

    var name = "";

    if (parentElem == null)
    {
        parentElem = document;
    }
    else if (parentElem.length)
    {
        parentElem = parentElem[0];     // unwrap parent, if needed
    }

    //---- keep it very simple for now ----
    if (ss.startsWith("#"))
    {
        byId = true;
        name = ss.substring(1).ltrim();
    }
    else if (ss.startsWith("."))
    {
        byClass = true;
        name = ss.substring(1).ltrim();
    }
    else if (ss.startsWith(":"))
    {
        byColon = true;
        name = ss.substring(1).ltrim();
    }
    else if (ss != "*")
    {
        byTag = true;
        name = ss.toLowerCase();
    }

    vp.getElementsCore(elements, parentElem, byId, byClass, byTag, byColon, name);

    return elements;
};


vp.select = function (p1, p2)
    /// signature: vp.select()
    ///     summary: creates an empty selected set
    ///     snippet: var ss = $();            // create an empty selected set
    ///     returns: the newly created selection set
    /// signature: vp.select(element)
    ///     summary: creates a new selected set containing the element
    ///     paramType(element): HTML, SVG, or Canvas document/element
    ///     snippet: var ss = $(myDivElement);        // wrap the element in a selected set
    ///     returns: the newly created selection set
    /// signature: vp.select(array)
    ///     summary: adds each element of the array to a new set
    ///     paramType(array): an array of elements
    ///     snippet: var aray = [elem1, elem2, elem3];
    ///     snippet: var ss = $(a);
    ///     returns: the newly created selection set
    /// signature: vp.select(selector)
    ///     summary: creates a set from each element in the document that matches the css selector string
    ///     paramType(selector): string
    ///     snippet: var ss = $("#myId");         // select all elements with the id "myId"
    ///     returns: the newly created selection set
    /// signature: vp.select(parent, selector)
    ///     summary: creates a set from each element in the parent that matches the css selector string
    ///     paramType(parent): HTML, SVG, or Canvas document/element
    ///     paramType(selector): string
    ///     snippet: var ss = $(myDiv, "a");      // select all anchors within myDiv
    ///     returns: the newly created selection set
{
    var parentElem = null;
    var selector = null;

    if (p2)
    {
        //---- selection string specified ----
        parentElem = p1;
        selector = p2;
    }
    else if (vp.isString(p1))
    {
        //---- only p1=string specified ----
        parentElem = document.body;
        selector = p1;
    }
    else
    {
        //---- only p1=NON-string specified ----
        parentElem = p1;
        selector = null;
    }

    //return new vp.selectedSet(rootElement, selectStr);

    if (vp.isString(selector))
    {
        var elems = vp.getElementsInSelectorString(parentElem, selector);
        return vp.wrapElements(elems);
    }
    else if (vp.isArray(parentElem))
    {
        return vp.wrapElements(parentElem);
    }
    else if (parentElem != null)
    {
        return vp.wrapElements(parentElem);
    }
    else
    {
        return new vp.selectedSet();        // empty selected set
    }
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// insertAppend.js.  Copyright (c) 2012 Microsoft Corporation.
///                   part of the vuePlot library - handles inserting and appending content to containers.
///-----------------------------------------------------------------------------------------------------------------

/// internal.
vp.insertOrAppend = function (container, child, insertOp)
{
    var returnValue = null;

    var addingToContainer = ((insertOp == "append") || (insertOp == "prepend"));

    if ((insertOp == "append") || ((addingToContainer) && (container.children.length == 0)))
    {
        returnValue = container.appendChild(child);
    }
    else if (insertOp == "prepend")
    {
        returnValue = container.insertBefore(child, container.children[0]);
    }
    else if (insertOp == "insertBefore")
    {
        var parent = container.parentNode;
        returnValue = parent.insertBefore(child, container);
    }
    else if (insertOp == "insertAfter")
    {
        var parent = container.parentNode;
        returnValue = parent.insertBefore(child, container.nextSibling);
    }

    return returnValue;
};

//---- INTERNAL: appends the content into the container, using the specified insertOp, and returns ----
//---- an array of appended elements. ----
vp.appendCoreSingle = function (container, content, insertOp)
{
    var appendedElements = [];

    //---- look for all 3 "select set" types ----
    if (content instanceof vp.selectedSet)
    {
        content = content.toArray();
    }
    else if (content.ctr == "vp.canvasSelectedSet")
    {
        content = content.toArray();
    }
    else if (content instanceof vp.visuals.singleWrapperClass)
    {
        //---- special handling since "content" is already wrapped ----
        var element = vp.insertOrAppend(container, content.elem, insertOp);

        appendedElements = content;      // already wrapped (don't rewrap)
    }

    if (appendedElements.length == 0)
    {
        if (vp.isArray(content))
        {
            for (var i = 0; i < content.length; i++)
            {
                var child = content[i];
                var element = vp.insertOrAppend(container, child, insertOp);

                appendedElements.push(element);
            }
        }
        else if (vp.isString(content))
        {
            var element = vp.createElement(container, content);
            if (element != null)
            {
                //---- transfer data info from parent container ----
                element.dataItem = container.dataItem;
                element.dataIndex = container.dataIndex;

                vp.insertOrAppend(container, element, insertOp);

                appendedElements.push(element);
            }
        }
        else if (vp.isFunction(content))
        {
            //---- call func to get content to append ----
            var elemFromFunc = content(index, this);

            var element = vp.insertOrAppend(container, elemFromFunc, insertOp);

            appendedElements.push(element);
        }
        else if (content != null)
        {
            var element = vp.insertOrAppend(container, content, insertOp);

            appendedElements.push(element);
        }
    }

    return appendedElements;
};

//---- add specified content to container & return added elements as ARRAY ----
//---- seems to be used only for HTML "select" element? ----
//---- TODO: merge this with "vp.appendCoreSingle" (using a callBack functon to do the append/insert/add!) ----

vp.add = function (container, content)
{
    var addedElements = [];

    //---- look for all 3 "select set" types ----
    if (content instanceof vp.selectedSet)
    {
        content = content.toArray();
    }
    else if (content.ctr == "vp.canvasSelectedSet")
    {
        content = content.toArray();
    }
    else if (content instanceof vp.visuals.singleWrapperClass)
    {
        content = [content.elem];
    }

    if (vp.isArray(content))
    {
        for (var i = 0; i < content.length; i++)
        {
            var child = content[i];
            var element = container.add(child);
            addedElements.push(element);
        }
    }
    else if (vp.isString(content))
    {
        if (vp.isSvgDocOrElement(container))
        {
            //---- normal SVG container ----
            var element = document.createElementNS('http://www.w3.org/2000/svg', content);
            if (element != null)
            {
                //---- transfer data info from parent container ----
                element.dataItem = container.dataItem;
                element.dataIndex = container.dataIndex;

                container.add(element);
                addedElements.push(element);
            }
        }
        else
        {
            //---- regular HTML element ----
            var element = document.createElement(content);
            if (element != null)
            {
                //---- transfer data info from parent container ----
                element.dataItem = container.dataItem;
                element.dataIndex = container.dataIndex;

                container.add(element);
                addedElements.push(element);
            }
        }
    }
    else if (content != null)
    {
        container.add(content);
        addedElements.push(element);
    }

    return addedElements;
};

//---- append into specified container and return elements in a wrapper ----
vp.append = function (container, content)
{
    var elements = null;

    if (container.append)      // canvas group 
    {
        elements = container.append(content);
    }
    else
    {
        elements = vp.appendCoreSingle(container, content, "append");
    }

    if (!vp.isSelectedSet(elements))
    {
        elements = vp.wrapElements(elements);
    }

    return elements;
};

//---- append into specified container ----
vp.appendElements = function (container, elements)
{
    if (container.append)      // canvas group 
    {
        for (var i = 0; i < elements.length; i++)
        {
            container.append(elements[i]);
        }
    }
    else
    {
        for (var i = 0; i < elements.length; i++)
        {
            container.appendChild(elements[i]);
        }
    }
};

//---- prepend into specified container ----
vp.prepend = function (container, content)
{
    var elements = vp.appendCoreSingle(container, content, "prepend");
    return vp.wrapElements(elements);
};

//---- insert content before specified container ----
vp.insertBefore = function (container, content)
{
    var elements = vp.appendCoreSingle(container, content, "insertBefore");
    return vp.wrapElements(elements);
};

//---- insert content after specified container ----
vp.insertAfter = function (container, content)
{
    var elements = vp.appendCoreSingle(container, content, "insertAfter");
    return vp.wrapElements(elements);
};

/// INTERNAL.
vp.appendCoreMulti = function (self, content, insertOp)
{
    var appendedElements = [];
    var firstContainer = true;

    self.each(function (index, container)
    {
        var newElements = vp.appendCoreSingle(container, content, insertOp);
        if (firstContainer)
        {
            appendedElements = newElements;
            firstContainer = false;
        }
    });

    var ss = vp.wrapElements(appendedElements);
    return ss;
};


//---- APPEND the content to the selected set of containers ----
vp.fn.append = function (content)
    /// signature: ss.append(element)
    ///     summary: adds the specified element to the end of the children's list for the items in the set.
    ///     paramType(element): the element to be appended.
    ///     snippet: $("#mydiv").append(mySpan);        // append the element mySpan to myDiv
    ///     returns: a new selected set consisting of the appended elements.
    /// signature: ss.append(tag)
    ///     summary: for each item in the set, creates an element from the tag and adds it to the end of the item's children's list.
    ///     paramType(tag): string.
    ///     snippet: $("div").append("span");        // append a new span to each div
    ///     returns: a new selected set consisting of the appended elements.
    /// signature: ss.append(elemArray)
    ///     summary: for each item in the set, add each element of the array to the end of the item's children's list.
    ///     paramType(elemArray): array of elements to append.
    ///     snippet: var aray = [span1, span2, span3];
    ///     snippet: $("#div1").append(aray);        // append the 3 spans to div1
    ///     returns: a new selected set consisting of the appended elements.
    /// signature: ss.append(ssElems)
    ///     summary: for each item in the set, add each element of ssElems to the end of the item's children's list.
    ///     paramType(ssElems): a selected set of elements to be appended.
    ///     snippet: var ssElems = $(".detailSpan");    // create a ss of all spans with the class "detailSpan"
    ///     snippet: $("#div1").append(ssElems);        // append all spans from ssElems to div1
    ///     returns: a new selected set consisting of the appended elements.
{
    return vp.appendCoreMulti(this, content, "append");
};

vp.fn.prepend = function (content)
    /// signature: ss.prepend(element)
    ///     summary: adds the specified element to the front of the children's list for the items in the set.
    ///     paramType(element): the element to be appended.
    ///     snippet: $("#mydiv").prepend(mySpan);        // prepend the element mySpan to myDiv
    ///     returns: a new selected set consisting of the added elements.
    /// signature: ss.prepend(tag)
    ///     summary: for each item in the set, creates an element from the tag and adds it to the front of the item's children's list.
    ///     paramType(tag): string.
    ///     snippet: $("div").prepend("span");        // prepend a new span to each div
    ///     returns: a new selected set consisting of the added elements.
    /// signature: ss.prepend(elemArray)
    ///     summary: for each item in the set, add each element of the array to the front of the item's children's list.
    ///     paramType(elemArray): array of elements to append.
    ///     snippet: var aray = [span1, span2, span3];
    ///     snippet: $("#div1").prepend(aray);        // prepend the 3 spans to div1
    ///     returns: a new selected set consisting of the added elements.
    /// signature: ss.prepend(ssElems)
    ///     summary: for each item in the set, add each element of ssElems to the front of the item's children's list.
    ///     paramType(ssElems): a selected set of elements to be appended.
    ///     snippet: var ssElems = $(".detailSpan");    // create a ss of all spans with the class "detailSpan"
    ///     snippet: $("#div1").prepend(ssElems);        // prepend all spans from ssElems to div1
    ///     returns: a new selected set consisting of the added elements.
{
    return vp.appendCoreMulti(this, content, "prepend");
};

vp.fn.insertBefore = function (content)
{
    return vp.appendCoreMulti(this, content, "insertBefore");
};

vp.fn.insertAfter = function (content)
{
    return vp.appendCoreMulti(this, content, "insertAfter");
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// singleWrapper.js.  Copyright (c) 2012 Microsoft Corporation.
///                    part of the vuePlot library - wraps a single element for method chaining & 
///                    vuePlot API access.
///-----------------------------------------------------------------------------------------------------------------

/// wraps a single element for method chaining & vuePlot API access.
vp.singleWrapper = function (elem)
{
    this.elem = elem;
    this.ctr = "vp.singleWrapper";

    //---- we want calling code to be able to treat this as an array (so it doesn't have to special case ss vs. this) ----
    this.length = 0;

    //---- make "selectedSet" look/act like an array object ---
    this.push = Array.prototype.push;
    this.splice = Array.prototype.splice;
    this.indexOf = Array.prototype.indexOf;
    this.select = Array.prototype.select;

    this.push(elem);

    //---- extend this wrapper if elem with custom control properties ----

    if ((elem) && (elem.control) && (elem.control.extendWrapper))
    {
        elem.control.extendWrapper(this);
    }
};

vp.sw = vp.singleWrapper.prototype;

vp.sw.element = function ()
{
    return this.elem;
};

vp.sw.css = function (name, value)
{
    if (arguments.length == 1)
    {
        return vp.css(this.elem, name);
    }

    vp.css(this.elem, name, value);
    return this;
};

vp.sw.bounds = function (x, y, width, height)
{
    vp.bounds(this.elem, x, y, width, height);
    return this;
};

vp.sw.colors = function (fill, stroke, strokeWidth)
{
    vp.colors(this.elem, fill, stroke, strokeWidth);
    return this;
};

vp.sw.text = function (value)
{
    if (arguments.length == 0)
    {
        return vp.text(this.elem);
    }

    vp.text(this.elem, value);
    return this;
};

vp.sw.tabIndex = function (value)
{
    if (arguments.length == 0)
    {
        return vp.tabIndex(this.elem);
    }

    vp.tabIndex(this.elem, value);
    return this;
};

vp.sw.title = function (value)
{
    if (arguments.length == 0)
    {
        return vp.title(this.elem);
    }

    vp.title(this.elem, value);
    return this;
};

vp.sw.value = function (value)
{
    if (arguments.length == 0)
    {
        return vp.value(this.elem);
    }

    vp.value(this.elem, value);
    return this;
};

vp.sw.html = function (value)
{
    if (arguments.length == 0)
    {
        return vp.html(this.elem);
    }

    vp.html(this.elem, value);
    return this;
};

vp.sw.show = function (showIt)
{
    vp.show(this.elem, showIt);
    return this;
};

vp.sw.showToggle = function ()
{
    vp.showToggle(this.elem);
    return this;
};

vp.sw.hide = function ()
{
    vp.hide(this.elem);
    return this;
};

vp.sw.collapse = function ()
{
    vp.collapse(this.elem);
    return this;
};

vp.sw.expand = function ()
{
    vp.expand(this.elem);
    return this;
};

vp.sw.dataIndex = function (value)
{
    if (arguments.length == 0)
    {
        return vp.dataIndex(this.elem);
    }

    vp.dataIndex(this.elem, value);
    return this;
};

vp.sw.dataItem = function (value)
{
    if (arguments.length == 0)
    {
        return vp.dataItem(this.elem);
    }

    vp.dataItem(this.elem, value);
    return this;
};

vp.sw.dataPair = function (dataItem, dataIndex)
{
    vp.dataPair(this.elem, dataItem, dataIndex);
    return this;
};

//---- warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. ----
vp.sw.dataBind = function (bindingName, data, pkFunc, isNewData)
{
    return vp.dataBind(this.elem, this, bindingName, data, pkFunc, isNewData);
};

vp.sw.to = function (x, y)
{
    vp.to(this.elem, x, y);
    return this;
};

vp.sw.from = function (x, y)
{
    vp.from(this.elem, x, y);
    return this;
};

vp.sw.attach = function (name, callBack)
{
    vp.attach(this.elem, name, callBack);
    return this;
};

vp.sw.detach = function (name, callBack)
{
    vp.detach(this.elem, name, callBack);
    return this;
};

vp.sw.transform = function (value)
{
    if (arguments.length == 0)
    {
        return vp.transform(this.elem);
    }

    vp.transform(this.elem, value);
    return this;
};

vp.sw.translate = function (x, y)
{
    vp.translate(this.elem, x, y);
    return this;
};

vp.sw.transformOrigin = function (value)
{
    if (arguments.length == 0)
    {
        return vp.transformOrigin(this.elem);
    }

    vp.transformOrigin(this.elem, value);
    return this;
};

vp.sw.href = function (value)
{
    if (arguments.length == 0)
    {
        return vp.href(this.elem);
    }

    vp.href(this.elem, value);
    return this;

   // return vp.attrNS("http://www.w3.org/1999/xlink", "href", value);
};

vp.sw.safeHref = function (value, fallback)
{
    if ((! value) || (value.length == 0))
    {
        value = fallback;
    }

    vp.href(this.elem, value);
    return this;
};

vp.sw.font = function (family, size, weight, style)
{
    vp.font(this.elem, family, size, weight, style);
    return this;
};

vp.sw.setClass = function (value)
{
    vp.setClass(this.elem, value);
    return this;
};

vp.sw.hasClass = function (value)
{
    var returnValue = vp.hasClass(this.elem, value);
    return returnValue;
};

vp.sw.addClass = function (value)
{
    vp.addClass(this.elem, value);
    return this;
};

vp.sw.removeClass = function (value)
{
    vp.removeClass(this.elem, value);
    return this;
};

vp.sw.toggleClass = function (value)
{
    vp.toggleClass(this.elem, value);
    return this;
};

vp.sw.id = function (value)
{
    if (arguments.length == 0)
    {
        return vp.id(this.elem);
    }

    vp.id(this.elem, value);
    return this;
};

// CHW: new function
vp.sw.getBounds = function (relToParent)
{
    return vp.getBounds(this.elem, relToParent);
};

vp.sw.center = function (cx, cy)
{
    vp.center(this.elem, cx, cy);
    return this;
};

vp.sw.position = function (x, y)
{
    vp.position(this.elem, x, y);
    return this;
};

vp.sw.absPosition = function (left, top)
{
    vp.absPosition(this.elem, left, top);
    return this;
};

vp.sw.opacity = function (value)
{
    if (arguments.length == 0)
    {
        return vp.opacity(this.elem);
    }

    vp.opacity(this.elem, value);
    return this;
};

vp.sw.radius = function (value)
{
    if (arguments.length == 0)
    {
        return vp.radius(this.elem);
    }

    vp.radius(this.elem, value);
    return this;
};

vp.sw.attr = function (name, value)
{
    if (arguments.length == 1)
    {
        return vp.attr(this.elem, name);
    }

    vp.attr(this.elem, name, value);
    return this;
};

vp.sw.customAttr = function (name, value)
{
    if (arguments.length == 1)
    {
        return vp.customAttr(this.elem, name);
    }

    vp.customAttr(this.elem, name, value);
    return this;
};

//---- these are one and the same ----
vp.sw.prop = vp.sw.customAttr;

vp.sw.remove = function ()
{
    vp.remove(this.elem);
    return this;
};

vp.sw.toolTipEnabled = function (value)
{
    if (arguments.length == 0)
    {
        return vp.toolTipEnabled(this.elem);
    }

    vp.toolTipEnabled(this.elem, value);
    return this;
};

vp.sw.height = function (value)
{
    if (arguments.length == 0)
    {
        return vp.height(this.elem);
    }

    vp.height(this.elem, value);
    return this;
};

vp.sw.width = function (value)
{
    if (arguments.length == 0)
    {
        return vp.width(this.elem);
    }

    vp.width(this.elem, value);
    return this;
};

vp.sw.totalHeight = function ()
{
    return vp.totalHeight(this.elem);
};

vp.sw.totalWidth = function ()
{
    return vp.totalWidth(this.elem);
};

vp.sw.left = function (value)
{
    if (arguments.length == 0)
    {
        return vp.left(this.elem);
    }

    vp.left(this.elem, value);
    return this;
};
    
vp.sw.top = function (value)
{
    if (arguments.length == 0)
    {
        return vp.top(this.elem);
    }

    vp.top(this.elem, value);
    return this;
};

vp.sw.checked = function (value)
{
    if (arguments.length == 0)
    {
        return vp.checked(this.elem);
    }

    vp.checked(this.elem, value);
    return this;
};

vp.sw.clear = function ()
{
    vp.clear(this.elem);
    return this;
};

vp.sw.add = function (content)
{
    var elems = vp.add(this.elem, content);
    var ss = vp.wrapElements(elems);

    return ss;
};


vp.sw.append = function (content)
{
    var ss = vp.append(this.elem, content);
    return ss;
};

vp.sw.prepend = function (content)
{
    var ss = vp.prepend(this.elem, content);
    return ss;
};

vp.sw.insertBefore = function (content)
{
    var ss = vp.insertBefore(this.elem, content);
    return ss;
};

vp.sw.insertAfter = function (content)
{
    var ss = vp.insertAfter(this.elem, content);
    return ss;
};

vp.sw.addStop = function (offset, color, opacity)
{
    vp.addStop(this.elem, offset, color, opacity);
    return this;
};

vp.sw.animate = function (duration, ease, container)
{
    vp.animate(this.elem, duration, ease, container);
    return this;
};

vp.sw.frameRateChanged = function (callBack)
{
    vp.frameRateChanged(this.elem, callBack);
};

/// creates a new selectedSet from the current this.elem and the specified element/array.
vp.sw.merge = function (elemOrArray)
{
    var newElements = null;

    if (elemOrArray instanceof vp.selectedSet)
    {
        elemOrArray = elemOrArray.toArray();
    }
    else if (elemOrArray instanceof vp.singleWrapper)
    {
        elemOrArray = elemOrArray.elem;
    }

    if (vp.isArray(elemOrArray))
    {
        newElements = this.toArray().concat(elemOrArray);
    }
    else
    {
        newElements = this.toArray();
        newElements.push(elemOrArray);
    }

    var newSet = new vp.selectedSet(newElements);

    return newSet;
};

vp.sw.toArray = function ()
    /// signature: ss.toArray()
    ///     summary: returns the elements in the selected set as an array.
    ///     snippet: var aray = $('a');      // return all anchors as an array
    ///     returns: the new array.
{
    return [this.elem];
};

vp.sw.wrap = function (index)
{
    var we = null;

    if (index == 0)
    {
        we = vp.wrapElements(this.elem);
    }

    return we;
};

vp.sw.kids = function ()
{
    var kids = vp.children(this.elem);
    var wrappedKids = vp.wrapElements(kids);

    return wrappedKids;
};

vp.sw.each = function (callback)
    /// signature: ss.each(func)
    ///     summary: calls the specified function for each element in the set.  The function is pass "index" and "element" parameters.
    ///     paramType(callback): the function to be called for each element.
    ///     snippet: $("a").each(function(index, elem) { elem.clickCount = 0; });     // set a custom property on each anchor
    ///     returns: null.
{
    //---- pass our element to callback as wrapped ("this") ----
    callback.call(this, 0, this);
    return this;
};



vp.sw.elementSizes = function (callBack)
{
    return vp.elementSizes(this.elem, callBack);
};

vp.sw.focus = function ()
{
    vp.focus(this.elem);
    return this;
};

vp.sw.background = function (value)
{
    if (arguments.length == 0)
    {
        return vp.background(this.elem);
    }

    vp.background(this.elem, value);
    return this;
};

vp.sw.dataId = function (value)
{
    if (arguments.length == 0)
    {
        return vp.dataId(this.elem);
    }

    vp.dataId(this.elem, value);
    return this;
};

vp.sw.shapeId = function (value)
{
    if (arguments.length == 0)
    {
        return vp.shapeId(this.elem);
    }

    vp.shapeId(this.elem, value);
    return this;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// ssFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - selected set functions.
///-----------------------------------------------------------------------------------------------------------------


//---- ADD the content to the selected set of containers ----
vp.fn.add = function (content)
{
    var ss = null;
    var firstContainer = true;

    this.each(function (index, container) 
    {
        var newElems = vp.add(container, content);

        if (firstContainer)
        {
            ss = vp.wrapElements(newElems);
            firstContainer = false;
        }
    });

    return ss;
};

/// remove all children (childNodes) of each item in the selected set.
vp.fn.clear = function ()
{
    return this.each(function (index, element)
    {
        vp.clear(element);
    });
};

vp.fn.show = function (showIt)
{
    return this.each(function (index, element)
    {
        vp.show(this, showIt);
    });
};

vp.fn.showToggle = function ()
{
    return this.each(function (index, element)
    {
        vp.showToggle(this);
    });
};

vp.fn.hide = function ()
{
    return this.each(function (index, element)
    {
        vp.hide(this);
    });
};

vp.fn.collapse = function ()
{
    return this.each(function (index, element)
    {
        vp.collapse(this);
    });
};

vp.fn.expand = function ()
{
    return this.each(function (index, element)
    {
        vp.expand(this);
    });
};


/// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
vp.fn.docOffset = function (elem)
{
    var value = null;

    if (this.length > 0)
    {
        value = vp.docOffset(elem);
    }

    return value;
};

//
//---- warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. ----
//
//---- "bindingName" is a unique, persistent name for this binding of data to a set of visuals ----
//---- "data" is a set of records to be logically bound to a set of visual elements ----
//---- "pkFunc" is a function to return the primary key of a record ----
//----     if "pkFunc" is omitted or null, it will default to the index number of each record ----
//---- "isNewData" - if true, will treat "data" as a new data set with no key matches to previous
//
//---- warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. ----
//
vp.fn.dataBind = function (bindingName, data, pkFunc, isNewData)
{
    var binder = null;
    var ss = this;

    this.each(function (index, element)
    {
        binder = vp.dataBind(this, ss, bindingName, data, pkFunc, isNewData);
    });

    return binder;
};

/// get/set "left" value (relative to closest parent) of items.
vp.fn.left = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.left(this[0]);
        }

        return value;
    }
    else
    {
        //---- SET value ----
        return this.each(function (index, element)
        {
            vp.left(this, value);
        });
    }
};

/// get/set "top" value (relative to closest parent) of items.
vp.fn.top = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.top(this[0]);
        }

        return value;
    }
    else
    {
        //---- SET value ----
        return this.each(function (index, element)
        {
            vp.top(this, value);
        });
    }
};

/// return actual width of first element.
vp.fn.width = function (value)
{
    if (arguments.length == 0)
    {
        var value = null;
        if (this.length > 0)
        {
            value = vp.width(this[0]);
        }

        return value;
    }
    else
    {
        //---- SET value ----
        var origValue = value;

        return this.each(function (index, element)
        {
            if (vp.isFunction(origValue))
            {
                value = origValue(index, element);
            }

            vp.width(this, value);
        });
    }
};

/// get/set css style property for each item in the set.
vp.fn.css = function (prop, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.css(this[0], prop);
        }

        return value;
    }

    //---- SET value ----
    var origValue = value;

    return this.each(function (index, element)
    {
        if (vp.isFunction(origValue))
        {
            value = origValue(index, element);
        }

        vp.css(this, prop, value);
    });
}

/// get or set height of elements in set.
vp.fn.height = function (value)
{
    if (arguments.length == 0)
    {
        var value = null;
        if (this.length > 0)
        {
            value = vp.height(this[0]);
        }

        return value;
    }

    //---- SET value ----
    var origValue = value;

    return this.each(function (index, element)
    {
        if (vp.isFunction(origValue))
        {
            value = origValue(index, element);
        }

        vp.height(this, value);
    });
};

/// get total height of first element
vp.fn.totalHeight = function ()
{
    var value = null;
    if (this.length > 0)
    {
        value = vp.totalHeight(this[0]);
    }

    return value;
};

/// get total width of first element
vp.fn.totalWidth = function ()
{
    var value = null;
    if (this.length > 0)
    {
        value = vp.totalWidth(this[0]);
    }

    return value;
};

vp.fn.toolTipEnabled = function (value)
{
    if (arguments.length == 0)
    {
        value = (this.length > 0) ? this[0].toolTipEnabled : false;
        return value;
    }

    return this.each(function (index, element)
    {
        vp.toolTipEnabled(element, value);
    });
};

vp.fn.animate = function (duration, ease, container)
{
    return this.each(function (index, element)
    {
        vp.animate(this, duration, ease, container);
    });
};


vp.fn.onAnimationComplete = function (completedFunc)
{
    this.animation.completedFunc = completedFunc;
    return this;
};

vp.fn.remove = function ()
{
    return this.each(function (index, element)
    {
        if (this.animation == null)
        {
            vp.remove(this);
        }
        else
        {
            this.animation.deleteElementsOnCompleted(this);
        }
    });
};


vp.fn.attr = function (name, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.attr(this[0], name);
        }

        return value;
    }

    //---- SET value ----
    var origValue = value;

    return this.each(function (index, element)
    {
        vp.attr(this, name, value);
    });
};

vp.fn.prop = function (name, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.prop(this[0], name);
        }

        return value;
    }

    //---- SET value ----
    var origValue = value;

    return this.each(function (index, element)
    {
        vp.prop(this, name, value);
    });
};

vp.fn.attrXlink = function (name, origValue)
{
    return this.attrNS("http://www.w3.org/1999/xlink", name, origValue);
};

vp.fn.attrNS = function (ns, name, value)
{
    return this.each(function (index, element)
    {
        vp.attrNS(element, ns, name, value);
    });
};

vp.fn.bounds = function (x, y, width, height)
{
    return this.each(function (index, element)
    {
        vp.bounds(element, x, y, width, height);
    });
};

vp.fn.radius = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        value = (this.length > 0) ? vp.radius(this[0]) : 0;
        return value;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.radius(this, value);
    });
};

vp.fn.opacity = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.opacity(this[0]);
        }

        return value;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.opacity(this, value);
    });
};

/// get/set the "checked" property on the items.
vp.fn.checked = function (value)
{
    //---- GET value ----
    if (arguments.length == 0)
    {
        var value = null;

        if (this.length > 0)
        {
            value = vp.checked(this[0]);
        }

        return value;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        //---- animation not supported for "checked" ----
        vp.checked(this, value);
    });
};

vp.fn.position = function (x, y)
{
    return this.each(function (index, element)
    {
        vp.position(element, x, y);
    });
};

vp.fn.absPosition = function (left, top)
{
    return this.each(function (index, element)
    {
        vp.absPosition(element, left, top);
    });
};

vp.fn.removeProp = function (name)
    /// signature: ss.removeProp(name)
    ///     summary: removes the property/value pair stored under "name" from the elements in the set.
    ///     paramType(name): string (the name of the property to be removed).
    ///     snippet: $("a").removeProp("hitCount");        // remove the "hitCount" property from the anchors in the set
    ///     returns: null.
{
    return this.each(function (index, element)
    {
        //---- animation not supported for this operation ----
        vp.removeProp(this, name);
    });
};

vp.fn.center = function (cx, cy)
{
    return this.each(function (index, element)
    {
        vp.center(element, cx, cy);
    });
};

vp.fn.id = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.id(this[0]);
        }
        return value;
    }
    else
    {
        //---- SET value ----
        return this.each(function (index, element)
        {
            vp.id(this, value);
        });
    }
};

vp.fn.addClass = function (name)
{
    return this.each(function (index, element)
    {
        vp.addClass(this, name);
    });
};

vp.fn.removeClass = function (name)
{
    return this.each(function (index, element)
    {
        vp.removeClass(this, name);
    });
};

vp.fn.hasClass = function (name)
{
    var hasIt = false;

    if (this.length > 0)
    {
        hasIt = vp.hasClass(this[0], name);
    }

    return hasIt;
};

vp.fn.setClass = function (name)
{
    return this.each(function (index, element)
    {
        vp.setClass(this, name);
    });
};

vp.fn.toggleClass = function (name)
{
    return this.each(function (index, element)
    {
        vp.toggleClass(this, name);
    });
};

vp.fn.attach = function (eventName, funcToCall)
{
    return this.each(function (index, element)
    {
        vp.attach(this, eventName, funcToCall);
    });
};

vp.fn.detach = function (eventName, funcToCall)
{
    return this.each(function (index, element)
    {
        vp.detach(this, eventName, funcToCall);
    });
};

vp.fn.transform = function (strTransform)
{
    return this.each(function (index, element)
    {
        vp.transform(this, strTransform);
    });
};

vp.fn.translate = function (x, y)
{
    return this.each(function (index, element)
    {
        vp.translate(this, x, y);
    });
};

vp.fn.transformOrigin = function (value)
{
    if (arguments.length == 0)
    {
        value = (this.length > 0) ? vp.transformOrigin(this[0]) : undefined;
        return value;
    }

    return this.each(function (index, element)
    {
        vp.transformOrigin(value);
    });
};

vp.fn.addStop = function (offset, color, opacity)
{
    return this.each(function (index, element)
    {
        vp.addStop(this, offset, color, opacity)
    });
};

vp.fn.from = function (x1, y1)
{
    return this.each(function (index, element)
    {
        vp.from(element, x1, y1);
    });
};

vp.fn.to = function (x2, y2)
{
    return this.each(function (index, element)
    {
        vp.to(element, x2, y2);
    });
};

vp.fn.font = function (family, size, weight, style)
{
    return this.each(function (index, element)
    {
        vp.font(element, family, size, weight, style);
    });
};

vp.fn.dataPair = function (dataItem, dataIndex)
{
    return this.each(function (index, element)
    {
        vp.dataPair(this, dataItem, dataIndex);
    });
};

vp.fn.dataItem = function (dataItem)
{
    if (dataItem != null)
    {
        return this.each(function (index, element)
        {
            this.dataItem = dataItem;
        });
    }
    else
    {
        return this[0].dataItem;
    }
};

vp.fn.dataIndex = function (dataIndex)
{
    if (dataIndex != null)
    {
        return this.each(function (index, element)
        {
            this.dataIndex = dataIndex;
        });
    }
    else
    {
        return (this.length == 0) ? null : this[0].dataIndex;
    }
};

vp.fn.customAttr = function (name, value)
{
    if (arguments.length == 1)
    {
        value = (this.length > 0) ? this[0][name] : null;
    }

    return this.each(function (index, element)
    {
        vp.customAttr(element, name, value);
    });
};

vp.fn.text = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        value = null;

        if (this.length > 0)
        {
            value = vp.text(this[0]);
        }

        return value;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.text(this, value);
    });
};

vp.fn.value = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        if (this.length > 0)
        {
            value = vp.value(this[0]);
        }

        return value;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.value(this, value);
    });
};

vp.fn.html = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        return (this.length == 0) ? null : this[0].innerHTML;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.html(this, value);
    });
};

vp.fn.colors = function (fill, stroke, strokeWidth)
{
    return this.each(function (index, element)
    {
        vp.colors(this, fill, stroke, strokeWidth);
    });
};

vp.fn.href = function (origValue)
{
    return this.attrNS("http://www.w3.org/1999/xlink", "href", origValue);
};

vp.fn.safeHref = function (value, fallback)
{
    if ((!value) || (value.length == 0))
    {
        value = fallback;
    }

    return this.each(function (index, element)
    {
        vp.href(this, value);
    });
};

vp.fn.kids = function ()
{
    var kids = [];

    if (this.length > 0)
    {
        kids = vp.children(this[0]);
    }

    var wrappedKids = vp.wrapElements(kids);
    return wrappedKids;
};

vp.fn.elementSizes = function (callBack)
{
    var value = undefined;

    if (this.length > 0)
    {
        value = vp.elementSizes(this[0]);
    }

    return value;
};

vp.fn.background = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        return (this.length == 0) ? null : this[0].background;
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.background(this, value);
    });
};

vp.fn.focus = function ()
{
    if (this.length > 0)
    {
        vp.focus(this[0]);
    }

    return this;
};

vp.fn.dataId = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        return (this.length == 0) ? null : vp.dataItem(this[0]);
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.dataItem(this, value);
    });
};

vp.fn.shapeId = function (value)
{
    if (arguments.length == 0)
    {
        //---- GET value ----
        return (this.length == 0) ? null : vp.shapeId(this[0]);
    }

    //---- SET value ----
    return this.each(function (index, element)
    {
        vp.shapeId(this, value);
    });
};﻿///-----------------------------------------------------------------------------------------------------------------
/// ssMgmt.js.  Copyright (c) 2012 Microsoft Corporation.
///             part of the vuePlot library - selected set management functions.
///-----------------------------------------------------------------------------------------------------------------
/// get element at specified index.  fails silently if index is not a number or out of range.
vp.fn.get = function (index)
    /// signature: ss.get(index)
    ///     summary: returns the element at the specified index in the selected set.
    ///     paramType(index): an integer number
    ///     snippet: var first = $("a").get(0);
    ///     returns: the element at the specified index if the index is valid; null otherwise
{
    var element = null;

    if (vp.isNumber(index))
    {
        if ((index >= 0) && (index < this.length))
        {
            element = this[index];
        }
    }

    return element;
};

vp.fn.element = function ()
{
    return this.get(0);
};

/// wrap the element at specified index.  fails silently if index is not a number or out of range.
vp.fn.wrap = function (index)
    /// signature: ss.wrap(index)
    ///     summary: wraps the element at the specified index in a new selected set.
    ///     paramType(index): an integer number
    ///     snippet: var ssFirst = $("a").wrap(0);      // wrap the first anchor in a selected set
    ///     returns: the new selected set.
{
    var element = this.get(index);
    var ss = null;

    if (element)
    {
        ss = vp.wrapElements(element);
    }

    return ss;
};

vp.fn.toArray = function ()
    /// signature: ss.toArray()
    ///     summary: returns the elements in the selected set as an array.
    ///     snippet: var aray = $('a');      // return all anchors as an array
    ///     returns: the new array.
{
    return Array.prototype.slice.call(this, 0);
};

//---- each function signature: callback(index, element) ----
vp.fn.each = function (callback)
    /// signature: ss.each(func)
    ///     summary: calls the specified function for each element in the set.  The function is pass "index" and "element" parameters.
    ///     paramType(callback): the function to be called for each element.
    ///     snippet: $("a").each(function(index, elem) { elem.clickCount = 0; });     // set a custom property on each anchor
    ///     returns: null.
{
    for (var i = 0; i < this.length; i++)
    {
        var elem = this[i];

        //---- callback with this=elem and 2 params ----
        callback.call(elem, i, elem);
    }

    return this;
};

//---- eachWrapped function signature: callback(index, element) ----
vp.fn.eachWrapped = function (callback)
    /// signature: ss.eachWrapped(func)
    ///     summary: calls the specified function for each element in the set.  The function is pass "index" and "element" parameters.
    ///          "element" is passed as a wrapped element.
    ///     paramType(callback): the function to be called for each element.
    ///     snippet: $("a").each(function(index, elem) { elem.clickCount = 0; });     // set a custom property on each anchor
    ///     returns: null.
{
    var sw = vp.visuals.createSingleWrapper(null);

    for (var i = 0; i < this.length; i++)
    {
        var elem = this[i];
        sw.elem = elem;

        //---- callback with this=wrapper(elem) and 2 params ----
        callback.call(sw, i, sw);
    }

    return this;
};

/// adds the specified element/array to the selected set.
vp.fn.merge = function (elemOrArray)
{
    var newElements = null;

    if (elemOrArray instanceof vp.selectedSet)
    {
        elemOrArray = elemOrArray.toArray();
    }
    else if (elemOrArray instanceof vp.canvasSelectedSet)
    {
        elemOrArray = elemOrArray.toArray();
    }
    else if (elemOrArray instanceof vp.visuals.singleWrapperClass)
    {
        elemOrArray = elemOrArray.elem;
    }

    if (vp.isArray(elemOrArray))
    {
        newElements = this.toArray().concat(elemOrArray);
    }
    else
    {
        newElements = this.toArray();
        newElements.push(elemOrArray);
    }

    var newSet = new vp.selectedSet(newElements);

    return newSet;  
};

//---- remove the selected set from their parent ----
vp.fn.removeCore = function (content)
{
    this.each(function (index, element)
    {
        vp.remove(element);
    });
};

/// remove the element from its parent.
vp.remove = function (element)
{
    if (vp.isCanvasChild(element))
    {
        var parentElement = element.parentElement;
        if (parentElement != null)
        {
            parentElement.removeChild(element);
        }
    }
    else
    {
        var parentNode = element.parentNode;
        if (parentNode != null)
        {
            parentNode.removeChild(element);
        }
    }
};

vp.wrapElements = function (elemOrArray)
{
    var ss = null;

    if (vp.isArray(elemOrArray))
    {
        if (elemOrArray.length == 1)
        {
            ss = vp.visuals.createSingleWrapper(elemOrArray[0]);
        }
        else    // wrap empty or multi-element set
        {
            ss = new vp.selectedSet(elemOrArray);
        }
    }
    else if (elemOrArray)
    {
        ss = vp.visuals.createSingleWrapper(elemOrArray);
    }

    return ss;
};

/// upwrap(elem): return unwrapped version of elem (can be wrapper or unwrapped element)
vp.unwrap = function (elem)
{
    if (elem.length)
    {
        elem = elem[0];
    }

    return elem;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// animation.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library 
///-----------------------------------------------------------------------------------------------------------------
/// class: animation 
/// creates a set of animations for the specified "elem". 
///
/// "elem" is an UNWRAPPED HTML/SVG/Canvas elem.
/// "duration" is the time in milliseconds that the animation lasts.
/// "easeObj" is an optional object to control start and end easing.
/// "container" is an  optional animation container (which controls multiple animations).
///-----------------------------------------------------------------------------------------------------------------
vp.animation = function (elem, duration, easeObj, container)
{
    //---- private state ----
    var children = [];                  // animation objects for each obj/prop being animated
    var elemsToDelete = vp.select();    // elems to delete at end of animation
    var completedFunc = null;
    var removed = [];                   // children that have been moved to shader list
    var transformAnimations = {};       // we use one for all transform animations for a given elem
    var origTransform = undefined;
    var timer = null;
    var timeStarted = undefined;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.animiation";

    /// move the specified anim off the active children list to the "removed" list.
    closure.remove = function (anim)
    {
        children.remove(anim);
        removed.push(anim);
    };

    /// internal.
    var getSlideLoc = function (slideLoc)
    {
        var parent = vp.parent(elem);
        var pw = vp.width(parent);
        var ph = vp.height(parent);

        //---- compute OFFSET from current position ----
        var x = 0;
        var y = 0;

        if ((slideLoc == vp.slideLoc.left) || (slideLoc == "left"))
        {
            x = -pw;        //-2000;
        }
        else if ((slideLoc == vp.slideLoc.right) || (slideLoc == "right"))
        {
            x = pw;
        }
        else if ((slideLoc == vp.slideLoc.top) || (slideLoc == "top"))
        {
            y = -ph;
        }
        else if ((slideLoc == vp.slideLoc.bottom) || (slideLoc == "bottom"))
        {
            y = ph;
        }

        return { x: x, y: y };
    }

    // CHW: new function
    var getTranslateTo = function (trans)
    {
        var parts = parseTransform(trans);
        var locTo = null;

        for (var i = 0; i < parts.length; i++)
        {
            if (parts[i].name == "translate")
            {
                locTo = { x: parts[i].p0, y: parts[i].p1 };
                break;
            }
        }

        return locTo;
    }

    /// public: applyEffect(elem, effect, isEnter)
    closure.applyEffect = function (elem, effect, isEnter)
    {
        if (isEnter)
        {
            closure.applyEnterEffect(elem, effect);
        }
        else
        {
            closure.applyExitEffect(elem, effect);
        }
    }

    /// public: applyEnterEffect(elem, effect)
    closure.applyEnterEffect = function (elem, effect)
    {
        if (effect.fadeType)
        {
            if ((effect.fadeType == vp.fadeType.fade) || (effect.fadeType == "fade"))
            {
                // CHW: end up at current opacity; 1 if not set yet
                var curOpacity = vp.attr(elem, "opacity");

                if (curOpacity == null)
                    curOpacity = 1;


                vp.attr(elem, "opacity", 0);
                closure.animateAttr(elem, "opacity", 0, curOpacity);
            }
        }

        if (effect.slideLoc)
        {
            var locFrom = getSlideLoc(effect.slideLoc);

            // CHW: use current location, even if transformed, as destination of enter effect
            var locTo = getTranslateTo(vp.transform(elem));

            if (locTo == null)
            {
                locTo = getTranslateTo(origTransform);
                if (locTo == null)
                {
                    //---- if elem has no transform, just use (0,0) as the "to" value ----
                    //locTo = { x: vp.attr(elem, "x"), y: vp.attr(elem, "y") };
                    locTo = { x: 0, y: 0 };
                }
            }

            if (locFrom.x)
            {
                closure.animateAttr(elem, "translate.x", locFrom.x, locTo.x);
            }

            if (locFrom.y)
            {
                closure.animateAttr(elem, "translate.y", locFrom.y, locTo.y);
            }
        }

        if (effect.growOrigin)
        {
            if ((effect.growOrigin != vp.growOrigin.none) && (effect.growOrigin != "none"))
            {
                var w = vp.width(elem);
                var h = vp.height(elem);

                var x = vp.left(elem);
                var y = vp.top(elem);

                if ((effect.growOrigin == vp.growOrigin.left) || (effect.growOrigin == "left"))
                {
                    closure.animateAttr(elem, "scale.x", 0, 1, x, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.top) || (effect.growOrigin == "top"))
                {
                    closure.animateAttr(elem, "scale.y", 0, 1, x, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.right) || (effect.growOrigin == "right"))
                {
                    closure.animateAttr(elem, "scale.x", 0, 1, x + w, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.bottom) || (effect.growOrigin == "bottom"))
                {
                    closure.animateAttr(elem, "scale.y", 0, 1, x, y + h);
                }
                else if ((effect.growOrigin == vp.growOrigin.center) || (effect.growOrigin == "center"))
                {
                    closure.animateAttr(elem, "scale.x", 0, 1, x + w / 2, y + h / 2);
                    closure.animateAttr(elem, "scale.y", 0, 1, x + w / 2, y + h / 2);
                }
            }
        }

        if (effect.rotateAngle)
        {
            var w = vp.width(elem);
            var h = vp.height(elem);

            var x = vp.left(elem);
            var y = vp.top(elem);

            closure.animateAttr(elem, "rotate", effect.rotateAngle, 0, x + w / 2, y + h / 2);
        }

        //---- for enter animations, we don't want to restore the origTransform at the end ----
        origTransform = undefined;

        //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
        closure.animateFrameCore(0);
    };

    /// public: applyExitEffect(elem, effect)
    closure.applyExitEffect = function (elem, effect)
    {
        if (effect.fadeType)
        {
            if ((effect.fadeType == vp.fadeType.fade) || (effect.fadeType == "fade"))
            {
                // CHW: only set current opacity if not set
                var curOpacity = vp.attr(elem, "opacity");

                if (curOpacity == null)
                {
                    vp.attr(elem, "opacity", 1);
                }

                closure.animateAttr(elem, "opacity", 0);
            }
        }

        if (effect.slideLoc)
        {
            var loc = getSlideLoc(effect.slideLoc);

            // CHW: TODO use current location, even if transformed, as source of exit effect

            if (loc.x)
            {
                closure.animateAttr(elem, "translate.x", 0, loc.x);
            }

            if (loc.y)
            {
                closure.animateAttr(elem, "translate.y", 0, loc.y);
            }
        }

        if (effect.growOrigin)
        {
            if ((effect.growOrigin != vp.growOrigin.none) && (effect.growOrigin != "none"))
            {
                var w = vp.width(elem);
                var h = vp.height(elem);

                var x = vp.left(elem);
                var y = vp.top(elem);

                if ((effect.growOrigin == vp.growOrigin.left) || (effect.growOrigin == "left"))
                {
                    closure.animateAttr(elem, "scale.x", 1, 0, x, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.top) || (effect.growOrigin == "top"))
                {
                    closure.animateAttr(elem, "scale.y", 1, 0, x, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.right) || (effect.growOrigin == "right"))
                {
                    closure.animateAttr(elem, "scale.x", 1, 0, x + w, y);
                }
                else if ((effect.growOrigin == vp.growOrigin.bottom) || (effect.growOrigin == "bottom"))
                {
                    closure.animateAttr(elem, "scale.y", 1, 0, x, y + h);
                }
                else if ((effect.growOrigin == vp.growOrigin.center) || (effect.growOrigin == "center"))
                {
                    closure.animateAttr(elem, "scale.x", 1, 0, x + w / 2, y + h / 2);
                    closure.animateAttr(elem, "scale.y", 1, 0, x + w / 2, y + h / 2);
                }
            }
        }

        if (effect.rotateAngle)
        {
            var w = vp.width(elem);
            var h = vp.height(elem);

            var x = vp.left(elem);
            var y = vp.top(elem);

            closure.animateAttr(elem, "rotate", 0, effect.rotateAngle, x + w / 2, y + h / 2);
        }

        //---- for exit animations, we don't want to restore the origTransform at the end ----
        origTransform = undefined;

        //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
        closure.animateFrameCore(0);
    };

    /// private.
    var getTransformObject = function (elem)
    {
        var ta = transformAnimations[elem];
        if (ta == null)
        {
            origTransform = vp.transform(elem);

            ta = new vp.transformAnimation(closure, elem);
            transformAnimations[elem] = ta;

            addAnimation(ta);
        }

        return ta;
    }

    /// private.
    var parseTransformParams = function (scanner, transObj, paramCount)
    {
        var paramNum = 0;
        var tt = scanner.tokenType();

        while (tt == vp.tokenType.number)
        {
            var pname = "p" + paramNum++;
            transObj[pname] = scanner.token();

            tt = scanner.scan();

            //---- look for optional comma ----
            if (scanner.token() == ",")
            {
                tt = scanner.scan();     // skip over comma
            }
        }

        return (paramNum == paramCount);
    }

    //---- parse a transform string into an array of transform part objects (translate, scale, rotate, skew) ----
    /// private.
    var parseTransform = function (str)
    {
        var parts = [];

        if (str != null)
        {
            var scanner = new vp.scanner(str);
            var tt = scanner.scan();
            var paramCounts = { scale: 2, translate: 2, rotate: 3, skew: 2 };

            while (tt != vp.tokenType.eof)
            {
                if (tt != vp.tokenType.id)
                {
                    //---- looks like an error; just stop parsing ----
                    parts = [];
                    break;
                }

                var transObj = { name: scanner.token() };
                parts.push(transObj);

                tt = scanner.scan();
                if (scanner.token() == "(")
                {
                    tt = scanner.scan();
                    var counts = paramCounts[transObj.name];

                    if (!parseTransformParams(scanner, transObj, counts))
                    {
                        // CHW: handle some common cases that used to look like errors
                        if (transObj.name == "scale" && transObj["p0"])
                        {
                            // scale with one parameter; second parameter should equal first
                            transObj["p1"] = transObj["p0"];
                        }
                        else if (transObj.name == "translate" && transObj["p0"])
                        {
                            // translate with one parameter; second parameter should be 0
                            transObj["p1"] = "0";
                        }
                        else
                        {
                            //---- looks like an error; just stop parsing ----
                            parts = [];
                            break;
                        }
                    }

                    if (scanner.token() != ")")
                    {
                        //---- looks like an error; just stop parsing ----
                        parts = [];
                        break;
                    }

                    tt = scanner.scan();     // get next function name
                }
            }
        }

        return parts;
    };

    /// private.
    var getFromValue = function (elem, isStyle, propOwner, name)
    {
        var from = 0;       // default, if we cannot read it from anywhere...

        // the BELOW code should be changed - it adds a direct property that later down overrides the attribute
        // for an SVG elem like "rect".

        ////---- initialize property with default value, if needed ----
        //if ((propOwner[name] === undefined) || (propOwner[name] === ""))
        //{
        //    propOwner[name] = 0;
        //}


        if (isStyle)
        {
            from = vp.css(elem, name);
        }
        else if (elem.getAttribute)
        {
            var av = elem.getAttribute(name);
            if (av)
            {
                if (av.baseVal != undefined)
                {
                    from = vp.getBaseVal(elem, name, av);
                }
                else if (av.value != undefined)
                {
                    from = parseFloat(av.value);
                }
                else
                {
                    from = parseFloat(av);
                }
            }
            else
            {
                //---- try style again after all ----
                from = vp.attr(elem, name);
            }
        }
        else if (name in propOwner)
        {
            if (elem.rootContainer)
            {
                from = propOwner[name];
            }
            else
            {
                from = (propOwner[name].baseVal) ? vp.getBaseVal(elem, name, propOwner[name]) : 0;
            }
        }


        return from;
    };

    /// private animateColorValue()
    var animateColorValue = function (elem, name, isStyle, fromValue, value)
    {
        var from = fromValue;
        if (vp.isUndefined(from))
        {
            from = (isStyle) ? elem.style[name] : (elem.getAttribute) ? elem.getAttribute(name) : elem[name];
        }

        from = vp.colorHelper.getColorFromString(from);
        value = vp.colorHelper.getColorFromString(value);

        var areDiff = false;

        if (from == null)
        {
            areDiff = (value != null);
        }
        else if (value == null)
        {
            areDiff = true;
        }
        else if ((from[0] != value[0]) || (from[1] != value[1]) || (from[2] != value[2]))
        {
            areDiff = true;
        }

        if (areDiff)
        {
            var animate = vp.colorAnimation(closure, elem, name, from, value);
            addAnimation(animate);
        }
    };

    /// private animateColorValue()
    var animateTransformValue = function (elem, name, isStyle, fromValue, value)
    {
        var ta = getTransformObject(elem);
        var from = fromValue;

        if (vp.isUndefined(from))
        {
            if (isStyle)
            {
                from = vp.css(elem, "transform");
            }
            else
            {
                from = vp.attr(elem, "transform");
            }
        }

        //---- parse "transform" strings into their function parts ----
        var fromParts = parseTransform(from);
        var toParts = parseTransform(value);

        for (var i = 0; i < toParts.length; i++)
        {
            var toPart = toParts[i];
            var fromPart = (i < fromParts.length) ? fromParts[i] : null;

            if ((fromPart) && (fromPart.name != toPart.name))
            {
                //---- this is an error for our current level of support ----
                break;
            }

            if (toPart.name == "translate")
            {
                var fromX = (fromPart) ? fromPart.p0 : 0;
                var toX = toPart.p0;

                var fromY = (fromPart) ? fromPart.p1 : 0;
                var toY = toPart.p1;

                ta.makeTransform("translate.x", fromX, toX);
                ta.makeTransform("translate.y", fromY, toY);
            }
            else if (toPart.name == "scale")
            {
                var fromX = (fromPart) ? fromPart.p0 : 1;
                var toX = toPart.p0;

                var fromY = (fromPart) ? fromPart.p1 : 1;
                var toY = toPart.p1;

                ta.makeTransform("scale.x", fromX, toX);
                ta.makeTransform("scale.y", fromY, toY);
            }
            else if (toPart.name == "rotate")
            {
                var from = (fromPart) ? fromPart.p0 : 0;
                var to = toPart.p0;

                ta.makeTransform("rotate", from, to, toPart.p1, toPart.p2);
            }
        }

    };

    /// public: animateAttr() - add the specified attribute/value to children (attributes) being animated.
    closure.animateAttr = function (elem, name, value, value2, cx, cy, isStyle)
    {
        var animate = null;
        var fromValue = undefined;
        var propOwner = (isStyle) ? elem.style : elem;

        if (value2 !== undefined)
        {
            fromValue = value;
            value = value2;
        }

        if ((name == "color") || (name == "fill") || (name == "stroke"))
        {
            //---- COLOR value ----
            animateColorValue(elem, name, isStyle, fromValue, value);
        }
        else if (name == "transform")
        {
            //---- TRANSFORM value ----
            animateTransformValue(elem, name, isStyle, fromValue, value);
        }
        else if ((name == "scale") || (name == "translate") || (name == "rotate"))
        {
            //---- TRANSFORM value ----
            var ta = getTransformObject(elem);

            ta.makeTransform(name, fromValue, value, cx, cy);
        }
        else if ((name.startsWith("scale.")) || (name.startsWith("translate.")) || (name.startsWith("rotate.")))
        {
            //---- TRANSFORM value ----
            var ta = getTransformObject(elem);

            ta.makeTransform(name, fromValue, value, cx, cy);
        }
        else
        {
            //---- NUMERIC value ----
            var from = fromValue;
            if (vp.isUndefined(from))
            {
                from = getFromValue(elem, isStyle, propOwner, name);

                if (vp.isUndefined(from))
                {
                    from = 0;
                }
            }

            if (!vp.floatEq(from, value))
            {
                var animate = vp.numberAnimation(closure, elem, name, from, value, isStyle);
                addAnimation(animate);
            }
        }

        //---- if this is a child of a webGL canvas, add to new animatons list ----
        if (animate != null)
        {
            if ((elem.rootContainer) && (elem.rootContainer.glHelper))
            {
                if ((window.vp) && (window.vp.shaderAnimationMgr))
                {
                    window.vp.shaderAnimationMgr.addNewAnimation(animate);
                }
            }
        }

    }

    /// public.
    closure.deleteElementsOnCompleted = function (elems)
    {
        elemsToDelete = elemsToDelete.merge(elems);
    }

    /// private.
    var addAnimation = function (child)
    {
        children.push(child);
    }

    /// called each frame to animate all contains attribute animations.  must return true when
    /// we have reached percent=1 (100%).
    closure.animateFrame = function ()
    {
        //---- on first frame of first animation, see if a common setset of the GL animations ----
        //---- (those with the same duration) can be moved onto the shader animation list ---
        if ((window.vp) && (window.vp.shaderAnimationMgr))
        {
            window.vp.shaderAnimationMgr.processNewAnimations();
        }

        var elapsed = new Date() - timeStarted;
        var percent = elapsed / duration;

        if (percent > 1)
        {
            percent = 1;
        }
        else if (percent < 0)
        {
            percent = 0;
        }
        else
        {
            //---- apply easing fuction ----
            if (easeObj)
            {
                percent = easeObj.ease(percent);
            }
        }

        closure.animateFrameCore(percent);

        return (percent == 1);
    };

    closure.animateFrameCore = function (percent)
    {
        for (var i = 0; i < children.length; i++)
        {
            children[i].animateFrame(percent);
        }

        if (percent == 1)
        {
            onAnimationStopped();
        }
    };

    /// public.
    closure.stop = function ()
    {
        var stopped = false;

        if (true)       // timer)
        {
            //---- move all elems into their final position instantly ----
            var percent = 1;
            //vp.debug("animation.stop: forcing percent=1 positions");

            for (var i = 0; i < children.length; i++)
            {
                children[i].animateFrame(percent);
            }

            onAnimationStopped();
            stopped = true;
        }

        return stopped;
    };

    /// private.
    var onAnimationStopped = function ()
    {
        //---- stop further animations ----
        if (timer)
        {
            clearInterval(timer);

            vp.debug("timer CLEARED: " + timer);
            timer = null;
        }

        if (vp.isDefined(origTransform))
        {
            // CHW don't reset any more
            ////---- reset to pre-animation value ----
            //vp.transform(elem, origTransform);    
        }

        if (elemsToDelete.length > 0)
        {
            elemsToDelete.removeCore();

            elemsToDelete = vp.select();
        }

        if (completedFunc)
        {
            completedFunc();
        }

        //---- remove this animation from the list of active animations on the container ----
        if (vp.isCanvasChild(elem))
        {
            elem.rootContainer.removeAnimation(elem.animation);
        }

        //---- remove the animation property so that subsequent property changes are normal ----
        delete elem.animation;
    };

    //---- init code ----
    if (vp.isUndefined(duration))
    {
        duration = 1000;
    }

    if (easeObj === true)
    {
        easeObj = new vp.powEase(2);
    }

    if (container)
    {
        container.add(closure);
        timeStarted = container.timeStarted();
    }
    else
    {
        timer = setInterval(closure.animateFrame, 1000 / 60);
        vp.debug("timer created: " + timer);

        timeStarted = new Date();
    }

    //---- add this animation to the list of active animations on the container ----
    if (vp.isCanvasChild(elem))
    {
        elem.rootContainer.addAnimation(closure);
    }

    return closure;
};

///  - adapted from http://paulirish.com/2011/requestanimationframe-for-smart-animating/
vp.requestAnimationFrame = function (callback)
{
    var func =
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame;

    if (!func)
    {
        func = function (callback)
        {
            return setInterval(callback, 1000 / 60);
        };
    }

    return func(callback);
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// animationContainer.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library 
///   - controls multiple animation objects
///-----------------------------------------------------------------------------------------------------------------
/// class: animationContainer
/// this is used to contain and control a set of vp.animation classes.  to keep animations
/// crisp and in sync, a single timer is used in the container class. when stopped
/// or all child animations are completed, the "completedFunc" is called.
vp.animationContainer = function ()
{
    //---- private state ----
    var children = [];
    var completedFunc = null;
    var timer = null;
    var timeStarted = null;
    var easeObj = null;
    var ctr = "vp.animationContainer";
    var isRunning = false;

    /// closure object.
    var closure = function ()
    {
    };

    closure.timeStarted = function()
    {
        return timeStarted;
    };

    /// public: add(anim)
    closure.add = function (anim)
    {
        if (children.length == 0)
        {
            //---- start the container when first child is added ---
            timer = setInterval(closure.animateFrame, 1000 / 60);
            timeStarted = new Date();
            isRunning = true;
        }

        children.push(anim);
    };

    /// public: stop()
    /// stop the running animation.
    closure.stop = function ()
    {
        if (timer)
        {
            for (var i = 0; i < children.length; i++)
            {
                var child = children[i];
                child.stop();
            }

            onStoppedOrCompleted();
        }
    };

    /// public: onCompleted(completedFunc)
    /// set the callback func to be called when animation is stopped or completed.
    closure.onCompleted = function (completedFuncParam)
    {
        completedFunc = completedFuncParam;
    };

    /// public: clear()
    closure.clear = function ()
    {
        closure.stop();
        children = [];
    };

    /// private: onStoppedOrCompleted()
    /// this is called when animation container is explictly stopped or all of the child
    /// animations have completed.
    var onStoppedOrCompleted = function ()
    {
        clearInterval(timer);
        timer = null;
        isRunning = false;

        if (completedFunc)
        {
            completedFunc();
        }
    };

    /// public: animateFrame()
    /// called once every 1/60 of a second or so.  its job is to call each child animation and
    /// keep track of which have completed.
    closure.animateFrame = function ()
    {
        //---- go thru backwards, so its safe to remove entries ----
        for (var i = children.length - 1; i >= 0; i--)
        {
            var child = children[i];
            var completed = child.animateFrame();

            if (completed)
            {
                children.removeAt(i);
            }
        }

        if (children.length == 0)
        {
            onStoppedOrCompleted();
        }
    };

    //---- init code ----
    return closure;

};

﻿///-----------------------------------------------------------------------------------------------------------------
/// animUtils.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library
///  - animation related utility functions.
///  - adapted from http://paulirish.com/2011/requestanimationframe-for-smart-animating/
///-----------------------------------------------------------------------------------------------------------------
vp.requestAnimationFrame = function (callback)  
{
    var func = 
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame;

    if (!func)
    {
        func = function (callback)
        {
            return setInterval(callback, 1000 / 60);
        };
    }

    return func(callback);
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// colorAnimation.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library
///  - animates a color.
///-----------------------------------------------------------------------------------------------------------------
//---- class: colorAnimation ----
vp.colorAnimation = function (parent, element, attributeName, fromColor, toColor)
{
    //---- local state ----
    var from = vp.colorHelper.getColorFromString(fromColor);
    var to = vp.colorHelper.getColorFromString(toColor);

    if (!from)
    {
        vp.error("colorAnimation: 'from' is not defined");
    }

    if (!to)
    {
        vp.error("colorAnimation: 'to' is not defined");
    }

    //---- closure object ----
    var closure = function ()
    {
    };

    /// private: getAnimateCalue(percent)
    var getAnimatedValue = function (percent)
    {
        var r = Math.round(from[0] + percent * (to[0] - from[0]));
        var g = Math.round(from[1] + percent * (to[1] - from[1]));
        var b = Math.round(from[2] + percent * (to[2] - from[2]));

        var value = "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
        return value;
    };

    /// public: animateFrame(percent)
    closure.animateFrame = function (percent)
    {
        var value = getAnimatedValue(percent);
        element.setAttribute(attributeName, value);
    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// eases.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - eases for animation.
///
/// - adapted from Microsoft WPF Framework (their ease functions).
///-----------------------------------------------------------------------------------------------------------------
//---- enum: easeMode ----
vp.easeMode = { easeIn: 0, easeOut: 1, easeInOut: 2 };

//---- enum: bezierEaseMode ----
vp.bezierEaseMode = { ease: 0, easeIn: 1, easeOut: 2, easeInOut: 3, linear: 4, maxEase: 5 };

//---- enum: bezierEaseMode ----
vp.bindAction = { enter: 0, update: 1, exit: 2 };

//---- class: easeBase ----
vp.easeBase = function ()
{
    this.easeMode = vp.easeMode.easeInOut;

    //---- this function is overwritten by subclasses ----
    this.easeCore = function (t)
    {
        return t;
    }

    this.ease = function (t)
    {
        var value;

        if (this.easeMode == vp.easeMode.easeIn)
        {
            value = this.easeCore(t);
        }
        else if (this.easeMode == vp.easeMode.easeOut)
        {
            value = this.easeCore(1 - t);
        }
        else
        {
            if (t < .5)
            {
                var coreValue = this.easeCore(t * 2);
                value = coreValue * .5;
            }
            else
            {
                var coreValue = this.easeCore(2 * (1 - t));
                value = (1 - coreValue) * .5 + .5;
            }
        }

        return value;
    }
};

//---- class: floorEase ----
//----      always uses the first value in a local pair of values. ----
vp.floorEase = function ()
{
};

vp.floorEase.prototype = new vp.easeBase();

vp.floorEase.prototype.easeCore = function (t)
{
    return 0;
};

//---- class: nearestNeighborEase ----
//----      use the ease that "t" is closest to ----
vp.nearestNeighborEase = function ()
{
};

vp.nearestNeighborEase.prototype = new vp.easeBase();

vp.nearestNeighborEase.prototype.easeCore = function (t)
{
    return (t < .5) ? 0 : 1;
};

//---- class: linearEase ----
//----      use the ease that "t" is closest to ----
vp.linearEase = function ()
{
};

vp.linearEase.prototype = new vp.easeBase();

vp.linearEase.prototype.easeCore = function (t)
{
    return t;
};

//---- class: quadraticEase ----
vp.quadraticEase = function ()
{
};

vp.quadraticEase.prototype = new vp.easeBase();

vp.quadraticEase.prototype.easeCore = function (t)
{
    return t * t;
};

//---- class: cubicEase ----
vp.quadraticEase = function ()
{
};

vp.quadraticEase.prototype = new vp.easeBase();

vp.quadraticEase.prototype.easeCore = function (t)
{
    return t * t * t;
};

//---- class: quarticEase ----
vp.quarticEase = function ()
{
};

vp.quarticEase.prototype = new vp.easeBase();

vp.quarticEase.prototype.easeCore = function (t)
{
    return t * t * t * t;
};

//---- class: sineEase ----
vp.sineEase = function ()
{
};


vp.sineEase.prototype = new vp.easeBase();

vp.sineEase.prototype.easeCore = function (t)
{
    return 1 - Math.sin(Math.pi * .5 * (1 - t));
};

//---- class: circleEase ----
vp.circleEase = function ()
{
};

vp.circleEase.prototype = new vp.easeBase();

vp.circleEase.prototype.easeCore = function (t)
{
    return 1 - Math.sqrt(1 - t * t);
};

//---- class: backEase ----
vp.backEase = function (amplitude)
{
    this.amplitude = amplitude;
};

vp.backEase.prototype = new vp.easeBase();

vp.backEase.prototype.easeCore = function (t)
{
    return Math.pow(t, 3.0) - t * this.amplitude * Math.sin(Math.PI * t);
};

//---- class: powEase ----
vp.powEase = function (n)
{
    this.n = Math.max(0, n);
};

vp.powEase.prototype = new vp.easeBase();

vp.powEase.prototype.easeCore = function (t)
{
    return Math.pow(t, this.n);
};

//---- class: expEase ----
vp.expEase = function (n)
{
    this.n = Math.max(0, n);
};

vp.expEase.prototype = new vp.easeBase();

vp.expEase.prototype.easeCore = function (t)
{
    if (vp.floatEq(0, this.n))
    {
        return t;
    }
    else
    {
        return (Math.exp(this.n * t) - 1.0) / (Math.exp(this.n) - 1.0);
    }
};

//---- class: springEase ----
vp.springEase = function (springiness, oscillations)
{
    this.springiness = springiness;
    this.oscillations = oscillations;
};

vp.springEase.prototype = new vp.easeBase();

vp.springEase.prototype.easeCore = function (t)
{
    var expo = 0;

    if (vp.floatEq(this.springiness, 0))
    {
        expo = t;
    }
    else
    {
        expo = (Math.exp(this.springiness * t) - 1.0) / (Math.exp(this.springiness) - 1.0);
    }

    return expo * (Math.sin((Math.pi * 2.0 * this.oscillations + Math.pi * 0.5) * t));
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// effects.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - support for enter/exit animation effects.
///-----------------------------------------------------------------------------------------------------------------

//---- animate opacity ----
vp.fadeType = { none: 0, fade: 1 };

//---- move shape to/from specified location ----
vp.slideLoc = { none: 0, left: 1, top: 2, right: 3, bottom: 4 };

//---- grow/shrink shape using specified origin ----
vp.growOrigin = { none: 0, left: 1, top: 2, right: 3, bottom: 4, center: 5 };

//---- make an effect object ----
vp.makeEffects = function (fadeType, slideLoc, growOrigin, rotateAngle, rotateCx, rotateCy)
{
    var effects =
    {
        fadeType: fadeType, slideLoc: slideLoc, growOrigin: growOrigin,
        rotateAngle: rotateAngle, rotateCx: rotateCx, rotateCy: rotateCy
    };

    return effects;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// numberAnimation.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library 
///   - animates a numeric property.
///-----------------------------------------------------------------------------------------------------------------
//---- class: numberAnimation ----
vp.numberAnimation = function (parent, element, attributeName, fromValue, toValue, isStyle)
{
    //---- private state ----
    var from = fromValue;
    var to = toValue;
    var iss = isStyle;

    //---- closure object ----
    var closure = function ()
    {
    };

    var init = function ()
    {
        //---- remove "px" from value ----
        if ((vp.isString(from)) && (from.endsWith("px")))
        {
            from = from.substr(0, from.length - 2);
        }

        //---- remove "px" from value ----
        if ((vp.isString(to)) && (to.endsWith("px")))
        {
            to = to.substr(0, to.length - 2);
        }
    }

    /// private: getAnimatedValue(percent)
    var getAnimatedValue = function (percent)
    {
        var value = from + percent * (to - from);
        return value;
    }

    var isStyled = function ()
    {
        return iss;
    }

    /// public: animateFrame(percent)
    closure.animateFrame = function (percent)
    {
        var value = getAnimatedValue(percent);

        if (isStyled())
        {
            if ((attributeName != "z-index") && (attributeName != "opacity"))
            {
                value = value + "px";
            }

            element.style[attributeName] = value;
        }
        else if (element[attributeName] == null)
        {
            //---- unusual case (stroke-width) - set using "value" ----
            //element.attributes[attributeName].value = value;
            element.setAttribute(attributeName, value);
        }
        else
        {
            //---- normal case - set using "baseVal.value" ----
            if (element.rootContainer)
            {
                //---- its a canvas element ----
                element[attributeName] = value;
                element.markRebuildNeeded();
            }
            else if (element.setAttribute)
            {
                element.setAttribute(attributeName, value);
            }
            else
            {
                //---- its an SVG/HTML element ----
                if (element[attributeName].baseVal)
                {
                    element[attributeName].baseVal.value = value;
                }
                else
                {
                    element[attributeName] = value;
                }
            }
        }
    }

    //---- init code ----
    init();

    //---- force to numbers for correct calculations ----
    from = +from;
    to = +to;
    iss = isStyle;

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// transformAnimation.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library 
///   - animates a transform (scale, translation, rotation).
///-----------------------------------------------------------------------------------------------------------------
//---- class: transformAnimation ----
vp.transformAnimation = function (parent, element)
{
    //---- private state ----
    var parts = [];

    //---- closure ----
    var closure = function ()
    {
    };

    /// public.
    closure.makeTransform = function (name, fromValue, toValue, cx, cy)
    {
        var part = { name: name, from: fromValue, to: toValue, cx: cx, cy: cy };
        parts.push(part);
    };

    /// private.
    var getAnimatedValue = function (percent)
    {
        //---- build transform string from parts[] ----
        var str = "";

        for (var i = 0; i < parts.length; i++)
        {
            var part = parts[i];
            var nextPartName = (i < parts.length - 1) ? parts[i + 1].name : "";

            var from = +part.from;
            var to = +part.to;
            var value = from + percent * (to - from);

            if (part.name == "scale.x")
            {
                var x = value;
                var y = 1;

                if (nextPartName == "scale.y")
                {
                    i++;
                    var nextPart = parts[i];

                    y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                }

                if (vp.isDefined(part.cx))
                {
                    //---- center the scaling at cx, cy ----
                    str += "translate( " + (-part.cx*(x-1)) + ", " + (-part.cy*(y-1)) + ") ";
                }

                str += "scale(" + x + " " + y + ") ";
            }
            else if (part.name == "scale.y")
            {
                if (vp.isDefined(part.cx))
                {
                    //---- center the scaling at cx, cy ----
                    str += "translate(0 " + (-part.cy * (value - 1)) + ") ";
                }

                str += "scale(1 " + value + ") ";
            }
            else if (part.name == "translate.x")
            {
                var x = value;
                var y = 0;

                if (nextPartName == "translate.y")
                {
                    i++;
                    var nextPart = parts[i];

                    y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                }

                str += "translate(" + x + " " + y + ") ";
            }
            else if (part.name == "translate.y")
            {
                str += "translate(0 " + value + ") ";
            }
            else if (part.name == "rotate")
            {
                str += "rotate(" + value;

                if (vp.isDefined(part.cx))
                {
                    str += " " + part.cx + " " + part.cy;
                }

                str += ") ";
            }
        }

        return str;
    }

    /// public.
    closure.animateFrame = function (percent)
    {
        var transformStr = getAnimatedValue(percent).trim();
        element.setAttribute("transform", transformStr);
    }

    //---- init code ----
    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - the base class for a canvas container or element.
///-----------------------------------------------------------------------------------------------------------------

//---- class: canvasElement ----
//----    Lightweight class to hold attributes for a canvas shape, and optional children. ----
vp.canvasElement = function (rootContainer)
{
    this.ctr = "vp.canvasElement;"
    this.rootContainer = rootContainer;
    this.opacity = 1;
    this.parentNode = (rootContainer) ? rootContainer.canvas : null;

    this.getRoot = function (elem)
    {
        while ((elem) && (elem.ctr != "vp.canvasContainerElement"))
        {
            elem = elem.parentElement;
        }

        return elem;
    };

    this.markRebuildNeeded = function ()
    {
        this.rootContainer.startAnimationClock();
    };

    this.setAttribute = function (name, value)
    {
        if (name == "d")
        {
            //---- special handling for path's data property ----
            this.d(value);
        }
        else if (name == "points")
        {
            //---- special handling for path's data property ----
            this.points(value);
        }
        else
        {
            this[name] = value;
        }

        this.markRebuildNeeded();
    };

    this.getAttribute = function (name)
    {
        return this[name];
    };

    this.append = function (strElem)
    {
        var elem = null;

        if (strElem == "rect")
        {
            elem = new vp.canvasRectElement(this);
        }
        else if (strElem == "circle")
        {
            elem = new vp.canvasCircleElement(this);
        }
        else if (strElem == "ellipse")
        {
            elem = new vp.canvasEllipseElement(this);
        }
        else if (strElem == "text")
        {
            elem = new vp.canvasTextElement(this);
        }
        else if (strElem == "line")
        {
            elem = new vp.canvasLineElement(this);
        }
        else if (strElem == "path")
        {
            elem = new vp.canvasPathElement(this);
        }
        else if (strElem == "polygon")
        {
            elem = new vp.canvasPolygonElement(this);
        }
        else if (strElem == "g")
        {
            elem = new vp.canvasGroupElement(this);
        } else
        {
            vp.error("This element type not yet supported for canvas by VuePlot: " + strElem);
        }

        if (elem != null)
        {
            this.children.push(elem);
            this.markRebuildNeeded();
        }

        return elem;
    };

    //this.setClass = function (className)
    //{
    //    switch (className)
    //    {
    //        case "vpChartTitle":
    //            {
    //                this.fill = "gray";
    //                this["font-size"] = 14;
    //                break;
    //            }

    //        case "vpLegendTitle":
    //            {
    //                this["font-weight"] = "bold";
    //                break;
    //            }

    //        case "vpLegendText":
    //        case "vpTickLabel":
    //            {
    //                this.fill = "gray";
    //                this["font-size"] = 11;
    //                break;
    //            }

    //        case "vpAxisLine":
    //        case "vpGridLine":
    //            {
    //                this.stroke = "lightgray";
    //                this["stroke-width"] = 1;
    //                break;
    //            }

    //        case "vpTickMark":
    //        case "vpFrameLine":
    //            {
    //                this.stroke = "gray";
    //                this["stroke-width"] = 1;
    //                break;
    //            }

    //        case "vpAxisLabel":
    //            {
    //                this.fill = "gray";
    //                this["font-size"] = 12;
    //                break;
    //            }


    //        case "vpPlotBg":
    //            {
    //                this.fill = "white";
    //                break;
    //            }
    //    }
    //};
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasSelectedSet.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - holds a set of canvas items that actions can be executed against.  
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasSelectedSet ----
vp.canvasSelectedSet = function (parentElem, selector)
{
    this.ctr = "vp.canvasSelectedSet";
    this.parentElem = parentElem;
    this.length = 0;

    //---- make "selectedSet" look/act like an array object ---
    this.push = Array.prototype.push;
    this.sort = Array.prototype.sort;
    this.splice = Array.prototype.splice;
    this.indexOf = Array.prototype.indexOf;
    this.select = Array.prototype.select;

    if (vp.isString(selector))
    {
        var elems = vp.fn.getElementsInSelectorString(parentElem, selector);

        for (var i = 0; i < elems.length; i++)
        {
            this.push(elems[i]);
        }
    }
    else if (vp.isArray(selector))
    {
        for (var i = 0; i < selector.length; i++)
        {
            this.push(selector[i]);
        }
    }
    else if (selector != null)
    {
        //---- assume it is a single element ----
        this.push(selector);
    }

};

vp.fnCanvas = vp.canvasSelectedSet.prototype;

vp.canvasSelect = function (selectStr)
{
    return new vp.canvasSelectedSet(document.body, selectStr);
};

vp.selectContext = function (selectStr, contextName)
{
    var ssCanvas = vp.canvasSelect();

    var elems = vp.getElementsInSelectorString(document.body, selectStr);
    var ss = new vp.selectedSet(elems);

    if (ss.length > 0)
    {
        var cc = ss.context(contextName);
        if (cc != null)
        {
            ssCanvas = ssCanvas.merge(cc);
        }
    }

    return ssCanvas;
};

//---- extend vuePlot selected set to add "context()" ----
//---- use to obtain a Canvas (2d) or WebGL (3d) context ----
vp.fn.context = function (origRequest)
{
    var cc = null;
    var value = null;

    for (var i = 0; i < this.length; i++)
    {
        var elem = this[i];

        var contextRequest = origRequest;

        if (elem.getContext)
        {
            if (contextRequest == "3d")
            {
                //---- works for Chrome, Safari, FireFox ----
                contextRequest = "experimental-webgl";

                //---- setting alpha=false prevents alpha values that we output from compositing with other DOM elements ----
                value = elem.getContext(contextRequest, { alpha: false });
            }
            else
            {
                value = elem.getContext(contextRequest);
            }
        }

        if (value == null)
        {
            if (origRequest == "2d")
            {
                //alert("This browser doesn't support HTML 5 Canvas.  Try IE9");
            }
            else
            {
                //alert("This browser doesn't support WebGL.  Try latest Chrome or Firefox");
            }
        }

        if (value != null)
        {
            if (elem.canvasContainerElement != null)
            {
                //---- reuse existing object (prevent duplicates w/diff info) ----
                cc = elem.canvasContainerElement;
                cc.ctx = value;
                cc.contextRequest = origRequest;
            }
            else
            {
                cc = new vp.canvasContainerElement(elem, value, origRequest);
            }
        }

        break;
    }

    return cc;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasUtils.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions for canvas.
///-----------------------------------------------------------------------------------------------------------------
vp.parsePathDataAndGenerateDrawFunc = function (dstr)
{
    var index = 0;
    var d = dstr;
    var firstPt = { x: 0, y: 0 };
    var lastPt = { x: 0, y: 0 };
    var firstPointSeen = false;

    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = -Number.MAX_VALUE;      // Number.MIN_VALUE;
    var maxY = -Number.MAX_VALUE;      // Number.MIN_VALUE;

    function skipSpaces(d)
    {
        while (index < d.length)
        {
            var ch = d[index];
            if ((ch == ' ') || (ch == "\t") || (ch == "\r") || (ch == '\n') | (ch == ","))
            {
                index++;
            }
            else
            {
                break;
            }
        }
    }

    function parseNumber(d)
    {
        skipSpaces(d);
        var isNegative = false;
        var value = 0;

        if (index < d.length)
        {
            var ch = d[index];
            if (ch == "+")
            {
                index++;
            }
            else if (ch == '-')
            {
                index++;
                isNegative = true;
            }

            var start = index;

            while (index < d.length)
            {
                var ch = d[index];

                if ((ch == '.') || ((ch >= '0') && (ch <= '9')))
                {
                    index++;
                }
                else
                {
                    break;
                }
            }

            var str = d.substr(start, index - start);
            value = parseFloat(str);
        }

        if (isNegative)
        {
            value = -value;
        }

        return value;
    }

    function parsePoint(d, isRelative)
    {
        /// <number> [ "," ] <number>    (skip spaces in-between each element) 
        var x = parseNumber(d);
        var y = parseNumber(d);

        if (isRelative)
        {
            x += lastPt.x;
            y += lastPt.y;
        }

        var pt = { x: x, y: y };

        onPointSeen(pt);

        return pt;
    }

    function onPointSeen(pt)
    {
        if (!firstPointSeen)
        {
            firstPt = pt;
            firstPointSeen = true;
        }

        lastPt = pt;

        minX = Math.min(minX, pt.x);
        minY = Math.min(minY, pt.y);

        maxX = Math.max(maxX, pt.x);
        maxY = Math.max(maxY, pt.y);

    }

    var funcStr = "function (ctx)\r\n"
        + "{\r\n";

    var cmd = "";

    /// sample: d="M 100 100 L 300 100 L 200 300 z"
    /// uppercase cmd letter: absolute coordinates, lowercase: relative coordinates
    ///
    /// M=move, L=line, Z=close, H=horizontal line, V=vertical line, C=cubic bezier, S=reflective cubic bezier
    /// Q=quadratic bezier, T=reflective quadratic, A=arc

    var lastIndex = -1;

    while (index < d.length)
    {
        skipSpaces(d);

        if (index == lastIndex)
        {
            vp.error("Error: internal error in parsePathDataAndGenerateDrawFunc()");
        }

        if (index >= d.length)
        {
            break;
        }

        lastIndex = index;

        var ch = d[index];
        var isLower = ((ch >= "a") && (ch <= "z"));
        var isUpper = ((ch >= "A") && (ch <= "Z"));

        if ((isLower) || (isUpper))
        {
            //---- new cmd specified ----
            cmd = ch;
            index++;

            skipSpaces(d);
            if (index >= d.length)
            {
                break;
            }
        }

        //---- process current command ----
        if ((cmd == "M") || (cmd == "m"))
        {
            var pt = parsePoint(d, cmd == "m");

            funcStr += "    ctx.moveTo(" + pt.x + ", " + pt.y + ");\r\n";
        }
        else if ((cmd == "L") || (cmd == "l"))
        {
            var pt = parsePoint(d, cmd == "l");

            funcStr += "    ctx.lineTo(" + pt.x + ", " + pt.y + ");\r\n";
        }
        else if ((cmd == "A") || (cmd == "a"))
        {
            vp.error("Error - 'A' (arc) command in path not currently supported by VuePlot");

            //---- not supported (code below is incomplete ----
            //var rx = parseNumber(d);
            //var ry = parseNumber(d);
            //var xRotate = parseNumber(d);
            //var largeArc = parseNumber(d);
            //var sweepFlag = parseNumber(d);
            //var ptEnd = parsePoint(d, cmd == "a");

            //var ptCenter = xx;
            //var radius = rx;
            //var startAngle = xx;
            //var endAngle = yy;

            //funcStr += "    ctx.arc(" + ptCenter.x + ", " + ptCenter.y + "," + radius + "," +
            //    startAngle + "," + endAngle + "," + sweepFlag + ");\r\n";
        }
        else if ((cmd == "Z") || (cmd == "z"))
        {
            if (firstPt)
            {
                //---- close path with straight line to first point ----
                funcStr += "ctx.lineTo(" + firstPt.X + ", " + firstPt.Y + ");\r\n";
            }
        }
        else
        {
            vp.error("Error: unrecognized in path: " + cmd);
        }
    }

    funcStr += "}\r\n";
    var bb = vp.rect(minX, minY, maxX - minX, maxY - minY);

    return [funcStr, bb];
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// fnCanvas.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - functions that extend the canvasSelectedSet class.
///-----------------------------------------------------------------------------------------------------------------

//---- is this still needed? ----
//vp.fn = vp.fn;

//---- set up sharing of functions with vuePlot selectedSet class ----
vp.fnCanvas.dataBind = vp.fn.dataBind;
vp.fnCanvas.left = vp.fn.left;
vp.fnCanvas.top = vp.fn.top;
vp.fnCanvas.width = vp.fn.width;
vp.fnCanvas.height = vp.fn.height;
vp.fnCanvas.toolTipEnabled = vp.fn.toolTipEnabled;
vp.fnCanvas.animate = vp.fn.animate;
vp.fnCanvas.onAnimationComplete = vp.fn.onAnimationComplete;
vp.fnCanvas.remove = vp.fn.remove;
vp.fnCanvas.add = vp.fn.add;
vp.fnCanvas.radius = vp.fn.radius;
vp.fnCanvas.transform = vp.fn.transform;
vp.fnCanvas.clear = vp.fn.clear;
vp.fnCanvas.show = vp.fn.show;
vp.fnCanvas.hide = vp.fn.hide;
vp.fnCanvas.href = vp.fn.href;
vp.fnCanvas.bounds = vp.fn.bounds;
vp.fnCanvas.opacity = vp.fn.opacity;
vp.fnCanvas.position = vp.fn.position;
vp.fnCanvas.center = vp.fn.center;
vp.fnCanvas.id = vp.fn.id;
vp.fnCanvas.addClass = vp.fn.addClass;
vp.fnCanvas.removeClass = vp.fn.removeClass;
vp.fnCanvas.hasClass = vp.fn.hasClass;
vp.fnCanvas.setClass = vp.fn.setClass;
vp.fnCanvas.toggleClass = vp.fn.toggleClass;
vp.fnCanvas.attach = vp.fn.attach;
vp.fnCanvas.detach = vp.fn.detach;
vp.fnCanvas.from = vp.fn.from;
vp.fnCanvas.to = vp.fn.to;
vp.fnCanvas.font = vp.fn.font;
vp.fnCanvas.colors = vp.fn.colors;
vp.fnCanvas.data = vp.fn.data;
vp.fnCanvas.dataItem = vp.fn.dataItem;
vp.fnCanvas.dataIndex = vp.fn.dataIndex;
vp.fnCanvas.customAttr = vp.fn.customAttr;
vp.fnCanvas.css = vp.fn.css;
vp.fnCanvas.text = vp.fn.text;
vp.fnCanvas.value = vp.fn.value;
vp.fnCanvas.html = vp.fn.html;
vp.fnCanvas.toArray = vp.fn.toArray;
vp.fnCanvas.each = vp.fn.each;


/// adds the specified element/array to the selected set.
vp.fnCanvas.merge = function (elemOrArray)
{
    var newElements = null;

    if (elemOrArray instanceof vp.canvasSelectedSet)
    {
        elemOrArray = elemOrArray.toArray();
    }

    if (vp.isArray(elemOrArray))
    {
        newElements = this.toArray().concat(elemOrArray);
    }
    else
    {
        var aray = this.toArray();
        aray.push(elemOrArray);
        newElements = aray;
    }

    var newSet = new vp.canvasSelectedSet(this.parentElem, newElements);

    return newSet;
};

/// rapidly creates and appends the specified "str" canvas element for the specified "count".
vp.fnCanvas.multiAppend = function (str, count)
{
    var appendedElements = [];

    if (this.length > 0)
    {
        //---- for now, only support first container ----//
        var container = this[0];

        for (var i = 0; i < count; i++)
        {
            var elem = container.append(str);
            appendedElements.push(elem);
        }
    }

    return appendedElements;
}

vp.fnCanvas.updateBounds = function (w, h)
{
    return this.each(function (index, container)
    {
        this.updateBounds(w, h);
    });
};

vp.fnCanvas.initShaderAnimations = function (duration, onCompleteCallback)
{
    return this.each(function (index, container)
    {
        this.initShaderAnimations(duration, onCompleteCallback);
    });
};

vp.fnCanvas.resetShaderAnimations = function ()
{
    return this.each(function (index, container)
    {
        this.resetShaderAnimations();
    });
};

vp.fnCanvas.pointSize = function (value)
{
    if (arguments.length == 0)
    {
        value = (this.length > 0) ? this[0].pointSize() : undefined;
        return value;
    }

    return this.each(function (index, container)
    {
        this.pointSize(value);
    });
};

vp.fnCanvas.usePointSprites = function (value)
{
    if (arguments.length == 0)
    {
        value = (this.length > 0) ? this[0].usePointSprites() : undefined;
        return value;
    }

    return this.each(function (index, container)
    {
        this.usePointSprites(value);
    });
};

vp.fnCanvas.usePointSize = function (value)
{
    if (arguments.length == 0)
    {
        value = (this.length > 0) ? this[0].usePointSize() : undefined;
        return value;
    }

    return this.each(function (index, container)
    {
        this.usePointSize(value);
    });
};

vp.fnCanvas.markRebuildNeeded = function ()
{
    return this.each(function (index, container)
    {
        this.markRebuildNeeded();
    });
};

vp.fnCanvas.append = function (content)
{
    var appendedElements = [];
    var firstContainer = null;

    this.each(function (index, container)
    {
        if (firstContainer == null)
        {
            firstContainer = container;
        }

        if (content instanceof vp.selectedSet)
        {
            content = content.toArray();
        }
        else if (content instanceof vp.visuals.singleWrapperClass)
        {
            content = content.elem;
        }

        if (vp.isArray(content))
        {
            for (var i = 0; i < content.length; i++)
            {
                var child = content[i];
                var element = container.appendChild(child);
                appendedElements.push(element);
            }
        }
        else if (vp.isString(content))
        {
            var canvasElement = this.append(content);
            if (canvasElement != null)
            {
                //---- transfer data info from parent container ----
                canvasElement.dataItem = container.dataItem;
                canvasElement.dataIndex = container.dataIndex;

                appendedElements.push(canvasElement);
            }
        }
        else if (content != null)
        {
            container.appendChild(content);
            appendedElements.push(content);
        }
    });

    var ss = null;

    if (firstContainer != null)
    {
        ss = new vp.canvasSelectedSet(firstContainer, appendedElements);
    }

    return ss;
};

vp.fnCanvas.frameRateChanged = function (fpsCallBack)
{
    var appendedElements = [];
    var firstContainer = null;

    this.each(function (index, container)
    {
        vp.frameRateChanged(this, fpsCallBack);
    });

    return this;
};

vp.fn.frameRateChanged = vp.fnCanvas.frameRateChanged;

vp.fnCanvas.attr = function (name, origValue)
{
    return this.each(function (index, element)
    {
        var value = origValue;

        if (typeof origValue === "function")
        {
            value = origValue(element.dataItem, element.dataIndex);
        }

        if (vp.isUndefined(this.animation))
        {
            //---- no animation is active - just set in instantly ----
            //this[name] = value;
            //this.markRebuildNeeded();
            this.setAttribute(name, value);
        }
        else
        {
            //---- add to current animation ----
            this.animation.animateAttr(element, name, value);
        }
    });
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// inkHitTest.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library 
///     - does ink based hit testing of a shape and rectangle, using a temp. canvas
///-----------------------------------------------------------------------------------------------------------------
vp.inkHitTest = function (rect)
{
    //---- private state ----
    var tempCanvas = null;
    var root = null;
    var w = rect.width;
    var h = rect.height;
    var ctx = null;

    //---- closure ----
    var closure = function ()
    {
    };

    var transferAttrs = function (fromElem, toElem, attrNameList)
    {
        //---- unwrap toElem ----
        toElem = (toElem.length) ? toElem[0] : toElem;

        for (var i = 0; i < attrNameList.length; i++)
        {
            var name = attrNameList[i];
            var value = (name == "text") ? vp.text(fromElem) : vp.attr(fromElem, name);

            if (value !== undefined)
            {
                vp.attr(toElem, name, value);
            }
        }
    }

    var canvasElemFromSvg = function (canvasRoot, svgElem)
    {
        //---- add svgElem to canvasRoot ----
        var canvasElem = null;

        if (svgElem.tagName == "g")
        {
            canvasElem = canvasRoot.append("g");
            transferAttrs(svgElem, canvasElem, []);
        }
        else if (svgElem.tagName == "rect")
        {
            canvasElem = canvasRoot.append("rect");
            transferAttrs(svgElem, canvasElem, ["x", "y", "width", "height"]);
        }
        else if (svgElem.tagName == "line")
        {
            canvasElem = canvasRoot.append("line");
            transferAttrs(svgElem, canvasElem, ["x1", "y1", "x2", "y2"]);
        }
        else if (svgElem.tagName == "circle")
        {
            canvasElem = canvasRoot.append("circle");
            transferAttrs(svgElem, canvasElem, ["cx", "cy", "r"]);
        }
        else if (svgElem.tagName == "ellipse")
        {
            canvasElem = canvasRoot.append("ellipse");
            transferAttrs(svgElem, canvasElem, ["cx", "cy", "rx", "ry"]);
        }
        else if (svgElem.tagName == "path")
        {
            canvasElem = canvasRoot.append("path");
            transferAttrs(svgElem, canvasElem, ["d"]);
        }
        else if (svgElem.tagName == "polyline")
        {
            canvasElem = canvasRoot.append("polyline");
            transferAttrs(svgElem, canvasElem, ["points"]);
        }
        else if (svgElem.tagName == "polygon")
        {
            canvasElem = canvasRoot.append("polygon");
            transferAttrs(svgElem, canvasElem, ["points"]);
        }
        else if (svgElem.tagName == "text")
        {
            canvasElem = canvasRoot.append("text");
            transferAttrs(svgElem, canvasElem, ["x", "y", "text", "dx", "dy", "font-size", "font-width", "font-weight",
                "font-style", "font-family"]);
        }
        else
        {
            //vp.error("unsupported SVG element: " + svgElem.tagName);
        }

        if (canvasElem)
        {
            //---- transfer common attributes -----
            transferAttrs(svgElem, canvasElem, ["transform", "fill", "stroke", "stroke-width"]);

            //---- unwrap canvasElem ----
            canvasElem = (canvasElem.length) ? canvasElem[0] : canvasElem;
        }
        else
        {
            canvasElem = vp.select("");     // empty wrapper
        }

        return canvasElem;
    };

    var addCanvasChild = function (canvasParent, svgElem)
    {
        if (svgElem.tagName)           // only process nodes with a valid tagName
        {
            canvasParent = canvasElemFromSvg(canvasParent, svgElem);

            //---- now add children of svgElem ----
            var kids = vp.children(svgElem);
            if (kids.length > 0)
            {
                var wcp = vp.wrapElements(canvasParent);

                for (var i = 0; i < kids.length; i++)
                {
                    addCanvasChild(wcp, kids[i]);
                }
            }
        }
    }

    closure.close = function ()
    {
        //---- remove temp canvas ----
        root[0].close();        // stop drawing
        tempCanvas.remove();
    };

    closure.doesShapeOverlap = function (svgShape)
    {
        var shapeWidth = vp.width(svgShape);
        var shapeHeight = vp.height(svgShape);

        root.clear();       // remove previous shapes

        addCanvasChild(root, svgShape);

        //---- clear the canvas ----
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, w, h);

        //---- set the transform so that only the rect area of the shape will be drawn on the canvas ----
        var x = -rect.left;
        var y = -rect.top;
        ctx.setTransform(1, 0, 0, 1, x, y);

        //---- draw the shape ----
        root[0].drawAll(ctx);

        //---- get the pixels in the canvas ----
        var imageData = ctx.getImageData(0, 0, w, h);

        var intersects = false;

        //---- now, walk each pixel and see if any ink is present ----
        var index = 0;
        for (var r = 0; r < h; r++)
        {
            if (intersects)
            {
                break;
            }

            for (var c = 0; c < w; c++)
            {
                if (intersects)
                {
                    break;
                }

                for (var p = 0; p < 4; p++)
                {
                    if (imageData.data[index++])
                    {
                        intersects = true;
                        break;
                    }
                }
            }
        }

        return intersects;
    };

    //---- init code ----
    //---- create a temp. canvas object to render to ----
    tempCanvas = vp.select(document.body).append("canvas")
        .id("$_tempCanvas")
        .attr("width", w)
        .attr("height", h);

    root = vp.selectContext("#$_tempCanvas", "2d");
    ctx = root[0].ctx;

    return closure;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasCircleElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS CIRCLE element.
///-----------------------------------------------------------------------------------------------------------------

//---- class: canvasCircleElement ----
vp.canvasCircleElement = function (parentElement)
{
    this.ctr = "vp.canvasCircleElement";
    this.tagName = "circle";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer;        //  rootContainer.canvas;
    this.opacity = 1;
    this.cx = 0;
    this.cy = 0;
    this.r = 0;

    this.getOffset = function ()
    {
        var x = this.cx - this.r;
        var y = this.cy - this.r;

        return { x: x, y: y };
    };

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        var elem = null;

        //---- for circle, this is easy.  use distance <= r for match ----
        var xdiff = this.cx - x;
        var ydiff = this.cy - y;

        var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (dist <= this.r)
        {
            elem = this;
        }

        //vp.debug("circle.hitTest: dist=" + dist);

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            ctx.beginPath();
            ctx.arc(this.cx, this.cy, this.r, 0, Math.PI * 2, true);
            ctx.closePath();

            if (container.isHitTesting)
            {
                container.hitTestPath(ctx, this);
            }

            if (this.fill != null)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }

                ctx.fill();
                //ctx.addHitRegion("circle1");
            }

            if (this.stroke != null)
            {
                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }

                ctx.stroke();
            }
        }
    };

    this.getWidth = function ()
    {
        return 2 * this.r;
    };

    this.getHeight = function ()
    {
        return 2 * this.r;
    };
};

//---- inherit from canvasElement ----
vp.canvasCircleElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasContainerElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - holds information associated with a CANVAS DOM element.
///-----------------------------------------------------------------------------------------------------------------

//---- class: canvasContainerElement ----
vp.canvasContainerElement = function (canvas, ctx, contextRequest)
{
    //---- keep us as property on canvas, so other instances can reuse us ----
    //---- and, as we walk the hierarchy, we know that this is a canvas on which we have ----
    //---- canvas lightweight elements.
    canvas.canvasContainerElement = this;

    this.ctr = "vp.canvasContainerElement";
    this.canvas = canvas;
    this.ctx = ctx;
    this.rootContainer = this;
    this.parentElement = canvas;
    this.children = [];
    this.contextRequest = contextRequest;
    this.initialized = false;

    this.frameCount = 0;
    this.lastTime = new Date();
    this.frameRate = 0;
    this.frameRateChanged = null;
    this.glHelper = null;
    this.rebuildNeeded = true;
    this.opacity = 1;

    this.currentFill = "";
    this.currentStroke = "";
    this.currentStrokeWidth = 0;
    this.selectedFill = "orange";
    this.drawCallback = null;
    this.activeAnimations = [];           // list of active animations
    this.rebuildNeeded = false;           // this flagged is used to rebuild buffers (don't remove)

    //---- hit test management ----
    this.isHitTesting = false;
    this.hitTestX = 0;
    this.hitTestY = 0;
    this.hitTestResult = null;

    var self = this;

    if (this.contextRequest == "3d")
    {
        this.glHelper = new vp.glHelper(this);
        this.initialized = this.glHelper.init(canvas, ctx);
    }

    this.outerDraw = function ()
    {
        self.draw();
    }

    this.updateBounds = function (w, h)
    {
        if (this.glHelper)
        {
            this.glHelper.updateBounds(w, h);
        }
    };

    this.initShaderAnimations = function (duration, onCompleteCallback)
    {
        if (this.glHelper)
        {
            this.glHelper.initShaderAnimations(duration, onCompleteCallback);
        }
        else
        {
            //---- create CPU animations for all shapes & properties ----
            //---- first, create a master animation to control timing of everything ----
            var master = vp.animationContainer()
                .onCompleted(onCompleteCallback);
                
            var easeObj =  new vp.powEase(2);

            for (var i = 0; i < this.children.length; i++)
            {
                var shape = this.children[i];

                //---- animation object for all properties of this element ----
                var anim = vp.animation(shape, duration, null, master);

                if (shape.x != shape.toX)
                {
                    anim.animateAttr(shape, "x", shape.x, shape.toX, null, null, false);
                }

                if (shape.y != shape.toY)
                {
                    anim.animateAttr(shape, "y", shape.y, shape.toY, null, null, false);
                }

                if (shape.width != shape.toWidth)
                {
                    anim.animateAttr(shape, "width", shape.width, shape.toWidth, null, null, false);
                }

                if (shape.height != shape.toHeight)
                {
                    anim.animateAttr(shape, "height", shape.height, shape.toHeight, null, null, false);
                }

                if (shape.fill != shape.toColor)
                {
                    anim.animateAttr(shape, "fill", shape.fill, shape.toColor, null, null, false);
                }

                if (shape.opacity != shape.toOpacity)
                {
                    anim.animateAttr(shape, "opacity", shape.opacity, shape.toOpacity, null, null, false);
                }
            }
        }
    };

    this.resetShaderAnimations = function ()
    {
        if (this.glHelper)
        {
            this.glHelper.resetShaderAnimations();
        }
    };

    this.pointSize = function (value)
    {
        if (arguments.length == 0)
        {
            value = (this.glHelper) ? this.glHelper.pointSize() : 0;
            return value;
        }

        if (this.glHelper)
        {
            this.glHelper.pointSize(value);
        }
    };

    this.usePointSprites = function (value)
    {
        if (arguments.length == 0)
        {
            value = (this.glHelper) ? this.glHelper.usePointSprites() : 0;
            return value;
        }

        if (this.glHelper)
        {
            this.glHelper.usePointSprites(value);
        }
    };

    this.usePointSize = function (value)
    {
        if (arguments.length == 0)
        {
            value = (this.glHelper) ? this.glHelper.usePointSize() : 0;
            return value;
        }

        if (this.glHelper)
        {
            this.glHelper.usePointSize(value);
        }
    };

    /// hit testing for canvas 2D/3D elements (rect, circle, text, line, etc).
    this.getCanvasElementAtPoint = function (x, y)
    {
        var elemFound = null;

        if (this.glHelper)
        {
            elemFound = this.glHelper.hitTest(this.children, x, y);
        }
        else
        {
            //---- canvas 2d - use pointInPath() during drawing to find elem ----
            this.isHitTesting = true;
            this.hitTestX = x;
            this.hitTestY = y;
            this.hitTestResult = null;

            this.draw();

            elemFound = this.hitTestResult;
        }

        return elemFound;
    }

    this.markRebuildNeeded = function ()
    {
        if (this.glHelper)
        {
            this.rebuildNeeded = true;
        }
        else
        {
            this.startAnimationClock();
        }
    };

    /// remove the specified child element.
    this.removeChild = function (element)
    {
        this.children.remove(element);
        this.markRebuildNeeded();
    };

    /// remove all children.
    this.clear = function ()
    {
        this.children = [];
        this.markRebuildNeeded();
    };

    this.hitTestPath = function (ctx, elem)
    {
        if (ctx.isPointInPath(this.hitTestX, this.hitTestY))
        {
            this.hitTestResult = elem;
            this.isHitTesting = false;
        }
    }

    this.drawAll = function (ctx)
    {
        ctx.globalAlpha = 1;
        //this.drawSelf(ctx);

        this.currentFill = "notaColor";
        this.currentStroke = "notaColor";
        this.currentStrokeWidth = -999;
        this.selectedFill = "orange";

        //---- draw children ----
        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i].drawAll(ctx, this);

            if (false)
            {
                if (child.isImage)
                {
                    ctx.drawImage(child.imageElement, child.x, child.y, child.width, child.height);
                }
            }
        }
    }

    this.draw = function ()
    {
        //---- frame stats ----
        this.frameCount++;

        var elapsed = new Date() - this.lastTime;
        if (elapsed >= 1000)
        {
            this.frameRate = Math.round(this.frameCount / (elapsed / 1000));

            if (this.frameRateChanged != null)
            {
                var count = this.children.length;
                this.frameRateChanged(this.frameRate, count, this.bufferBuildTime);
            }

            this.frameCount = 0;
            this.lastTime = new Date();
        }

        if (this.glHelper == null)
        {
            //---- clear the canvas ----
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.drawAll(this.ctx);
        }
        else
        {
            if (this.rebuildNeeded)
            {
                var start = new Date();
                this.glHelper.rebuildBuffers(this.children);
                this.rebuildNeeded = false;

                //logTime(start, "MESH build");

                this.bufferBuildTime = new Date() - start;
            }

            this.glHelper.drawScene();
        }

        if (this.drawCallback)
        {
            this.drawCallback();
        }

        if (this.activeAnimations.length == 0)
        {
            this.stopAnimationClock();
        }

    };

    this.startAnimationClock = function ()
    {
        if (!this.timer)
        {
            //---- this doesn't always work on Chrome ----
            //this.timer = vp.requestAnimationFrame(this.outerDraw);
            this.timer = setInterval(this.outerDraw, 1000 / 60);
        }
    };

    this.stopAnimationClock = function ()
    {
        if (!this.glHelper)
        {
            //---- stop animation clock  ----
            clearInterval(this.timer);
            this.timer = null;
        }
    };

    this.addAnimation = function (anim)
    {
        this.activeAnimations.push(anim);

        if (this.activeAnimations.length == 1)
        {
            this.startAnimationClock();
        }
    };

    this.removeAnimation = function (anim)
    {
        this.activeAnimations.remove(anim);
    };

    //---- init code continued ----
    this.startAnimationClock();

    this.close = function ()
    {
        clearTimeout(this.timer);
        this.timer = null;
    };
};

//---- inherit from canvasElement ----
vp.canvasContainerElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasEllipseElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS ELLIPSE element.
///-----------------------------------------------------------------------------------------------------------------

//---- class: canvasEllipseElement ----
vp.canvasEllipseElement = function (parentElement)
{
    this.ctr = "vp.canvasEllipseElement";
    this.tagName = "ellipse";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer;        //  rootContainer.canvas;
    this.opacity = 1;
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;

    this.getOffset = function ()
    {
        var x = this.cx - this.rx;
        var y = this.cy - this.ry;

        return { x: x, y: y };
    };

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        var elem = null;

        //---- for ellipse, this is easy.  use distance <= r for match ----
        var xdiff = this.cx - x;
        var ydiff = this.cy - y;

        var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (dist <= Math.max(this.rx, this.ry))     // not exactly right, but close enough for now
        {
            elem = this;
        }

        //vp.debug("ellipse.hitTest: dist=" + dist);

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            var left = this.cx - this.rx;
            var right = this.cx + this.rx;

            var top = this.cy - this.ry;
            var bottom = this.cy + this.ry;

            //---- canvas has no built-in ellipse support, so we just scale a circle ----
            var xScale = 1;
            var yScale = 1;
            var radius = this.rx;

            if (this.rx > this.ry)
            {
                yScale = this.ry / this.rx;
                radius = this.rx;
            }
            else
            {
                xScale = this.rx / this.ry;
                radius = this.ry;
            }

            ctx.beginPath();
            ctx.save();
            ctx.translate(this.cx, this.cy);
            ctx.scale(xScale, yScale);
            ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
            ctx.restore();
            ctx.closePath();

            if (container.isHitTesting)
            {
                container.hitTestPath(ctx, this);
            }

            if (this.fill != null)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }

                ctx.fill();
                //ctx.addHitRegion("ellipse1");
            }

            if (this.stroke != null)
            {
                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }

                ctx.stroke();
            }
        }
    };

    this.getWidth = function ()
    {
        return 2 * this.rx;
    };

    this.getHeight = function ()
    {
        return 2 * this.ry;
    };
};

//---- inherit from canvasElement ----
vp.canvasEllipseElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasGroupElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - a class for a lightweight canvas GROUP element  
///-----------------------------------------------------------------------------------------------------------------

//---- class: canvasGroupElement ----
vp.canvasGroupElement = function (parentElement)
{
    this.ctr = "vp.canvasGroupElement";
    this.tagName = "g";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.children = [];
    this.x = 0;
    this.y = 0;

    this.getOffset = function ()
    {
        return { x: this.x, y: this.y };
    };

    this.clear = function ()
    {
        this.children = [];
        this.markRebuildNeeded();
    };

    /// find 2d/3d element that intersects with x,y at z=0.  return that element.
    this.hitTest = function (x, y)
    {
        var elem = null;

        //---- for now, we test each child.  may use color-based bitmap in future. ----
        for (var i = 0; i < this.children.length; i++)
        {
            var child = this.children[i];
            elem = child.hitTest(x, y);

            if (elem)
            {
                break;
            }
        }

        return elem;
    };

    this.appendChild = function (element)
    {
        this.children.push(element);
        this.markRebuildNeeded();
    };

    /// remove the specified child element.
    this.removeChild = function (element)
    {
        this.children.remove(element);
        this.markRebuildNeeded();
    };

    /// remove all children.
    this.clear = function ()
    {
        this.children = [];
        this.markRebuildNeeded();
    };

    this.drawAll = function (ctx, container)
    {
        //---- todo: apply transfrom from each element (group & children) ----

        if (this.visibility != "hidden")
        {
            //---- draw children ----
            for (var i = 0; i < this.children.length; i++)
            {
                var child = this.children[i];

                child.drawAll(ctx, container);
            }
        }
    };

    this.getWidth = function ()
    {
        return Math.abs(this.x1 - this.x2);
    };

    this.getHeight = function ()
    {
        return Math.abs(this.y1 - this.y2);
    };
};

//---- inherit from canvasElement (executed only once) ----
vp.canvasGroupElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasLineElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS LINE element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasLineElement ----
vp.canvasLineElement = function (parentElement)
{
    this.ctr = "vp.canvasLineElement";
    this.tagName = "rect";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;

    this.getOffset = function ()
    {
        var left = Math.min(this.x1, this.x2);
        var top = Math.min(this.y1, this.y2);

        return { x: left, y: top };
    };

    /// return line at x,y, if any.
    this.hitTest = function (x, y)
    {
        //---- for NOW, just use axis aligned rect.  later, we will test the non-axis aligned rect that is the line ----
        var elem = null;

        var left = Math.min(this.x1, this.x2);
        var right = Math.max(this.x1, this.x2);

        var top = Math.min(this.y1, this.y2);
        var bottom = Math.max(this.y1, this.y2);

        if ((x >= left) && (x <= right))
        {
            if ((y >= top) && (y <= bottom))
            {
                elem = this;
            }
        }

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            if ((this.stroke != null) && (this["stroke-width"] > 0))
            {
                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }

                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();

                if (container.isHitTesting)
                {
                    container.hitTestPath(ctx, this);
                }
            }
        }
    };

    this.getWidth = function ()
    {
        return Math.abs(this.x1 - this.x2);
    };

    this.getHeight = function ()
    {
        return Math.abs(this.y1 - this.y2);
    };
};

//---- inherit from canvasElement ----
vp.canvasLineElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasPathElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS PATH element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasPathElement ----
vp.canvasPathElement = function (parentElement)
{
    this.ctr = "vp.canvasPathElement";
    this.tagName = "rect";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
    this.dataStr = "";

    this.getOffset = function ()
    {
        return { x: this.boundingBox.x, y: this.boundingBox.y };
    };

    this.getBBox = function ()
    {
        return this.boundingBox;
    };

    this.drawPath = function (ctx)
    {
        //---- this is generated when the "d" property is assigned a value ----
    };

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
        var bb = this.boundingBox;
        var elem = null;

        if ((x >= bb.left) && (x <= bb.right))
        {
            if ((y >= bb.top) && (y <= bb.bottom))
            {
                elem = this;
            }
        }

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            ctx.beginPath();

            this.drawPath(ctx);        // run the dynamically generated function to draw the path

            if (this.fill != null)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }

                ctx.fill();
            }

            if ((this.stroke != null) && (this["stroke-width"] > 0))
            {

                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }

                ctx.stroke();
            }

            if (container.isHitTesting)
            {
                container.hitTestPath(ctx, this);
            }

            ctx.closePath();
        }
    }

    this.d = function (value)
    {
        if (arguments.length == 0)
        {
            return this.dataStr;
        }

        this.dataStr = value;
        this.parseDataStr();

        return this;
    };

    this.parseDataStr = function ()
    {
        var both = vp.parsePathDataAndGenerateDrawFunc(this.dataStr);

        var funcStr = both[0];
        this.boundingBox = both[1];

        //---- generate code for our function ----
        eval("this.drawPath = " + funcStr);
    };

    this.getWidth = function ()
    {
        return this.boundingBox.width;
    };

    this.getHeight = function ()
    {
        return this.boundingBox.height;
    };
};

//---- inherit from canvasElement ----
vp.canvasPathElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasPolygonElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS POLYGON element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasPolygonElement ----
vp.canvasPolygonElement = function (parentElement)
{
    this.ctr = "vp.canvasPolygonElement";
    this.tagName = "rect";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
    this.pointStr = "";

    this.getOffset = function ()
    {
        return { x: this.boundingBox.x, y: this.boundingBox.y };
    };

    this.getBBox = function ()
    {
        return this.boundingBox;
    };

    this.drawPath = function (ctx)
    {
        //---- this is generated when the "points" property is assigned a value ----
    };

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
        var bb = this.boundingBox;
        var elem = null;

        if ((x >= bb.left) && (x <= bb.right))
        {
            if ((y >= bb.top) && (y <= bb.bottom))
            {
                elem = this;
            }
        }

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            ctx.beginPath();

            this.drawPath(ctx);        // run the dynamically generated function to draw the path

            if (this.fill != null)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }

                ctx.fill();
            }

            if ((this.stroke != null) && (this["stroke-width"] > 0))
            {

                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }

                ctx.stroke();
            }

            if (container.isHitTesting)
            {
                container.hitTestPath(ctx, this);
            }

            ctx.closePath();
        }
    }

    this.points = function (value)
    {
        if (arguments.length == 0)
        {
            return this.pointStr;
        }

        this.pointStr = value;
        this.genDrawFromPoints();

        return this;
    };

    this.genDrawFromPoints = function ()
    {
        var funcStr = "function (ctx)\r\n"
               + "{\r\n";

        var minX = Number.MAX_VALUE;
        var minY = Number.MAX_VALUE;
        var maxX = -Number.MAX_VALUE;      // Number.MIN_VALUE;
        var maxY = -Number.MAX_VALUE;      // Number.MIN_VALUE;
        var firstPt = null;

        var points = this.pointStr.split(" ");

        for (var i = 0; i < points.length; i++)
        {
            var ptx = points[i];
            var xy = ptx.split(",");

            var pt = { x: +xy[0], y: +xy[1] };

            if (i == 0)
            {
                funcStr += "    ctx.moveTo(" + pt.x + "," + pt.y + ");\r\n";
            }
            else
            {
                funcStr += "    ctx.lineTo(" + pt.x + "," + pt.y + ");\r\n";
            }

            if (firstPt == null)
            {
                firstPt = pt;
            }

            minX = Math.min(minX, pt.x);
            minY = Math.min(minY, pt.y);

            maxX = Math.max(maxX, pt.x);
            maxY = Math.max(maxY, pt.y);
        }

        //---- generate line back to initial point ----
        if (firstPt)
        {
            funcStr += "    ctx.lineTo(" + firstPt.x + "," + firstPt.y + ");\r\n";
        }

        funcStr += "}\r\n";
        this.boundingBox = vp.rect(minX, minY, maxX - minX, maxY - minY);
   
        //---- generate code for our function ----
        eval("this.drawPath = " + funcStr);
    };

    this.getWidth = function ()
    {
        return this.boundingBox.width;
    };

    this.getHeight = function ()
    {
        return this.boundingBox.height;
    };
};

//---- inherit from canvasElement ----
vp.canvasPolygonElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasRectElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS RECT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasRectElement ----
vp.canvasRectElement = function (parentElement)
{
    this.ctr = "vp.canvasRectElement";
    this.tagName = "rect";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.strokePlacement = "straddle";        // "inside", "straddle", "outside"
    this["stroke-width"] = 0;

    this.getOffset = function ()
    {
        return { x: this.x, y: this.y };
    };

    this.getBBox = function ()
    {
        var x = (vp.isDefined(this.layoutX)) ? this.layoutX : this.x;
        var y = (vp.isDefined(this.layoutY)) ? this.layoutY : this.y;

        //---- return bounds as a vuePlot rect ----
        var rc = 
        {
            left: x, top: y, width: this.width, height: this.height,
            right: x + this.width, bottom: y + this.height
        };

        return rc;
    };

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
        var elem = null;

        var myx = (vp.isDefined(this.layoutX)) ? this.layoutX : this.x;
        var myy = (vp.isDefined(this.layoutY)) ? this.layoutY : this.y;

        if ((x >= myx) && (x <= myx + this.width))
        {
            if ((y >= myy) && (y <= myy + this.height))
            {
                elem = this;
            }
        }

        return elem;
    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            if (this.fill != null)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }

                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            if ((this.stroke != null) && (this["stroke-width"] > 0))
            {

                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                var sw = this["stroke-width"];
                if (container.currentStrokeWidth != sw)
                {
                    ctx.lineWidth = sw;
                    container.currentStrokeWidth = sw;
                }

                if (this.strokePlacement == "inside")
                {
                    var sw_div2 = this["stroke-width"] / 2;
                    ctx.strokeRect(this.x + sw_div2, this.y + sw_div2, this.width - sw, this.height - sw);
                }
                else if (this.strokePlacement == "outside")
                {
                    var sw_div2 = this["stroke-width"] / 2;
                    ctx.strokeRect(this.x - sw_div2, this.y - sw_div2, this.width + sw, this.height + sw);
                }
                else    // "straddle"
                {
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
            }

            if (container.isHitTesting)
            {
                ctx.save();

                //---- create a rect path ----
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.width, this.height);

                container.hitTestPath(ctx, this);

                ctx.restore();
            }
        }
    }

    this.getWidth = function ()
    {
        return this.width;
    };

    this.getHeight = function ()
    {
        return this.height;
    };
};

//---- inherit from canvasElement ----
vp.canvasRectElement.prototype = new vp.canvasElement();

﻿///-----------------------------------------------------------------------------------------------------------------
/// canvasTextElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS TEXT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasTextElement ----
vp.canvasTextElement = function (parentElement)
{
    this.ctr = "vp.canvasTextElement";
    this.tagName = "text";
    this.textContent = "";
    this.parentElement = parentElement;
    this.rootContainer = this.getRoot(parentElement);
    this.parentNode = this.rootContainer.canvas;
    this.opacity = 1;
    this.x = 0;
    this.y = 0;

    /// return elem found at x,y.
    this.hitTest = function (x, y)
    {
        //---- for text; just treat as rect.  see if point is between left/right and top/bottom ----
        var elem = null;

        if ((x >= this.x) && (x <= this.x + this.width))
        {
            if ((y >= this.y) && (y <= this.y + this.height))
            {
                elem = this;
            }
        }

        return elem;
    };

    this.getOffset = function ()
    {
        var left = this.x;
        var top = this.y;

        //---- elem.y specifies the bottom for text elements, so substract the height to get the top ----
        top -= this.getHeight();

        return { x: left, y: top };
    };

    this.setContextForDrawing = function (ctx, container)
    {
        var font = "";
        if (this["font-size"] != undefined)
        {
            var fs = this["font-size"];
            if (vp.isNumber(fs))  // false)
            {
                //---- just using a number gives inconsistent results between SVG and Canvas; so force a default unit ----
                font += fs + "pt ";
            }
            else
            {
                font += fs;
            }
        }
        if (this["font-family"])
        {
            font += " " + this["font-family"];
        }
        else
        {
            font += " tahoma";
        }

        if (this.fontWeight != undefined)
        {
            font += " " + this.fontWeight;
        }
        if (this.fontStyle != undefined)
        {
            font += " " + this.fontStyle;
        }

        ctx.font = font;

        if (this.fill != null)
        {
            if (container)
            {
                if (container.currentFill != this.fill)
                {
                    ctx.fillStyle = this.fill;
                    container.currentFill = this.fill;
                }
            }
        }

        if (this.stroke != null)
        {
            if (container)
            {
                if (container.currentStroke != this.stroke)
                {
                    ctx.strokeStyle = this.stroke;
                    container.currentStroke = this.stroke;
                }

                if (container.currentStrokeWidth != this["stroke-width"])
                {
                    ctx.lineWidth = this["stroke-width"];
                    container.currentStrokeWidth = this["stroke-width"];
                }
            }
        }

        if (this.textAlign)
        {
            ctx.textAlign = this.textAlign;
        }

        if (this.verticalAlign)
        {
            ctx.textBaseline = this.verticalAlign;
        }

    };

    this.drawAll = function (ctx, container)
    {
        if (this.visibility != "hidden")
        {
            ctx.globalAlpha = this.opacity;

            this.setContextForDrawing(ctx, container);

            //---- apply alignment ----
            var x = +this.x;

            switch (this.textAlign)
            {
                case "center":
                    x += this.width / 2;
                    break;

                case "right":
                    x += this.width;
                    break;
            }

            var y = +this.y;

            switch (this.verticalAlign)
            {
                case "middle":
                    y += this.height / 2;
                    break;

                case "bottom":
                    y += this.height;
                    break;
            }

            if (this.fill != null)
            {
                ctx.fillText(this.textContent, x, y);
            }

            if (this.stroke != null)
            {
                ctx.strokeText(this.textContent, x, y);
            }

            if (container.isHitTesting)
            {
                ctx.save();

                //---- create a rect path to represent the text block (any other way to do this?) ----
                ctx.beginPath();

                var width = ctx.measureText(this.textContent).width;
                var height = this.getHeight();

                ctx.rect(this.x, this.y, width, height);

                container.hitTestPath(ctx, this);

                ctx.restore();
            }
        }
    };

    this.getBBox = function ()
    {
        var x = (vp.isDefined(this.layoutX)) ? this.layoutX : this.x;
        var y = (vp.isDefined(this.layoutY)) ? this.layoutY : this.y;

        var w = this.getWidth();
        var h = this.getHeight();

        //---- return bounds as a vuePlot rect ----
        var rc =
        {
            left: x, top: y, width: w, height: h,
            right: x + w, bottom: y + h
        };

        return rc;
    };

    this.getWidth = function ()
    {
        var width = 0;

        if (this.rootContainer.glHelper == null)
        {
            var ctx = this.rootContainer.ctx;
            this.setContextForDrawing(ctx);
            width = ctx.measureText(this.textContent).width;
        }

        return width;
    };

    this.getHeight = function ()
    {
        var height = 0;

        if (this.rootContainer.glHelper == null)
        {
            //---- note: ctx.measureText() doesn't support height; parse it from ctx.font ----
            //---- since the font size is the height of characters rendered by that font ----
            var ctx = this.rootContainer.ctx;
            this.setContextForDrawing(ctx);

            var fontStr = ctx.font;
            height = parseFloat(fontStr);      // starts with "10px" ...
            if (fontStr.contains("pt "))
            {
                height = height * 98 / 72;
            }

        }

        return height;
    };
};

//---- inherit from canvasElement ----
vp.canvasTextElement.prototype = new vp.canvasElement();
﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildBottomAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a bottom axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildBottomAxis = function (group, width, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, labelFit, drawTicksOnInside)
{
    group.clear();

    var yoff = 0;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var tickLength = daBlock.tick.length;
    var xMax = width - 1;
    var labelRotation = 0;
    var showLabels = true;
    var showTicks = true;
    var halign = "center";
    var xtweak = 0;

    var labelCount = labels.length;
    var adjWidth = .9 * width;
    var maxLabelWidth = szText.width;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)
    var truncateLabels = false;
    var rotate = null;

    if (labelCount * maxLabelWidth > adjWidth)
    {
        //---- all labels don't fit the space ----
        if (labelFit == LabelFit.skip)          
        {
            //---- SKIP labelFit ----
            var groupCount = adjWidth / maxLabelWidth;
            perGroupCount = Math.ceil(labelCount / groupCount);
        }
        else if (labelFit == LabelFit.truncate)
        {
            //---- TRUNCATE labelFit ----
            truncateLabels = true;
        }
        else if (labelFit == LabelFit.rotate45)
        {
            //---- ROTATE 45 ----
            rotate = 45;
        }
        else if (labelFit == LabelFit.rotate90)
        {
            //---- ROTATE 90 ----
            rotate = 90;
        }
        else if (labelFit == LabelFit.rotateAuto)
        {
            //---- AUTO ROTATE ----
            rotate = "auto";
        }
        else if (labelFit == LabelFit.hideAll)
        {
            //---- HIDE ALL ----
            showLabels = false;

            if ((autoHideTicks) && (labelCount > .15 * width))
            {
                showTicks = false;
            }
        }
    }

    if (group.firstPassResults)
    {
        showLabels = group.firstPassResults.showLabels;
        showTicks = group.firstPassResults.showTicks;
        rotate = group.firstPassResults.labelRotation;
    }

    if (rotate)
    {
        //---- try to make room for labels, if needed ----
        var labelCount = labels.length;
        if (labelCount * szText.height > width)
        {
            showLabels = false;
        }
        else if ((rotate == 90) || ((rotate == "auto") && (labelCount * szText.height * 1.3 > width)))
        {
            labelRotation = 90;
            halign = "left";
        }
        else if ((rotate == 45) || ((rotate == "auto") && (labelCount * szText.width > width)))
        {
            labelRotation = 45;
            halign = "left";
            xtweak = szText.height / 2;
        }
    }

    //---- axis line ----
    vp.drawHLine(group, daBlock.axis, 0, xMax, yoff, "vpAxisLine");

    if (showTicks)
    {
        var skipCount = 0;

        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);

            var daTick = daBlock.tick;

            if ((skipCount > 1) || ((skipCount == 1) && (!isCategory)))
            {
                if (daBlock.skipTick)
                {
                    daTick = daBlock.skipTick;
                }
            }

            var myTickLength = daTick.length + 1;

            if (drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            vp.drawVLine(group, daTick, yoff, yoff + myTickLength + 1, x, "vpTickMark");

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    if (showTicks && (!drawTicksOnInside))
    {
        yoff += (tickLength + tickLabelSpace);
    }
    else
    {
        yoff += tickLabelSpace + 2;
    }

    //---- tick labels ----
    var lastOffset = null;
    var labelIndex = 0;

    if (showLabels)
    {
        var skipCount = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);

            if (isCategory)
            {
                var offset = x;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                x = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            //var textWidth = szText.width;
            //var textHeight = szText.height;

            //var actualX = x - (textWidth / 2) + xtweak;
            var label = labels[labelIndex++];

            if (skipCount == 0)
            {
                if (label != "")
                {
                    daBlock.label.textLabel = (label.label) ? label.label : label;

                    var yStart = yoff + 5;
                    var xStart = x + xtweak;

                    if (labelRotation == 90)
                    {
                        xStart += 2;
                        yStart -= 8;
                    }
                    else if (labelRotation == 45)
                    {
                        xStart -= 10;
                        yStart -= 7;
                    }

                    vp.drawText(group, daBlock.label, xStart, yStart, null, null, halign, "center", labelRotation,
                        0, .5);

                    if (truncateLabels)
                    {
                        //---- add tooltip for full label name ----
                        var fullLabel = (label.fullLabel) ? label.fullLabel : label;
                        vp.textElemJustDraw.title(fullLabel);
                    }
                }
            }

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    if (showLabels)
    {
        if (labelRotation == 90)
        {
            yoff += (szText.width - 1);
        }
        else if (labelRotation == 45)
        {
            var rotateHeight = szText.width * Math.sin(45 * Math.PI / 180);
            yoff += (rotateHeight + 4);
        }
        else
        {
            yoff += (5 + szText.height / 2);      // height/2 since we draw text with vertical centering
        }
    }

    //---- axis title ----
    if (name)
    {
        var aoff = (labelRotation) ? 30 : 15;
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        //var sz = vp.drawText(group, daBlock.title, 0, yoff + aoff, width, null, "center", "center", 0);
        //yoff += (sz.height + aoff);
        var sz = vp.drawText(group, daBlock.title, left, yoff + top, width, null, "center", "center", 0);
        yoff += (sz.height + top + bottom);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.title(elem, "The X-axis represents the data column: " + name);
        elem.id = "xAxis";

        yoff -= 20;         // tighten up the white space
    }
    else
    {
        //---- add some white space so its not too crowded ----
        yoff -= 10;         // tighten up the white space
    }

    group.desiredWidth = width;
    group.desiredHeight = yoff;
    group.firstPassResults = { showLabels: showLabels, showTicks: showTicks, labelRotation: labelRotation };

    return group;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildLeftAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a left axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildLeftAxis = function (group, height, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, drawTicksOnInside)
{
    group.clear();

    var xoff = 0;
    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var yMax = height - 1;
    var showLabels = true;
    var showTicks = true;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)

    var labelCount = labels.length;
    var adjHeight = .9 * height;
    var maxLabelHeight = szText.height;

    if (maxLabelHeight > adjHeight)
    {
        //---- not room for even a single label - always hide ----
        showLabels = false;
    }
    else if (labelCount * maxLabelHeight > adjHeight)
    {
        //---- all labels don't fit the space ----
        if (autoHideLabels)
        {
            showLabels = false;

            if ((autoHideTicks) && (labelCount > .15 * height))
            {
                showTicks = false;
            }
        }
        else
        {
            var groupCount = adjHeight / maxLabelHeight;
            perGroupCount = Math.ceil(labelCount / groupCount);
        }
    }

    //---- axis title ----
    if (name)
    {
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        var sz = vp.drawText(group, daBlock.title, xoff + left, yoff + top, null, height, "center", "center", 270);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.title(elem, "The Y-axis represents the data column: " + name);
        elem.id = "yAxis";

        xoff += (left + right + sz.height);       // sz.height is the width of the text after rotation
    }

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var textWidth = szText.width;
        var textHeight = szText.height;
        var labelIndex = 0;
        var skipCount = 0;

        for (var i = 0; i < tickOffsets.length; i++)
    {
            var y = Math.round(tickOffsets[i]);

            if (isCategory)
            {
                var offset = y;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                y = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            if (skipCount == 0)
            {
                var label = labels[labelIndex];
                daBlock.label.textLabel = label;

                var yy = yoff + (height - y) + 3;
                vp.drawText(group, daBlock.label, xoff, yy, textWidth, null, "right", "center");
            }

            labelIndex++;

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    xoff += (szText.width + tickLabelSpace);
    xoff += tickLength;

    if (showTicks)
    {
        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var y = Math.round(tickOffsets[i]);

            var daTick = daBlock.tick;      // (skipCount > 0 && daBlock.skipTick) ? daBlock.skipTick : daBlock.tick;
            var myTickLength = daTick.length;
            var yy = yoff + (height - y);

            if (! drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            //---- don't draw ticks very near top/bottom on inside (hard to align correctly due to antialiasing) ----
            var nearTop = (Math.abs(yy - 0) < 2);
            var nearBottom = (Math.abs(yy - height) < 2);

            if ((drawTicksOnInside) && (nearTop || nearBottom))
            {
                //---- don't draw this tick ----
            }
            else
            {
                vp.drawHLine(group, daTick, xoff, xoff + myTickLength, yy);
            }
        }
    }

    //---- axis line ----
    vp.drawVLine(group, daBlock.axis, yoff, yoff + yMax, xoff);

    group.desiredWidth = xoff;
    group.desiredHeight = height;

    return group;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildLegend.js.  Copyright (c) 2012 Microsoft Corporation.
///     - a set of flat helper functions for building a set of legends.
///-----------------------------------------------------------------------------------------------------------------
vp.buildLegend = function (parentGroup, attributes, daBlock, primaryLayer, seriesCount)
{
    var group = parentGroup.append("g");
    var dw = 0;
    var dh = 0;

    var left = daBlock.box.left;
    var top = daBlock.box.top;
    var right = daBlock.box.right;
    var bottom = daBlock.box.bottom;

    for (var i = 0; i < attributes.length; i++)
    {
        var attribute = attributes[i];
        var scale = attribute.scale();

        //---- ensure this attribute is mapped to a column ----
        if ((!attribute.isMapped()) || (! attribute.isLegendVisible()))
        {
            continue;
        }

        if (scale.scaleType == "size")
        {
            continue;       // not yet supported
        }

        var scaleOrPalette = (scale.scaleType == "color") ? scale : null;
        var name = attribute.title();
        var breaks = attribute.getActualBreaks();
        var labels = attribute.getActualLabels(breaks);
        var singleGroup = null;
        var isContinuousPalette = (!attribute.isDiscrete());

        if (scaleOrPalette)
        {
            if (isContinuousPalette)
            {
                singleGroup = vp.buildContinuousLegend(group, primaryLayer, left, top, daBlock, attribute, scaleOrPalette, name, breaks, labels);
            }
            else
            {
                singleGroup = vp.buildDiscreteLegend(group, primaryLayer, left, top, daBlock, attribute, scaleOrPalette, name, breaks, labels);
            }

            dw = Math.max(dw, (singleGroup.desiredWidth + left + right));
            dh += singleGroup.desiredHeight + top + bottom;
        }
    }

    group.desiredWidth = dw;
    group.desiredHeight = dh;

    return group;

};

//---- build svg RECT with gradient matching "palette" (with last color in palette at top) ----
vp.buildSvgGradient = function (svgParent, defName, palette, drawBorder, flipColors, x, y, width, height)
{
    var defs = svgParent.append("defs");

    var gradient = defs.append("linearGradient")
        .attr("id", defName)
        .from("0%", "0%")
        .to("0%", "100%")

    var len = palette.length;

    //---- add a stop for each color in the palette ----
    for (var i = 0; i < len; i++)
    {
        var cr = (flipColors) ? palette[i] : palette[len - (i+1)];
        var color = vp.colorHelper.toColor(cr);

        var percent = (len == 1) ? 0 : (100 * i / (len - 1));

        gradient
            .addStop(percent + "%", color)
    }

    var rect = svgParent.append("rect")
        .bounds(x, y, width, height)
        .attr("fill", "url(#" + defName + ")");

    if (drawBorder)
    {
        rect
            .attr("stroke", "#333")
            .attr("stroke-width", "1")
    }

    return rect;
}

vp.addNameToLegend = function(group, daBlock, leftBase, dw, dh, name)
{
    daBlock.title.textLabel = name;

    var left = daBlock.title.left;
    var top = daBlock.title.top;
    var right = daBlock.title.right;
    var bottom = daBlock.title.bottom;

    var sz = vp.drawText(group, daBlock.title, leftBase + left, dh + top, null, null, "left", "center");

    dh += sz.height + (top + bottom);
    dw = Math.max(dw, (left + right + sz.width));

    return { dh: dh, dw: dw };
}

vp.buildDiscreteLegend = function (parentGroup, primaryLayer, xLoc, yLoc, daBlock, colorAttr, colorScale, name, breaks, labels)
{
    var group = parentGroup.append("g");

    var cr = "black";          // default color
    var dw = 0;
    var dh = yLoc;
    var xoff = xLoc;

    var daBox = daBlock.box;
    var box = null;

    if ((daBox.fill != "transparent") || ((daBox.lineSize) && (daBox.stroke != "transparent")))
    {
        box = vp.drawBox(group, daBox, 0, 0, 100, 100);       // we will resize at end of this function
        dh += 10;
        xoff += 10;
    }

    if (name)
    {
        var leftBase = dw;

        if ((!vp.isString(name)) && vp.isArray(name))
        {
            //---- do each name in array ----
            for (var i = 0; i < name.length; i++)
            {
                if (i > 0)
                {
                    dh += 4;        // a little extra spacing between multiple legend names
                }

                var thisName = name[i];
                var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, thisName);

                dh = dd.dh;
                dw = dd.dw;
            }
        }
        else
        {
            var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, name);

            dh = dd.dh;
            dw = dd.dw;
        }
    }

    var colorBoxesHeight = 0;
    var colorBoxesTop = dh;

    var flipIt = colorAttr.flipInLegend();

    //---- draw color boxes ----
    var lastBreak = breaks.length - 1;      // extra tick 

    for (var i = 0; i < lastBreak; i++)
    {
        var index = (flipIt) ? ((lastBreak - 1) - i) : i;

        var breakValue = index;     // discrete scale wants index

        if (colorScale)
        {
            if (vp.isArray(colorScale))
            {
                //var index = (flipIt) ? (breaks.length - 1) - i : 0;
                cr = vp.colorFromPalette(colorScale, index);
            }
            else
            {
                cr = colorScale.scale(breakValue);
            }
        }

        //---- shape ----
        var sw = daBlock.key.shapeWidth;
        var sh = daBlock.key.shapeHeight;

        var rect = group.append("rect")
            .bounds(xoff, dh + .5, sw, sh)

        daBlock.key.fill = cr;
        vp.applyShapeAttributes(rect, daBlock.key);

        //---- tick mark ----
        //vp.drawHLine(group, daBlock.tick, sw, sw + 5, dh);

        ////---- text ----
        //var str = "";
        //if (labels)
        //{
        //    str = labels[i];
        //}

        //var xx = sw + 4;    //8;
        //daBlock.keyText.textLabel = str;

        //var sz = vp.drawText(group, daBlock.keyText, xx, 2 + dh + sh, null, null, "left", "top");

        //dw = Math.max(dw, sz.width + xx);

        dh += sh;   //(sh + daBlock.key.lineSize);       //Math.max(sh, sz.height);
        colorBoxesHeight += sh;
    }

    var boxPlusWidth = daBlock.key.shapeWidth;

    //---- draw ticks and labels to right of color boxes ----
    var rightAxis = vp.createRightAxisForLegend(primaryLayer, colorAttr, colorScale, colorBoxesHeight-1, flipIt);

    var rightAxisWidth = rightAxis.getWidth(group, 100, colorBoxesHeight);
    rightAxis.draw(group, boxPlusWidth, colorBoxesTop+.5, rightAxisWidth, colorBoxesHeight-1, true);

    dw = Math.max(dw, boxPlusWidth + rightAxisWidth);

    var boxWidth = dw + 8;
    var boxHeight = dh + sh;

    group.desiredWidth = (box) ? dw : (dw - 10);
    group.desiredHeight = (box) ? boxHeight : (dh + sh - 16);

    if (box)
    {
        box
            .attr("width", boxWidth)
            .attr("height", boxHeight);
    }

    return group;
};

vp.createRightAxisForLegend = function (primaryLayer, colorAttr, colorScale, gradientHeight, flipIt)
{
    //---- create an attribute/scale pair to draw color axis with ----
    var tickCount = 4;
    var min = colorScale.domainMin();
    var max = colorScale.domainMax();

    var useNiceNums = ((!colorAttr.isDiscrete()) && (colorAttr.colName() != "_seriesIndex"));
    var palette = null;

    if (flipIt)
    {
        palette = [0, gradientHeight];
    }
    else
    {
        palette = [gradientHeight, 0];
    }

    //---- setup scale ----
    var axisScale = vp.scales.createSpace()
        .autoRange(false)

    var axisAttr = vp.scales.createAttribute("legendFill", axisScale)
        .tickCount(tickCount)
        .useNiceNumbers(useNiceNums)
        .colName(colorAttr.colName())
        .colData(colorAttr.colData())
        .isDiscrete(colorAttr.isDiscrete())
        .domainMin(min)
        .domainMax(max)
        .tickCount(tickCount)
        .labels(colorAttr.breaks())
        .labels(colorAttr.labels())
        .palette(palette)

    primaryLayer.prepAttrScaleIfNeeded(axisAttr, primaryLayer.info.seriesNames);

    //---- create the RIGHT AXIS ----
    var rightAxis = vp.visuals.svgAxis()
        .attribute(axisAttr)
        .axisLocation("right")
        .isLabelVisible(false)
        .daName("legendAxis")

    return rightAxis;
}

vp.legendId = 1;

vp.buildContinuousLegend = function (parentGroup, primaryLayer, xLoc, yLoc, daBlock, colorAttr, colorScale, name, breaks,
    labels)
{
    var group = parentGroup.append("g");

    var cr = "black";          // default color
    var xoff = xLoc;
    var yoff = yLoc;
    var daBox = daBlock.box;
    var box = null;

    if ((daBox.fill != "transparent") || ((daBox.lineSize) && (daBox.stroke != "transparent")))
    {
        box = vp.drawBox(group, daBox, xoff, yoff, 100, 100);       // we will resize at end of this function
        yoff += 10;
        xoff += 10;
    }

    if (name)
    {
        daBlock.title.textLabel = name;

        var sz = vp.drawText(group, daBlock.title, xoff, yoff, null, null, "left", "center");

        yoff += sz.height + 0;
    }

    //---- draw gradient for colors ----
    var gradientWidth = 20;
    var gradientHeight = 120;

    var palette = colorScale.palette();
    var uniqueName = "legendGradient_" + vp.legendId++;
    var flipColors = (!colorAttr.flipInLegend());      // logic is backwards

    vp.buildSvgGradient(group, uniqueName, palette, true, flipColors, xoff, yoff + .5, gradientWidth, gradientHeight);
    xoff += (gradientWidth + 1);

    //---- draw ticks and labels to right of gradient ----
    var rightAxis = vp.createRightAxisForLegend(primaryLayer, colorAttr, colorScale, gradientHeight);

    var rightAxisWidth = rightAxis.getWidth(group, 100, gradientHeight);
    rightAxis.draw(group, xoff, yoff, rightAxisWidth, gradientHeight, true);

    var groupWidth = gradientWidth + rightAxisWidth - 10;       // 10 is fudgeFactor
    var groupHeight = yoff + gradientHeight;

    if (box)
    {
        groupWidth += 10;
        groupHeight += 10;

        var boxWidth = groupWidth + 8;
        var boxHeight = groupHeight + 8;

        box
            .attr("width", boxWidth)
            .attr("height", boxHeight);
    }

    group.desiredWidth = groupWidth;
    group.desiredHeight = groupHeight;

    return group;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildRightAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a left axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildRightAxis = function (group, height, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, boxOnly, drawTicksOnInside)
{
    group.clear();

    var xoff = 0;
    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var yMax = height - 1;
    var showLabels = true;
    var showTicks = true;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)

    var labelCount = labels.length;
    var adjHeight = .9 * height;
    var maxLabelHeight = szText.height;

    if (boxOnly)
    {
        showLabels = false;
        name = null;
    }
    else
    {
        if (labelCount * maxLabelHeight > adjHeight)
        {
            //---- all labels don't fit the space ----
            if (autoHideLabels)
            {
                showLabels = false;

                if ((autoHideTicks) && (labelCount > .15 * height))
                {
                    showTicks = false;
                }
            }
            else
            {
                var groupCount = adjHeight / maxLabelHeight;
                perGroupCount = Math.ceil(labelCount / groupCount);
            }
        }
    }

    //---- axis line ----
    vp.drawVLine(group, daBlock.axis, yoff, yoff + yMax, xoff);

    if (showTicks)
    {
        //---- tick marks ----
        var skipCount = 0;

        if (myTickLength)
        {
            xoff += 2;
        }

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var y = Math.round(tickOffsets[i]);

            var daTick = (skipCount > 0 && daBlock.skipTick) ? daBlock.skipTick : daBlock.tick;
            var myTickLength = daTick.length;

            if (drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            //---- don't draw ticks very near top/bottom on inside (hard to align correctly due to antialiasing) ----
            var yy = yoff + (height - y);

            var nearTop = (Math.abs(yy - 0) < 2);
            var nearBottom = (Math.abs(yy - height) < 2);

            if ((drawTicksOnInside) && (nearTop || nearBottom))
            {
                //---- don't draw this tick ----
            }
            else
            {
                vp.drawHLine(group, daTick, xoff, xoff + myTickLength, yy);
            }

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    xoff += tickLength + tickLabelSpace;

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var textWidth = szText.width;
        var textHeight = szText.height;
        var labelIndex = 0;
        var skipCount = 0;
        var maxTextWidth = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            if (skipCount == 0)
            {
                var y = Math.round(tickOffsets[i]);

                if (isCategory)
                {
                    var offset = y;

                    if (lastOffset == null)
                    {
                        lastOffset = offset;
                        continue;
                    }

                    y = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                    lastOffset = offset;
                }

                var label = labels[labelIndex];
                daBlock.label.textLabel = label;

                var sz = vp.drawText(group, daBlock.label, xoff, yoff + (height - y) + 3,
                    textWidth, null, "left", "center");

                var tw = sz.width;      // width of text just drawn
                if (tw > maxTextWidth)
                {
                    maxTextWidth = tw;
                }
            }

            labelIndex++;

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }

        //xoff += (szText.width + tickLabelSpace);
        xoff += maxTextWidth;
    }

    //---- axis title ----
    if (name)
    {
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        xoff += tickLabelSpace + 6;

        //---- uses a coulple of fudge factors ----
        //sz = vp.drawText(group, daBlock.title, xoff - 5, yoff + 3, null, height, "left", "center", 90);
        var sz = vp.drawText(group, daBlock.title, xoff + left, yoff + 3 + top, null,
            height, "center", "center", 270);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.title(elem, "The Y-axis represents the data column: " + name);
        elem.id = "yAxis";

        xoff += (left + right + sz.height);       // sz.height is width of rotated text
    }

    group.desiredWidth = xoff;
    group.desiredHeight = height;

    return group;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildTopAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a bottom axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildTopAxis = function (group, width, tickOffsets, labels, szText, isCategory, name, isNameRotated, daBlock, ticksOnly, drawTicksOnInside)
{
    group.clear();

    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var xMax = width - 1;
    var showLabels = true;
    var showTicks = true;

    if (ticksOnly)
    {
        showLabels = false;
        name = null;
    }
    else
    {
        var labelCount = labels.length;
        if (labelCount * szText.width > 1.3 * width)
        {
            showLabels = false;

            if (labelCount > .15 * width)
            {
                showTicks = false;
            }
        }
    }

    //---- axis title ----
    if (name)
    {
        sz = vp.drawText(group, daBlock.title, 0, yoff, width, null, name, "vpAxisLabel", "center", "center", 0);
        yoff += sz.width + 10;
    }

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var labelIndex = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);      

            if (isCategory)
            {
                var offset = x;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                x = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            var textWidth = szText.width;
            var textHeight = szText.height;

            var actualX = x - textWidth / 2;
            var label = labels[labelIndex++];

            vp.drawText(group, daBlock.label, actualX, yoff, textWidth, textHeight, label, "vpTickLabel", "center", "center");
        }

        yoff += (szText.height + tickLabelSpace);
    }

    yoff += tickLength;

    if (showTicks)
    {
        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);
            var myTickLength = tickLength + 1;

            if (!drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            vp.drawVLine(group, daBlock.tick, yoff, yoff + myTickLength, x, "vpTickMark");
        }
    }


    //---- axis line ----
    vp.drawHLine(group, daBlock.axis, 0, xMax, yoff, "vpAxisLine");

    group.desiredWidth = width;
    group.desiredHeight = yoff;

    return group;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/chartFrame.js.  Copyright (c) 2012 Microsoft Corporation.
///     - draws the chart frame (title, axes, legend, grid).
///-----------------------------------------------------------------------------------------------------------------
vp.chartFrameClass = function ()
{
    //---- state variables ----
    var cfGroup;        // the root "g" for the chart frame
    var bgGroup;        // the plotarea background group
    var glGroup;        // the gridlines group
    var title;          // the text of the chart title
    var titleSize;      // the font size of the title (in points)
    var showXGridLines;
    var showYGridLines;
    var gridLineType = undefined;
    var isLegendVisible;
    var showLeftAxis;
    var showTopAxis;
    var showRightAxis;
    var showBottomAxis;
    var showLeftLabel;
    var showTopLabel;
    var showRightLabel;
    var showBottomLabel;
    var showBoxTicks;       // show ticks only for upper and right axes
    var xAttribute; 
    var yAttribute;
    var fillScale;
    var xData;
    var yData;
    var fillData;
    var plotAreaRect = null;
    var attributes = null;
    var xLabelFit = null;
    var drawTicksOnInside = false;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.chartFrame";

    var init = function ()
    {
    }

    closure.gridLinesGroup = function ()
    {
        return glGroup;
    }

    closure.plotAreaBounds = function ()
    {
        return plotAreaRect;
    };

    closure.build = function (root, frameMargins, borderSize, primaryLayer, seriesCount)
    {
        //buildScales();

        var x = 0;
        var y = 0;

        var w = root.width();
        var h = root.height();

        var info = primaryLayer.info;

        //---- why is this needed to get margins equal? ----
        x -= 1;
    
        //if (showBoxTicks)
        //{
        //    showRightAxis = true;
        //    showTopAxis = true;
        //}

        var showRight = (showRightAxis || showBoxTicks);
        var showTop = (showTopAxis || showBoxTicks);

        cfGroup = root.append("g")
            .id("chartFrame")

        //---- create now so that bg & grid lines are drawn first, even though we compute their positions last ----
        bgGroup = cfGroup.append("g")
        glGroup = cfGroup.append("g")

        //---- first, apply frame margins ----
        if (frameMargins)
        {
            x += frameMargins.left;
            y += frameMargins.top;

            w -= (frameMargins.left + frameMargins.right);
            h -= (frameMargins.top + frameMargins.bottom);
        }

        var szText = null;

        //---- draw title at top ----
        if (title)
        {
            //---- get THEME drawing attributes for TITLE ----
            var da = vp.currentTheme().getDrawingAttributes("chartFrame.title");
            da.textLabel = title;
            da.id = "title";

            if (titleSize !== undefined)
            {
                da.textSize = titleSize;
            }

            //---- use left/top/right/bottom margins from "da" ----
            var tw = w - (da.left + da.right);
            var xoff = x + da.left;

            //---- DRAW TITLE ----
            szText = vp.drawText(cfGroup, da, xoff, y + da.top, tw, null, "center", "bottom");

            var yoff = szText.height + da.top + da.bottom;
            h -= yoff;
            y += yoff;
        }

        //---- draw legend on right ----
        var legendHeight = 0;
        var legendLeft = 0;
        var legendGroup = null;

        if (isLegendVisible)
        {
            if ((seriesCount > 1) || ((attributes) && (attributes.length)))
            {
                //---- get THEME drawing attributes for LEGEND ----
                var legendTitle = vp.currentTheme().getDrawingAttributes("legend.title");
                var key = vp.currentTheme().getDrawingAttributes("legend.key");
                var keyText = vp.currentTheme().getDrawingAttributes("legend.keyText");
                var box = vp.currentTheme().getDrawingAttributes("legend.box");
                var tick = vp.currentTheme().getDrawingAttributes("legend.tick");

                var daBlock = { title: legendTitle, key: key, keyText: keyText, box: box, tick: tick };

                legendGroup = vp.buildLegend(cfGroup, attributes, daBlock, primaryLayer, seriesCount);

                legendLeft = (x + w + 16) - legendGroup.desiredWidth;
                legendHeight = legendGroup.desiredHeight;

                w -= (legendGroup.desiredWidth - 4);
            }
        }

        //---- figure out width/height of plot area, based on presence of 4 axes ----
        var leftWidth = 0;          // width of left axis
        var rightWidth = 0;
        var topHeight = 0;
        var bottomHeight = 0;

        //---- FIRST CALC WIDTHS ----

        //--- always create LEFT axis (but don't always show it) ----
        var leftAxis = vp.visuals.svgAxis()
            .attribute(yAttribute)
            .isLabelVisible(showLeftLabel)
            .daName("yaxis")

        leftWidth = leftAxis.getWidth(cfGroup, w, h, info, showLeftAxis, false, drawTicksOnInside);

        if (!showLeftAxis)
        {
            leftAxis.isAxisVisible(false);
            leftWidth = 0;
        }

        if (showRight)
        {
            var rightAxis = vp.visuals.svgAxis()
                .attribute(yAttribute)
                .axisLocation("right")
                .isLabelVisible(showRightLabel)
                .daName("yaxis")

            rightWidth = rightAxis.getWidth(cfGroup, w, h, info, showRight, showBoxTicks, drawTicksOnInside);
        }

        //---- hide non-plot stuff if plot is too small ----
        var minPlotSize = 10;
        var ww = w - (leftWidth + rightWidth);

        if ((ww < minPlotSize) && (legendGroup))
        {
            //---- hide legend ----
            w += (legendGroup.desiredWidth - 4);
            ww += (legendGroup.desiredWidth - 4);

            legendGroup.remove();           // remove from parent
            legendGroup = null;
        }

        if ((ww < minPlotSize) && (rightAxis))
        {
            //---- hide right axis ----
            rightAxis.isAxisVisible(false);
            ww += rightWidth;
            rightWidth = 0;
        }

        if ((ww < minPlotSize) && (leftAxis.isAxisVisible()))
        {
            //---- hide left axis ----
            leftAxis.isAxisVisible(false);
            ww += leftWidth;
            leftWidth = 0;
        }

        //---- now cacl final width ----
        w -= (leftWidth + rightWidth);

        //---- NOW CALC HEIGHTS ----

        //--- always create BOTTOM axis (but don't always show it) ----
        var bottomAxis = vp.visuals.svgAxis()
           .attribute(xAttribute)
           .axisLocation("bottom")
           .isLabelVisible(showBottomLabel)
           .daName("xaxis")
           .labelFit(xLabelFit)

        bottomHeight = bottomAxis.getHeight(cfGroup, w, h, info, showBottomAxis, false, drawTicksOnInside);

        if (!showBottomAxis)
        {
            bottomAxis.isAxisVisible(false);
            bottomHeight = 0;
        }

        if (showTop)
        {
            var topAxis = vp.visuals.svgAxis()
               .attribute(xAttribute)
               .axisLocation("top")
               .isLabelVisible(showTopLabel)
               .daName("xaxis")

            topHeight = topAxis.getHeight(cfGroup, w, h, info, showTop, showBoxTicks, drawTicksOnInside);
        }

        var hh = h - (topHeight + bottomHeight);
        if ((hh < minPlotSize) && (topAxis))
        {
            //---- hide top axis ----
            topAxis.isAxisVisible(false);
            hh += topHeight;
            topHeight = 0;
        }

        if ((hh < minPlotSize) && (bottomAxis))
        {
            //---- hide bottom axis ----
            bottomAxis.isAxisVisible(false);
            hh += bottomHeight;
            bottomHeight = 0;
        }

        //---- now we can draw all axes ----
        var sideHeight = h - topHeight - bottomHeight;
        //var topBotWidth = w;        // - leftWidth - rightWidth;

        if (topAxis)
        {
            topAxis.draw(cfGroup, x + leftWidth, y, w, topHeight, info, showTop, showBoxTicks, drawTicksOnInside);
        }

        if (bottomAxis)
        {
            bottomAxis.draw(cfGroup, x + leftWidth, y + h - bottomHeight, w, bottomHeight, info, showBottomAxis, false, drawTicksOnInside);
        }

        // w -= (leftWidth + rightWidth);
        h -= (topHeight + bottomHeight);

        //---- now actually draw axes ----
        if (leftAxis)
        {
            leftAxis.draw(cfGroup, x, y + topHeight - .5, leftWidth, sideHeight, info, showLeftAxis, false, drawTicksOnInside);
        }

        if (rightAxis)
        {
            rightAxis.draw(cfGroup, x + leftWidth + w, y + topHeight - .5, rightWidth, sideHeight, info, showRight, showBoxTicks, drawTicksOnInside);
        }

        x += leftWidth;
        y += topHeight;

        if ((w > 0) && (h > 0))
        {
            closure.drawPlotArea(x, y, w, h, leftAxis, bottomAxis, borderSize);
        }

        plotAreaRect = vp.rect(x, y, w, h);

        //---- center legend vertically relative to plot area, but no higher than top of plot area ----
        if (legendGroup)
        {
            var legendTop = y;
            if (legendHeight < h)
            {
                legendTop += (h - legendHeight) / 2;
            }

            legendGroup
                .translate(legendLeft + .5, legendTop - .25)
        }

        //---- move TITLE so that it is centered over plot area (white rect) ----
        if (szText)
        {
            var titleElem = vp.select(cfGroup, "#title");
            if (titleElem)
            {
                var xCenter = x + w / 2 - szText.width/2;
                titleElem.attr("x", xCenter);
            }
        }
    }

    closure.plotAreaRect = function ()
    {
        return plotAreaRect;
    };

    closure.drawPlotArea = function (x, y, w, h, leftAxis, bottomAxis, borderSize)
    {
        bgGroup
            .clear()
            .translate(x, y)
            .id("plotAreaBg")

        glGroup
            .clear()
            .translate(x, y - .5)
            .id("gridLines")

        //---- get THEME drawing attributes for PLOT BG ----
        var da = vp.currentTheme().getDrawingAttributes("chartFrame.plotBg");

        if (borderSize !== undefined)
        {
            da.lineSize = borderSize;
        }

        //---- add white rectangle ----
        var rect = bgGroup.append("rect")
            .id("plotBg")
            .attr("x", .5)
            .attr("y", +.5)
            .attr("width", w)
            .attr("height", h)

        vp.applyShapeAttributes(rect, da);

        //---- get THEME drawing attributes for GRID LINES ----
        da = vp.currentTheme().getDrawingAttributes("chartFrame.gridLines");
        da.id = "gridLine";

        if (gridLineType != undefined)
        {
            da.lineType = gridLineType;
        }

        if (showYGridLines)
        {
            var hTickOffsets = null;
            if (leftAxis)
            {
                hTickOffsets = leftAxis.tickOffsets();

                if (hTickOffsets.length > .15 * h)
                {
                    hTickOffsets = null;        // hide horizontal gridlines  (too busy)
                }
            }

            if (hTickOffsets)
            {
                //vp.debug("drawing gridlines with width=" + w);

                //---- draw horizontal gridlines ----
                for (var t = 0; t < hTickOffsets.length; t++)
                {
                    var yy = Math.round(hTickOffsets[t]);

                    //---- draw horizontal grid line ----
                    vp.drawHLine(glGroup, da, 0, w, (h - yy), da);
                }
            }
        }

        if (showXGridLines)
        {
            var vTickOffsets = null;
            if (bottomAxis)
            {
                vTickOffsets = bottomAxis.tickOffsets();

                if (vTickOffsets.length > .15 * w)
                {
                    vTickOffsets = null;        // hide vertical gridlines  (too busy)
                }

            }

            if (vTickOffsets)
            {
                //---- draw vertical gridlines ----
                for (var v = 0; v < vTickOffsets.length; v++)
                {
                    var xx = Math.round(vTickOffsets[v]);

                    //---- draw vertical grid line ----
                    vp.drawVLine(glGroup, da, 0, h, xx, da);
                }
            }
        }

        da.id = "plotBorder";

        //---- draw frame around grid ----
        //vp.drawHLine(glGroup, da, 0, w, 0, da);
        //vp.drawHLine(glGroup, da, 0, w, h, da);
        //vp.drawVLine(glGroup, da, 0, h, 0, da);
        //vp.drawVLine(glGroup, da, 0, h, w-1, da);
    }

    //---- public property: title ----
    closure.title = function (value)
    {
        if (arguments.length == 0)
        {
            return title;
        }

        title = value;
        return closure;
    };


    //---- public property: titleSize ----
    closure.titleSize = function (value)
    {
        if (arguments.length == 0)
        {
            return titleSize;
        }

        titleSize = value;
        return closure;
    };

    //---- public property: xLabelFit ---- 
    closure.xLabelFit = function (value)
    {
        if (arguments.length == 0)
        {
            return xLabelFit;
        }

        xLabelFit = value;
        return closure;
    };

    //---- public property: showXGridLines ---- 
    closure.showXGridLines = function (value)
    {
        if (arguments.length == 0)
        {
            return showXGridLines;
        }

        showXGridLines = value;
        return closure;
    };

    //---- public property: gridLineType ---- 
    closure.gridLineType = function (value)
    {
        if (arguments.length == 0)
        {
            return gridLineType;
        }

        gridLineType = value;
        return closure;
    };

    //---- public property: showYGridLines ---- 
    closure.showYGridLines = function (value)
    {
        if (arguments.length == 0)
        {
            return showYGridLines;
        }

        showYGridLines = value;
        return closure;
    };

    //---- public property: isLegendVisible ----
    closure.isLegendVisible = function (value)
    {
        if (arguments.length == 0)
        {
            return isLegendVisible;
        }

        isLegendVisible = value;
        return closure;
    };

    //---- public property: showLeftAxis ----
    closure.showLeftAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showLeftAxis;
        }

        showLeftAxis = value;
        return closure;
    };

    //---- public property: showTopAxis ----
    closure.showTopAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showTopAxis;
        }

        showTopAxis = value;
        return closure;
    };

    //---- public property: showBoxTicks ----
    closure.showBoxTicks = function (value)
    {
        if (arguments.length == 0)
        {
            return showBoxTicks;
        }

        showBoxTicks = value;
        return closure;
    };

    //---- public property: showRightAxis ----
    closure.showRightAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showRightAxis;
        }

        showRightAxis = value;
        return closure;
    };

    //---- public property: showBottomAxis ----
    closure.showBottomAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showBottomAxis;
        }

        showBottomAxis = value;
        return closure;
    };

    //---- public property: dataFrame ----
    //closure.dataFrame = function (value)
    //{
    //    if (arguments.length == 0)
    //    {
    //        return dataFrame;
    //    }

    //    dataFrame = value;
    //    return closure;
    //};

    ////---- public property: mappings ----
    //closure.mappings = function (value)
    //{
    //    if (arguments.length == 0)
    //    {
    //        return mappings;
    //    }

    //    mappings = value;
    //    return closure;
    //};

    //---- public property: showLeftLabel ----
    closure.showLeftLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showLeftLabel;
        }

        showLeftLabel = value;
        return closure;
    };

    //---- public property: showRightLabel ----
    closure.showRightLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showRightLabel;
        }

        showRightLabel = value;
        return closure;
    };
    //---- public property: showTopLabel ----
    closure.showTopLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showTopLabel;
        }

        showTopLabel = value;
        return closure;
    };

    //---- public property: showBottomLabel ----
    closure.showBottomLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showBottomLabel;
        }

        showBottomLabel = value;
        return closure;
    };

    //---- public property: drawTicksOnInside ----
    closure.drawTicksOnInside = function (value)
    {
        if (arguments.length == 0)
        {
            return drawTicksOnInside;
        }

        drawTicksOnInside = value;
        return closure;
    };

    //---- public property: xAttribute ----
    closure.xAttribute = function (value)
    {
        if (arguments.length == 0)
        {
            return xAttribute;
        }

        xAttribute = value;
        return closure;
    };

    //---- public property: yAttribute ----
    closure.yAttribute = function (value)
    {
        if (arguments.length == 0)
        {
            return yAttribute;
        }

        yAttribute = value;
        return closure;
    };

    //---- public property: attributes ----
    closure.attributes = function (value)
    {
        if (arguments.length == 0)
        {
            return attributes;
        }

        attributes = value;
        return closure;
    };

    //---- init code ----
    init();

    return closure;
};

vp.createChartFrame = function ()
{
    return new vp.chartFrameClass();
};﻿///-----------------------------------------------------------------------------------------------------------------
/// svgAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - implements a continuous (linear) OR discrete (category) axis for left/top/right/bottom positions.
///-----------------------------------------------------------------------------------------------------------------
/// create an SVG-based numeric axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see svgAxis.html
///-----------------------------------------------------------------------------------------------------------------
vp.visuals.svgAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label

    var labelStrings = [];
    var labelWidths = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;
    var isLabelVisible = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var changingSize = false;
    var daName;             // name used to retreive theme information
    var daBlock;            // holds da's for all axis parts 

    var group = undefined;
    var breaks = undefined;
    var tickOffsets = undefined;
    var autoHideLabels = false;
    var autoHideTicks = false;
    var labelFit = undefined;

    //---- myAttribute is the attribute object associated with this axis (MUST be set by caller) ----
    var myAttribute = null;
    var myScale = null;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.svgAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function ()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function ()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        //if (timer == null)
        //{
        //    timer = setTimeout(build, 1);
        //}
    };

    /// private.
    var pixelAlign = function (value)
    {
        return Math.round(value);
    };

    //---- public property: labelFit ---- 
    closure.labelFit = function (value)
    {
        if (arguments.length == 0)
        {
            return labelFit;
        }

        labelFit = value;
        return closure;
    };

    closure.getDaBlock = function()
    {
        return daBlock;
    }

    /// private.
    var buildLabelStringsAndSizes = function (breakValues, showAxis, width, truncateIfNeeded)
    {
        labelStrings = [];
        labelWidths = [];

        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;
        
        if (showAxis)
        {
            var scaleLabels = myAttribute.getActualLabels(breakValues);

            //---- create a single SVG TEXT element for measuring all of our strings ----
            var fakeLabel = group.append("text")

            var da = daBlock.label;
            vp.applyTextAttributes(fakeLabel, da);

            var maxLabelWidth = (truncateIfNeeded && scaleLabels.length) ? (width / scaleLabels.length) : 0;

            scaleLabels.selectWithFunc(function (value, index)
            {
                //var formatFunc = myAttribute.getActualFormatter();
                //var labelStr = null;

                //if (scaleLabels)
                //{
                //    labelStr = scaleLabels[index];
                //}
                //else
                //{
                //    labelStr = formatFunc(value);
                //}

                var labelStr = value;

                //---- set up for measuring "labelStr" ----
                fakeLabel.text(labelStr);

                var width = Math.ceil(fakeLabel.width());
                var height = Math.ceil(fakeLabel.height());

                if ((maxLabelWidth) && (width > maxLabelWidth))
                {
                    //---- label is too big - truncate it ----
                    var ret = truncateLabelToFit(labelStr, maxLabelWidth, fakeLabel);

                    width = ret.width;
                    labelStr = { label: ret.labelStr, fullLabel: value };
                }

                labelStrings.push(labelStr);

                if (width > maxStringWidth)
                {
                    maxStringWidth = width;
                }

                if (height > maxStringHeight)
                {
                    maxStringHeight = height;
                }

                labelWidths.push(width);
                dataCount++;
            });

            totalLabelWidths = maxStringWidth * dataCount;
            totalLabelHeights = maxStringHeight * dataCount;

            //---- remove temp label created above ----
            fakeLabel.remove();
        }
    }

    var truncateLabelToFit = function(labelStr, maxLabelWidth, fakeLabel)
    {
        var text = labelStr;
        var width = 0;

        while (text.length)
        {
            //---- remove last char ----
            text = text.substr(0, text.length - 1);

            labelStr = text + "...";

            //---- measure ----
            fakeLabel.text(labelStr);
            width = Math.ceil(fakeLabel.width());
            if (width <= maxLabelWidth)
            {
                break;
            }
        }

        return { width: width, labelStr: labelStr};
    }

    closure.buildPrep = function (parentGroup, width, height, info, showAxis, truncateIfNeeded, ticksOnly)
    {
        if (!group)
        {
            group = parentGroup.append("g"); 
        }

        closure.updateAutoRangeScale(width, height);

        //---- build "breaks" ----
        breaks = myAttribute.getActualBreaks();

        //---- build "tickOffsets" ----
        tickOffsets = [];           // list of normalized offsets of each tick mark

        var range = myScale.palette();
        var rangeMin = range[0];
        var rangeMax = range[1];
        
        var rangeRange = rangeMax - rangeMin;
        rangeRange = (rangeRange == 0) ? 1 : rangeRange;

        //---- this code allows for just putting ticks around breaks ----
        if (myAttribute.getActualIsDiscrete())           // && (! myAttribute.mergeDuplicateCategories()))
        {
            //---- discrete axis has 1 extra tick at end but this is included in "breaks" ----
            for (var i = 0; i < breaks.length; i++)
            {
                var breakValue = breaks[i];
                var tickOff = myScale.scale(breakValue, -1, true);       // supress bar offset
                tickOffsets.push(tickOff);
            }
        }
        else
        {
            for (var i = 0; i < breaks.length; i++)
            {
                var breakValue = breaks[i];
                var offset = myScale.scale(breakValue);
                tickOffsets.push(offset);
            }
        }

        //---- build "labels" and "szText" ----
        buildLabelStringsAndSizes(breaks, showAxis, width, truncateIfNeeded);
    }

    closure.drawCore = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        //---- always call buildPrep (performs some needed side effects) ----
        var drawOnBottom = ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"));
        if (labelFit === undefined)
        {
            //---- figure out best default ----
            labelFit = LabelFit.skip;

            if (drawOnBottom)
            {
                var isCategory = myAttribute.getActualIsDiscrete();   
                if (isCategory)
                {
                    labelFit = LabelFit.rotateAuto;
                }
            }
        }

        var truncateIfNeeded = ((drawOnBottom) && (labelFit == 2));     // truncate

        closure.buildPrep(parentGroup, width, height, info, showAxis, truncateIfNeeded, ticksOnly);

        if (showAxis)
        {
            var szText = { width: maxStringWidth, height: maxStringHeight };
            var name = (isLabelVisible) ? myAttribute.title() : null;

            var isCategory = myAttribute.getActualIsDiscrete();     // && (!myAttribute.mergeDuplicateCategories()));

            if ((width <= 0) || (height <= 0))
            {
                group.clear();
                group.desiredWidth = 0;
                group.desiredHeight = 0;
            }
            else if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                vp.buildLeftAxis(group, height, tickOffsets, labelStrings, szText, isCategory, name,
                    true, daBlock, autoHideLabels, autoHideTicks, drawTicksOnInside);
                group.id("leftAxis");
            }
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                vp.buildRightAxis(group, height, tickOffsets, labelStrings, szText, isCategory, name, true, daBlock, autoHideLabels, autoHideTicks,
                    ticksOnly, drawTicksOnInside);
                group.id("rightAxis");
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                vp.buildTopAxis(group, width, tickOffsets, labelStrings, szText, isCategory, name, false, daBlock, ticksOnly, drawTicksOnInside);
                group.id("topAxis");
            }
            else if (drawOnBottom)
            {
                vp.buildBottomAxis(group, width, tickOffsets, labelStrings, szText, isCategory, name,
                    false, daBlock, autoHideLabels, autoHideTicks, labelFit, drawTicksOnInside);
                group.id("bottomAxis");
            }
        }
    };

    closure.getWidth = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        return (showAxis) ? group.desiredWidth : 0;
    }

    closure.getHeight = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        return (showAxis) ? group.desiredHeight : 0;
    }

    closure.draw = function (parentGroup, x, y, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        group
            //.transform("translate(" + x + "," + y + ")");
            .translate(x, y)
    }

    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            //updateAutoRangeScale();       // need to get width, height ...
        }
    };

    closure.updateAutoRangeScale = function (width, height)
    {
        if (myScale.autoRange && myScale.autoRange())
        {
            var isVertical = ((axisLocation == vp.axisLocation.left) || (axisLocation == "left")
                || (axisLocation == vp.axisLocation.right) || (axisLocation == "right"));

            var size = (isVertical) ? height : width;

            myScale
                .rangeMin(0)
                .rangeMax(size)
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: attribute ----
    closure.attribute = function (value)
    {
        if (value === undefined)
        {
            return myAttribute;
        }

        myAttribute = value;
        myScale = value.scale();
        //updateAutoRangeScale();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        if (group)
        {
            group.remove();     // remove from parent
        }

        markRebuildNeeded();

        return closure;
    };

    //---- READONLY property: tickOffsets ----
    closure.tickOffsets = function (value)
    {
        return tickOffsets;
    };

    //---- property: isLabelVisible ----
    closure.isLabelVisible = function (value)
    {
        if (arguments.length === 0)
        {
            return isLabelVisible;
        }

        isLabelVisible = value;
        return closure;
    };

    //---- property: daName ----
    closure.daName = function (value)
    {
        if (arguments.length === 0)
        {
            return daName;
        }

        daName = value;
        onDaNameChanged();

        return closure;
    };

    var onDaNameChanged = function()
    {
        var theme = vp.currentTheme();

        var daTick = theme.getDrawingAttributes(daName + ".tick");
        var daSkipTick = theme.getDrawingAttributes(daName + ".skipTick");
        var daLabel = theme.getDrawingAttributes(daName + ".label");
        var daTitle = theme.getDrawingAttributes(daName + ".title");
        var daAxis = theme.getDrawingAttributes(daName + ".axisLine");

        daBlock = { tick: daTick, skipTick: daSkipTick, label: daLabel, title: daTitle, axis: daAxis };
    }

    return closure;
};

//---- enum: axisLocation ----
vp.axisLocation = { left: 0, top: 1, right: 2, bottom: 3 };
﻿///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/svgDraw.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for drawing lines and text.
///-----------------------------------------------------------------------------------------------------------------
vp.textElemJustDraw = null;

vp.drawText = function (group, da, x, y, width, height, halign, valign, rotation,
    cxRot, cyRot)
{
    vp.validateDa(da);

    cxRot = (cxRot === undefined) ? .5 : cxRot;
    cyRot = (cyRot === undefined) ? .5 : cyRot;

    var elem = group.append("text")

    vp.applyTextAttributes(elem, da, false);

    //---- get UNROTATED size ----
    var rect = vp.getBounds(elem[0]);       // .getBoundingClientRect();
    var sz = { width: rect.width, height: rect.height };

    var origSz = sz;
    var origX = x;
    var origY = y;

    if (rotation)
    {
        elem
            .transform("rotate(" + rotation + ")");

        //---- get ROTATED size ----
        rect = vp.getBounds(elem[0]);
        sz = { width: rect.width, height: rect.height };
    }

    halign = (halign === undefined) ? "left" : halign;
    valign = (valign === undefined) ? "center" : valign;

    if (! width)
    {
        //---- align to (x,y) ----
        if (halign === "center")
        {
            x -= origSz.width / 2;
        }
        else if (halign == "right")
        {
            x -= origSz.width;
        }
        else if (halign == "left")
        {
            //---- this is the SVG default ----
        }
    }
    else
    {
        //---- align within (x, y, width, height) ----
        if (halign === "center")
        {
            var xoff = Math.max(0, (width - origSz.width) / 2);
            x += xoff;
        }
        else if (halign == "right")
        {
            var xoff = Math.max(0, (width - origSz.width));
            x += xoff;
        }
        else if (halign == "left")
        {
            //---- this is the SVG default ----
        }
    }

    /// for vertical alignment, SVG defaults to writing the text on top of the 
    /// line at "y" with descenders hanging down.

    /// this adjusts the text is vertically centered on the y line --
    if (true)    //(sz.height > 30)
    {
        //if (Math.abs(rotation) > 0)
        //{
        //    x += (.30 * sz.width);       // adjust text to be just under middle line
        //}
        //else
        //{
        //    y += (.30 * sz.height);       // adjust text to be just under middle line
        //}
    }

    if (! height)
    {
        //---- align to (x,y) ----
        if (valign === "bottom")
        {
            y += origSz.height / 2;
        }
        else if (valign == "top")
        {
            y -= origSz.height / 2;
        }
        else if (valign == "center")
        {
            //---- this is the SVG default ----
        }
    }
    else
    {
        //---- align within (x, y, width, height) ----
        if (valign == "top")
        {
            y += origSz.height / 2;
        }
        else if (valign == "center")
        {
            y += height / 2;
        }
        else if (valign === "bottom")
        {
            y += (height - origSz.height / 2);
        }
    }

    y += .15 * origSz.height;           // asthetic adjustment

    elem
        .attr("x", x)
        .attr("y", y)

    if (rotation)
    {
        //---- set the actual transform ----

        //---- rotation point ----
        var cx = x + (cxRot * origSz.width);        
        var cy = y + ((cyRot - 1) * origSz.height);

        cy += .15 * origSz.height;           // asthetic adjustment

        elem
           .transform("rotate(" + rotation + "," + cx + "," + cy + ")");

        //---- debug - create small rect at rotation center ----
        //group.append("rect")
        //    .bounds(origX+1, y+1, 2, 2)
        //    .colors("blue")

        //group.append("rect")
        //    //.bounds(x + 1 + origSz.width / 2, y + 1 - origSz.height / 2, 2, 2)
        //    .bounds(cx + 1, cy + 1, 2, 2)
        //    .colors("red")

        //elem.transform("")

    }

    vp.textElemJustDraw = elem;

    return sz;
};

vp.validateDa = function (da)
{
    if ((!da) || (da.isThemeAttr === undefined))       // hasKeys(da))
    {
        vp.error("Invalid 'da' ('isThemeAttr' property not set): " + da);
    }
};


vp.drawHLine = function(group, da, x1, x2, y)
{
    vp.validateDa(da);

    x1 = Math.round(x1);
    x2 = Math.round(x2);
    y = Math.round(y);

    var line = group.append("line")
        .attr("x1", x1)
        .attr("x2", x2)
        .attr("y1", y + .5)     // added .5
        .attr("y2", y + .5)     // added .5
        .attr("shape-rendering", "crispEdges")

    vp.applyLineAttributes(line, da);

    //var rect = group.append("rect")
    //   .attr("x", x1)
    //   .attr("y", y + .5)
    //   .attr("width", x2-x1)
    //   .attr("height", da.lineSize)
    //   .attr("shape-rendering", "crispEdges")
    //   .attr("fill", da.fill)
};

vp.drawVLine = function(group, da, y1, y2, x)
{
    vp.validateDa(da);

    y1 = Math.round(y1);
    y2 = Math.round(y2);
    x = Math.round(x);

    var line = group.append("line")
        .attr("x1", x + .5)
        .attr("x2", x + .5)
        .attr("y1", y1)     // was y1 - .5
        .attr("y2", y2)     // was y2 - .5
        .attr("shape-rendering", "crispEdges")

    vp.applyLineAttributes(line, da);

    //var rect = group.append("rect")
    // .attr("x", x)
    // .attr("y", y1 + .5)
    // .attr("width", da.lineSize)
    // .attr("height", y2-y1)
    // .attr("shape-rendering", "crispEdges")
    // .attr("fill", da.fill)
};

vp.getFirstItem = function (value, isColor)
{
    //---- this block no longer needed since theme "fill" and "stroke" values are now single colors only ----
    //if (vp.isString(value))
    //{
    //}
    //else if (vp.isArray(value))
    //{
    //    var item0 = value[0];
    //    if ((! isColor) || (!vp.isNumber(item0)))
    //    {
    //        value = item0;
    //    }
    //}

    if ((isColor) && (!vp.isString(value)) && (vp.isArray(value)))
    {
        value = vp.colorHelper.toColor(value);
    }

    return value;
}

/// apply constant/mapped attributes specifed in "da" to a text element.
/// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
vp.applyTextAttributes = function (elem, da, alignText)
{
    vp.validateDa(da);

    alignText = (alignText === undefined) ? true : alignText;

    //---- FILL ----
    if (da.textFill !== undefined)     
    {
        var fillValue = vp.getFirstItem(da.textFill, true);

        elem
            .attr("fill", fillValue)

        /// Note: using elem.setAttribute() for custom props sometimes results in NaN values, so we set directly as prop on elem.
        elem[0].origFill = fillValue;
    }

    //---- OPACITY ----
    if (da.opacity !== undefined)
    {
        elem
            .attr("opacity", da.opacity)
    }

    //---- TEXT SIZE ----
    if (da.textSize !== undefined)
    {
        elem.attr("font-size", da.textSize)
    }

    //---- FONT FAMILY ----
    if (da.fontFamily !== undefined)
    {
        elem.attr("font-family", da.fontFamily)
    }

    if (da.fontWeight !== undefined)
    {
        elem.attr("font-weight", da.fontWeight);
    }

    //---- TEXT LABEL ----
    if (da.textLabel !== undefined)
    {
        elem.text(da.textLabel)
    }

    if (alignText)
    {
        //---- HALIGN, VALIGN ----
        var adjust = vp.calculateTextAdjust(elem, da.hAlign, da.vAlign);
        elem.attr("dx", adjust.x);
        elem.attr("dy", adjust.y);

        //---- the below code is for reference - a method for adjust text without us doing the measurement ----
        //.attr("text-anchor", "middle")
        //.attr("dy", ".5ex")       // "ex" unit is height of "e" char
    }

    if (da.id)
    {
        elem.id(da.id);
    }
};

/// use the "hAlign" and "vAlign" property values to calculate the x/y adjustment
/// needed for the text. requires the text element with the final text applied to it
/// (and it should be attached to the document) so that it can be correctly measured.  
///
/// return the adjustment as a {x, y} object.
vp.calculateTextAdjust = function (textElem, hAlign, vAlign)
{
    var hvals = { left: 0, middle: .5, right: 1 };
    var vvals = { top: 1, middle: .5, bottom: 0 };
    var adjust = { x: 0, y: 0 };

    if (textElem)
    {
        //---- HALIGN ----
        if (hvals[hAlign])
        {
            hAlign = hvals[hAlign];
        }

        //---- VALIGN ----
        if (vvals[vAlign])
        {
            vAlign = vvals[vAlign];
        }

        var uelem = (textElem.length) ? textElem[0] : textElem;
        var bb = vp.getBounds(uelem);

        //---- horizontal alignment defaults to: text starts at "x" ----
        adjust.x = -(bb.width * hAlign);

        //---- UNROATED TEXT: vertical alignment defaults to: CENTER LINE of text is at "y" ----
        adjust.y = (1 - .25 - vAlign) * bb.height;      // the ".25" is an asthetic adjustment for vertical alignment
    }

    return adjust;
};

vp.applyShapeAttributes = function (elem, da)
{
    vp.applyShapeAttributesU(elem[0], da);
    //vp.validateDa(da);

    ////---- SHAPE and SHAPE SIZE are not handled here since they requires special processing.  ----
    ////---- see layerPoint.js for example ----

    ////---- FILL ----
    //if (da.fill !== undefined)
    //{
    //    var fillValue = vp.getFirstItem(da.fill, true);

    //    elem
    //        .attr("fill", fillValue)

    //    elem[0].origFill = fillValue;
    //}

    ////---- STROKE ----
    //if (da.stroke !== undefined)
    //{
    //    var strokeValue = vp.getFirstItem(da.stroke, true);

    //    elem
    //        .attr("stroke", strokeValue)

    //    elem[0].origStroke = strokeValue;
    //}

    ////---- OPACITY ----
    //if (da.opacity !== undefined)
    //{
    //    elem
    //        .attr("opacity", da.opacity)

    //    elem[0].origOpacity = da.opacity;
    //}

    ////---- LINE TYPE ----
    //if (da.lineType !== undefined)
    //{
    //    var lineType = vp.lineTypeToDashArray(da.lineType);
    //    elem.attr("stroke-dasharray", lineType);
    //}

    //if (da.lineSize !== undefined)
    //{
    //    elem.attr("stroke-width", da.lineSize)
    //}

    //if (da.id)
    //{
    //    elem.id(da.id);
    //}

    //if (elem[0].tagName == "rect")
    //{
    //    //---- check for rx/ry attributes ----
    //    if ((da.rx) || (da.ry))
    //    {
    //        elem.attr("rx", da.rx);
    //        elem.attr("ry", da.ry);
    //    }

    //    //---- causing severe problems during animation; turn OFF for now ----
    //    ////---- adjust bounds of RECT to SNAP TO PIXELS ----
    //    //var noBorder = (!da.lineSize);

    //    //var x = Math.round(elem.attr("x"));
    //    //var y = Math.round(elem.attr("y"));
    //    //var w = Math.round(elem.attr("width"));
    //    //var h = Math.round(elem.attr("height"));

    //    //if (noBorder)
    //    //{
    //    //    h -= .25;
    //    //}
    //    //else
    //    //{
    //    //    x += .5;
    //    //    y += .5;
    //    //    w -= 1;
    //    //    h -= 1.25;
    //    //}

    //    //elem.attr("x", x);
    //    //elem.attr("y", y);
    //    //elem.attr("width", w);
    //    //elem.attr("height", h);
    //}
};

vp.applyShapeAttributesU = function (uelem, da)
{
    vp.validateDa(da);

    //---- SHAPE and SHAPE SIZE are not handled here since they requires special processing.  ----
    //---- see layerPoint.js for example ----

    //---- FILL ----
    if (da.fill !== undefined)
    {
        var fillValue = vp.getFirstItem(da.fill, true);

        vp.attr(uelem, "fill", fillValue)

        uelem.origFill = fillValue;
    }

    //---- STROKE ----
    if (da.stroke !== undefined)
    {
        var strokeValue = vp.getFirstItem(da.stroke, true);

        vp.attr(uelem, "stroke", strokeValue)

        uelem.origStroke = strokeValue;
    }

    //---- OPACITY ----
    if (da.opacity !== undefined)
    {
        vp.attr(uelem, "opacity", da.opacity)

        uelem.origOpacity = da.opacity;
    }

    //---- LINE TYPE ----
    if (da.lineType !== undefined)
    {
        var lineType = vp.lineTypeToDashArray(da.lineType);
        vp.attr(uelem, "stroke-dasharray", lineType);
    }

    if (da.lineSize !== undefined)
    {
        vp.attr(uelem, "stroke-width", da.lineSize)
    }

    if (da.id)
    {
        vp.id(uelem, da.id);
    }

    if (uelem.tagName == "rect")
    {
        //---- check for rx/ry attributes ----
        if ((da.rx) || (da.ry))
        {
            vp.attr(uelem, "rx", da.rx);
            vp.attr(uelem, "ry", da.ry);
        }

        //---- causing severe problems during animation; turn OFF for now ----
        ////---- adjust bounds of RECT to SNAP TO PIXELS ----
        //var noBorder = (!da.lineSize);

        //var x = Math.round(elem.attr("x"));
        //var y = Math.round(elem.attr("y"));
        //var w = Math.round(elem.attr("width"));
        //var h = Math.round(elem.attr("height"));

        //if (noBorder)
        //{
        //    h -= .25;
        //}
        //else
        //{
        //    x += .5;
        //    y += .5;
        //    w -= 1;
        //    h -= 1.25;
        //}

        //elem.attr("x", x);
        //elem.attr("y", y);
        //elem.attr("width", w);
        //elem.attr("height", h);
    }
};

vp.applyLineAttributes = function (elem, da)
{
    vp.applyLineAttributesU(elem[0], da);
}
    /// apply constant/mapped attributes specifed in "da" to line element.
/// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
vp.applyLineAttributesU = function (uelem, da)
{
    vp.validateDa(da);

    //---- STROKE ----
    if (da.stroke !== undefined)
    {
        var strokeValue = vp.getFirstItem(da.stroke, true);

        vp.attr(uelem, "stroke", strokeValue)
        uelem.origStroke = strokeValue;
    }

    //---- OPACITY ----
    if (da.opacity !== undefined)
    {
        vp.attr(uelem, "opacity", da.opacity)
        uelem.origOpacity = da.opacity;
    }

    //---- LINE TYPE ----
    if (da.lineType !== undefined)
    {
        var lineType = vp.lineTypeToDashArray(da.lineType);
        vp.attr(uelem, "stroke-dasharray", lineType);
    }

    if (da.lineSize === undefined)
    {
        da.lineSize = 1;
    }

    vp.attr(uelem, "stroke-width", da.lineSize)
    uelem.origStrokeWidth = da.lineSize;

    if (da.id)
    {
        vp.id(uelem, da.id);
    }
};

vp.drawBox = function (group, da, x, y, w, h)
{
    vp.validateDa(da);

    var rect = group.append("rect")
        .position(x, y)
        .width(w)
        .height(h)

    vp.applyShapeAttributes(rect, da);

    return rect;
};

vp.lineTypeToDashArray = function (lineType)
{
    var lt = (vp.isString(lineType)) ? lineType.toLowerCase() : lineType;
    var value = "";

    if ((lt === "blank") || (lt === 0))
    {
        value = "0, 10";
    }
    else if ((lt === "solid") || (lt === 1))
    {
        value = "";
    }
    else if ((lt === "dashed") || (lt === 2))
    {
        value = "4, 4";
    }
    else if ((lt === "dotted") || (lt === 3))
    {
        value = "1, 3";
    }
    else if ((lt === "dotdash") || (lt === 4))
    {
        value = "1, 3, 4, 4";
    }
    else if ((lt === "longdash") || (lt === 5))
    {
        value = "7, 3";
    }
    else if ((lt === "twodash") || (lt === 6))
    {
        value = "2, 2, 6, 2";
    }
    else
    {
        //---- leave alone (let call specify on/off pattern in a string) ----
        value = lt;
    }

    return value;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// vuePlot/colors/colorPalettes.js.  Copyright (c) 2012 Microsoft Corporation.
///     - a set of helper functions for creating color palettes (sets of colors).
///-----------------------------------------------------------------------------------------------------------------
/// <summary>
/// Predefined and custom color palettes.  A color palette is an array of colors that can be
/// used to with an Interpolator or a Scale to sample as discrete or continous colors.
/// 
/// note: below functions are continuous, unless marked as "discrete".
///
/// Predefined:
///     - blueRed              
///     - redGreen              
///     - surface
///     - grays(n)
///     - reds(n)
///     - greens(n)
///     - blues(n)
///     - rainbow(n)            (discrete)
///     - rainbowPairs(n)       (discrete)
///     
/// Custom:
///     - darkLight(cr, ...)        
///     - darkLightDark(cr, cr2)
///     - lightDark(cr, ...)        
///     - hueSteps(cr, n)       (discrete)
///     - analogs(cr)           (discrete)
///     - shades(cr, n)
///     
/// </summary>
///-----------------------------------------------------------------------------------------------------------------
vp.colorPalettes = {};       // namespace object

/// <summary>
/// Predefined color scheme for displaying negative and positive continous values:
///     DarkBlue, DarkRed
/// </summary>
vp.colorPalettes.blueRed = function ()
{
    return [ vp.colorHelper.colors.darkblue, vp.colorHelper.colors.darkred ];
};

/// <summary>
/// Predefined color scheme for displaying negative and positive continous values:
///     DarkRed, LightRed, LightGreen, DarkGreen
/// </summary>
vp.colorPalettes.redGreen = function ()
{
    return [vp.colorHelper.colors.darkred, vp.rgbFromHsl(0, 1, .8), vp.colorHelper.colors.lightgreen, vp.colorHelper.colors.darkgreen];
};

/// <summary>
/// Predefined color scheme for surface colors:
///     DarkBlue, Aqua, Yellow, DarkRed
/// </summary>
/// <returns></returns>
vp.colorPalettes.surface = function ()
{
    var palette = ["rgb(0, 0, 143)", "rgb(0, 0, 255)", "rgb(0, 255, 255)", "rgb(255, 255, 0)", "rgb(255, 0, 0)", "rgb(128, 0, 0)"];
    var stops = [0, 1 / 8, 3 / 8, 5 / 8, 7 / 8, 1];

    palette.stops = stops;
    return palette;
};

/// <summary>
/// Predefined color scheme for shades of gray
/// </summary>
/// <returns></returns>
vp.colorPalettes.grays = function (steps, startPercent, endPercent)
{
    startPercent = startPercent || 1;
    endPercent = endPercent || 0;

    return vp.colorPalettes.shades(vp.colorHelper.colors.gray, steps, startPercent, endPercent);
};

/// <summary>
/// Predefined color scheme for shades of red
/// </summary>
/// <returns></returns>
vp.colorPalettes.reds = function (steps)
{
    return vp.colorPalettes.shades(vp.colorHelper.colors.red, steps);
};

/// <summary>
/// Predefined color scheme for shades of green
/// </summary>
/// <returns></returns>
vp.colorPalettes.greens = function (steps)
{
    return vp.colorPalettes.shades(vp.colorHelper.colors.green, steps);
};

/// <summary>
/// Predefined color scheme using the specified number of hues spaced
/// around the color wheel.
/// </summary>
/// <returns></returns>
vp.colorPalettes.rainbow = function (steps)
{
    var values = [];
    var stepSize = 1 / steps;

    for (var i = 0; i < steps; i++)
    {
        var hue = i * stepSize;
        values[i] = vp.rgbFromHsl(hue, 1, .5);
    }

    return values;
};

/// <summary>
/// Predefined color scheme using the specified number of hues spaced
/// around the color wheel.  Each hue generates 2 colors: light and dark versions
/// of the hue.
/// </summary>
/// <returns></returns>
vp.colorPalettes.rainbowPairs = function (steps)
{
    var values = [];
    var stepSize = 1 / steps;

    for (var i = 0; i < steps; i++)
    {
        var hue = i * stepSize;

        values.push(vp.rgbFromHsl(hue, 1, .3));
        values.push(vp.rgbFromHsl(hue, 1, .7));
    }

    return values;
};

/// <summary>
/// Generates a custom color scheme, using a dark and light version of each
/// specifed color.
/// </summary>
/// <returns></returns>
vp.colorPalettes.darkLight = function (color1)
{
    var values = [];

    for (var i = 0; i < arguments.length; i++)
    {
        var hsl = vp.hslFromRgb(arguments[i]);

        values.push(vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
        values.push(vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
    }

    return values;
};

/// <summary>
/// Generates a custom color scheme, using a dark and light version of each
/// specifed color.
/// </summary>
/// <returns></returns>
vp.colorPalettes.darkLightDark = function (cr, cr2)
{
    var hsl = vp.hslFromRgb(cr);
    var hsl2 = vp.hslFromRgb(cr2);

    var colors =  
    [
        vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .20),
        vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .80),
        vp.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .80),
        vp.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .20)
    ];

    return colors;
};

/// <summary>
/// Generates a custom color scheme, using a light and dark version of each
/// specifed color.
/// </summary>
/// <returns></returns>
vp.colorPalettes.lightDark = function (color1)
{
    var values = [];

    for (var i = 0; i < arguments.length; i++)
    {
        var hsl = vp.hslFromRgb(arguments[i]);

        values.push(vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
        values.push(vp.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
    }

    return values;
};

/// <summary>
/// Returns a set of colors whose hues are equally spaces in the color wheel.
/// </summary>
/// <param name="color"></param>
/// <param name="count"></param>
/// <returns></returns>
vp.colorPalettes.hueSteps = function(color, steps)
{
    var colors = [];
    var hsl = vp.hslFromRgb(color);
    var hue = hsl.hue();
    var step = 1 / steps;

    for (var i = 0; i < steps; i++)
    {
        var hx = vp.normalizeHue(hue + i*step);
        colors[i] = vp.rgbFromHsl(hx, hsl.saturation(), hsl.lightness());
    }

    return colors;
};

/// <summary>
/// Returns the set of 4 analog colors, based on the specified color.
/// </summary>
/// <param name="color"></param>
/// <param name="count"></param>
/// <returns></returns>
vp.colorPalettes.analogs = function(color)
{
    var colors = [];
    var hsl = vp.hslFromRgb(color);
    var hue = hsl.hue();
    var step = 1 / 9;

    colors[0] = color;

    var h1 = vp.normalizeHue(hue + step);
    var h2 = vp.normalizeHue(hue + .5);
    var h3 = vp.normalizeHue(hue + .5 + step);

    colors[1] = vp.rgbFromHsl(h1, hsl.saturation(), hsl.lightness());
    colors[2] = vp.rgbFromHsl(h2, hsl.saturation(), hsl.lightness());
    colors[3] = vp.rgbFromHsl(h3, hsl.saturation(), hsl.lightness());

    return colors;
};

/// <summary>
/// Returns the specified number of shades of a color.
/// </summary>
/// <param name="color"></param>
/// <param name="count"></param>
/// <returns></returns>
vp.colorPalettes.shades = function (color, count, startPercent, endPercent)
{
    startPercent = (startPercent === undefined) ? .98 : startPercent;
    endPercent = (endPercent === undefined) ? .09 : endPercent;

    if (count < 1)
    {
        throw new Exception("Count must be at least 1");
    }

    var colors = [];
    if (count == 1)
    {
        colors.push(color);
    }
    else
    {
        var hsl = vp.hslFromRgb(color);

        var step = (endPercent - startPercent) / (count - 1);
        var index = 0;

        if (step >= 0)
        {
            for (var percent = startPercent; vp.floatLeq(percent, endPercent) ; percent += step)
            {
                colors[index++] = vp.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
            }
        }
        else
        {
            for (var percent = startPercent; vp.floatGeq(percent, endPercent) ; percent += step)
            {
                colors[index++] = vp.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
            }
        }
    }

    return colors;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// hsl.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a class that represents a color in HSL (hue, saturation, luminance) color space.
///-----------------------------------------------------------------------------------------------------------------
// Specifies an HSLA color value (stored as int + 3 floats).  Designed to support HSL color values as specified
/// for SVG.  Adapted from: http://www.w3.org/TR/css3-color/#hsl-color.  The SVG order is Hsla for creation.
/// 
/// CTR should accept 5 forms: 
///     - hsl (3-4 floats)    
///     - rgb (3-4 floats)
///     
/// Should provide 2 ToXXX() functions:
///     - toRgb()
///     - toString()
///     
/// Should provide 4 public READONLY properties:
///     - var hue
///     - var saturation
///     - var lightness
///     - var alpha
///-----------------------------------------------------------------------------------------------------------------
vp.hsl = function (hue, saturation, lightness, alpha)
{
    //---- private state ----

    /// closure
    var closure = function ()
    {
    };

    /// public: toRgb()
    closure.toRgb = function ()
    {
        var rgb = vp.rgbFromHsl(closure);
        return rgb;
    };

    closure.toString = function ()
    {
        return "{H: " + hue + ", S: " + saturation + ", L: " + lightness + ", A: " + alpha + "}";
    };

    closure.lighten = function ()
    {
        var light = Math.min(1, lightness + .13);
        return vp.hsl(hue, saturation, light, alpha);
    }

    closure.darken = function ()
    {
        var light = Math.max(0, lightness - .13);
        return vp.hsl(hue, saturation, light, alpha);
    }

    /// public: hue
    closure.hue = function ()
    {
        return hue;
    }

    /// public: saturation
    closure.saturation = function ()
    {
        return saturation;
    }

    /// public: lightness
    closure.lightness = function ()
    {
        return lightness;
    }

    /// public: alpha
    closure.alpha = function ()
    {
        return alpha;
    }

    //---- init code ----
    alpha = (alpha === undefined) ? 1 : alpha;

    return closure;
};

/// static public: vp.hslFromRgb()
/// "rgb" should be a 3 or 4 element array of numbers, each 0-255.
vp.hslFromRgb = function (rgb)
{ 
    if (vp.isString(rgb))
    {
        rgb = vp.colorHelper.getColorFromString(rgb);
    }

    //---- convert RGB to HSL ----
    ///
    /// adapted from: http://130.113.54.154/~monger/hsl-rgb.html
    /// 
    var r = rgb[0]/255;     // convert to unit numbers
    var g = rgb[1]/255;
    var b = rgb[2]/255;

    var alpha = (rgb.length > 3) ? rgb[3]/255 : 1;

    var min = Math.min(r, Math.min(g, b));
    var max = Math.max(r, Math.max(g, b));

    var lightness = (max + min)/2;
    var saturation = 0;
    var hue = 0;

    if (max == min)
    {
        //---- some shade of gray ----
        saturation = 0;
        hue = 0;       // actually undefined, but this is usual way to handle
    }
    else
    {
        if (lightness < .5)
        {
            saturation = (max - min) / (max + min);
        }
        else
        {
            saturation = (max - min) / (2 - max - min);
        }

        if (r == max)
        {
            hue = (g - b) / (max - min);
        }
        else if (g == max)
        {
            hue = 2 + (b - r) / (max - min);
        }
        else     // (b == max)
        {
            hue = 4 + (r - g) / (max - min);
        }

        //---- hue should now be in range 0..6 ----
        hue *= 60;
        if (hue < 0)
        {
            hue += 360;
        }

        hue /= 360;        // convert to a percentage
    }

    return vp.hsl(hue, saturation, lightness, 1);
};

/// static public: vp.rgbFromHsl()
vp.rgbFromHsl = function (hsl)
{
    if (arguments.length == 3)
    {
        hsl = vp.hsl(arguments[0], arguments[1], arguments[2]);
    }

    //---- HSL to RGB Conversion----
    ///
    /// adapted from: http://www.w3.org/TR/2003/CR-css3-color-20030514/
    /// 
    var m2 = 0;
    var ll = hsl.lightness();
    var s = hsl.saturation();
    var hue = hsl.hue();

    if (ll <= .5)
    {
        m2 = ll * (s + 1);
    }
    else
    {
        m2 = ll + s - ll * s;
    }

    var m1 = ll * 2 - m2;

    var red = vp.hueToRgb(m1, m2, hue + 1 / 3);
    var green = vp.hueToRgb(m1, m2, hue);
    var blue = vp.hueToRgb(m1, m2, hue - 1 / 3);

    //---- we represent RGB values as 3-4 element numeric arrays ----
    var r = vp.clamp(Math.round(red * 255), 0, 255);
    var g = vp.clamp(Math.round(green * 255), 0, 255);
    var b = vp.clamp(Math.round(blue * 255), 0, 255);
    var a = vp.clamp(Math.round(hsl.alpha() * 255), 0, 255);

    return [r, g, b, a];
};

vp.hueToRgb = function(m1, m2, h)
{
    if (h < 0)
    {
        h = h + 1;
    }

    if (h > 1)
    {
        h = h - 1;
    }

    if (h * 6 < 1)
    {
        return m1 + (m2 - m1) * h * 6;
    }

    if (h * 2 < 1)
    {
        return m2;
    }

    if (h * 3 < 2)
    {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }

    return m1;
};

vp.normalizeHue = function (value)
{
    if (value < 0)
    {
        value = 1 + value;
    }
    else if (value > 1)
    {
        value = value - 1;
    }

    value = vp.clamp(value, 0, 1);

    value = Math.floor(value) - value;      // just fractional part
    value = Math.abs(value);

    return value;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// adaptStatFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - statistic functions.
///-----------------------------------------------------------------------------------------------------------------

/// adapted from: http://en.wikipedia.org/wiki/Normal_distribution
vp.normalPDF = function (mean, varSq, xFrom, xTo, xIncr)
    /// vp.normalPDF(mean, varSq, xFrom, xTo, xIncr)
    /// - generates data for a gaussian (normal) probability distribution function.
{
    if (xFrom === undefined)
    {
        xFrom = -5;
    }

    if (xTo === undefined)
    {
        xTo = -xFrom;
    }

    if (xIncr === undefined)
    {
        xIncr = .05;
    }

    var variance = Math.sqrt(varSq);
    var dd = variance * Math.sqrt(2 * Math.PI)
    var records = [];

    for (var x = xFrom; x <= xTo; x += xIncr)
    {
        var xx = (x - mean) / variance;
        var y = (1 / dd) * Math.exp(xx * xx * -.5);

        var rec = { x: x, y: y };
        records.push(rec);
    }

    return records;
};

/// the error function, adapted from: http://en.wikipedia.org/wiki/Error_function
vp.erf = function (x)
{
    var p = .3275911;
    var a1 = .254829592;
    var a2 = -.284496736
    var a3 = 1.421413741;
    var a4 = -1.453152027;
    var a5 = 1.061405429;

    var xAbs = (x >= 0) ? x : -x;

    var t = 1 / (1 + p * xAbs);
    var t2 = t * t;
    var t3 = t2 * t;
    var t4 = t2 * t2;
    var t5 = t4 * t;

    var value = 1 - (a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5) * Math.exp(-(xAbs * xAbs));

    if (x < 0)
    {
        value = -value;
    }

    return value;
};


/// adapted from: http://en.wikipedia.org/wiki/Normal_distribution
vp.normalCDF = function (mean, varSq, xFrom, xTo, xIncr)
{
    if (xFrom === undefined)
    {
        xFrom = -5;
    }

    if (xTo === undefined)
    {
        xTo = -xFrom;
    }

    if (xIncr === undefined)
    {
        xIncr = .05;
    }

    var variance = Math.sqrt(varSq);
    var dd = variance * Math.sqrt(2 * Math.PI)
    var records = [];

    for (var x = xFrom; x <= xTo; x += xIncr)
    {
        var ep = (x - mean) / Math.sqrt(2 * varSq);
        var value = (1 + vp.erf(ep)) / 2;

        var rec = { x: x, y: value };
        records.push(rec);
    }

    return records;
};

/// adapted from http://en.wikipedia.org/wiki/Normal_distribution.
vp.randn = function (count, method)
{
    var meth = (method) ? method.toLowerCase() : "central-limit";
    var values = [];

    var loopCount = (count === undefined) ? 1 : count;

    if (meth === "box-muller")
    {
        //----- generate 2 numbers at a time ----
        for (var i = 0; i < loopCount; i += 2)
        {
            var u = Math.random();
            var v = Math.random();

            var term1 = Math.sqrt(-2 * Math.log(u)/Math.LOG10E);

            var value = term1 * Math.cos(2 * Math.PI * v);
            values.push(value);

            if (i < loopCount - 1)
            {
                //---- room for quick 2nd number ----
                value = term1 * Math.sin(2 * Math.PI * v);
                values.push(value);
            }
        }
    }
    else if (meth == "central-limit")
    {
        //--- generate 1 number at a time ----
        for (var i = 0; i < loopCount; i++)
        {
            //---- total next 12 random numbers ----
            var sum = Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() +
                Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random();

            var value = sum / 6;
            values.push(value);
        }
    }

    /// return scaler or array, depending on value of 'count' 
    return (count === undefined) ? values[0] : values;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// csv.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - converts a CSV (comma seperated file) into an array of json objects
///-----------------------------------------------------------------------------------------------------------------


/// converts a csv string (read from a csv file) into a json object.
vp.csvToJson = function (csv, hasHeader, sepChar, findTypes)
{
    var loader = vp.csvLoader(hasHeader, sepChar, findTypes);
    return loader.load(csv);
};

vp.csvLoader = function (hasHeader, sepChar, findTypes)
{
    //---- private state ----
    var colNames = [];
    var processedHdr = false;
    var lastLoadRemainder = "";
    var colCount = 0;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: load(csv)
    closure.load = function (csv, incrementalLoading)
    {
        var rows = [];
        var i = 0;      // char index into csv

        if (!processedHdr)
        {
            if (hasHeader)
            {
                //---- read first line containing column headers ----
                var colNum = 0;

                //---- process first line ----
                while ((i < csv.length) && (csv[i] != "\n"))
                {
                    var iStart = i;
                    //---- get next column name ----
                    while ((i < csv.length) && (csv[i] != sepChar) && (csv[i] != "\n"))
                    {
                        i++;
                    }

                    var colName = csv.substring(iStart, i);

                    //---- remove quotes around col names ----
                    if ((colName.startsWith("\"")) && (colName.endsWith("\"")))
                    {
                        colName = colName.substr(1, colName.length - 2);
                    }

                    colName = colName.trim();

                    colNames.push(colName);

                    if (csv[i] == sepChar)
                    {
                        i++;
                        colNum++;
                    }
                    else
                    {
                        if ((i < csv.length) && (csv[i] == "\n"))
                        {
                            i++;            // skip over newline at end of line
                        }
                        break;
                    }
                }
            }

            processedHdr = true;
        }

        if (incrementalLoading)
        {
            //---- append left over chars from last load ----
            csv = lastLoadRemainder + csv;
        }

        var lastRowOffset = 0;

        while (i < csv.length)
        {
            var row = null;

            var aray = csvLineToJsonRow(csv, i, sepChar, colNames);
            row = aray[0];
            i = aray[1];

            var isLastRowShort = false;
            var colsFound = vp.keys(row).length;

            if (colCount == 0)
            {
                colCount = colsFound;
            }
            else if (colsFound < colCount)
            {
                //---- short row - is it the last? ----
                if (i >= csv.length)
                {
                    isLastRowShort = true;
                }
            }

            if ((isLastRowShort) && (incrementalLoading))
            {
                lastLoadRemainder = csv.substr(lastRowOffset);
                break;
            }
            else
            {
                rows.push(row);
                lastRowOffset = i;
            }
        }

        //---- test each column to see if all numeric; if so, convert to numbers ----
        if ((findTypes) && (rows.length > 0))
        {
            var firstRow = rows[0];
            var keys = vp.keys(firstRow);

            //---- test each column ----
            for (var i = 0; i < keys.length; i++)
            {
                tryToConvertColToNativeType(rows, keys[i]);
            }
        }

        return rows;
    };

    var tryToConvertColToNativeType = function (rows, colName)
    {
        if (!tryToConvertColToBool(rows, colName))
        {
            /// since JavaScript cannot tell the difference between a DATE and a number reliably, don't auto convert to date.
            if (true)       // ! tryToConvertColToDate(rows, colName))
            {
                tryToConvertColToNumeric(rows, colName);
            }
        }
    };

    var tryToConvertColToNumeric = function (rows, colName)
    {
        var isNumeric = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName];

            var value = Number(str);
            if (isNaN(value))
            {
                isNumeric = false;
                break;
            }

            values.push(value);
        }

        if (isNumeric)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isNumeric;
    };

    var tryToConvertColToBool = function (rows, colName)
    {
        var isBool = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName].toLowerCase();

            if (str == "true")
            {
                values.push(true);
            }
            else if (str == "false")
            {
                values.push(false);
            }
            else
            {
                isBool = false;
                break;
            }

            values.push(value);
        }

        if (isBool)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isBool;
    };

    var tryToConvertColToDate = function (rows, colName)
    {
        var isDate = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName];

            var value = Date.parse(str);
            if (isNaN(value))
            {
                isDate = false;
                break;
            }

            values.push(value);
        }

        if (isDate)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isDate;
    };

    var csvLineToJsonRow = function (csv, i, sepChar, colNames)
    {
        //---- process next line (row) of data ----
        var colNum = 0;
        var row = {};

        while ((i < csv.length) && (csv[i] != "\n"))
        {
            //---- get next value ----
            var iStart = i;
            while ((i < csv.length) && (csv[i] != sepChar) && (csv[i] != "\n"))
            {
                i++;
            }

            var value = csv.substring(iStart, i);
            var colName = (colNum < colNames.length) ? colNames[colNum] : "col" + colNum;

            //---- remove quotes around values ----
            if ((value.startsWith("\"")) && (value.endsWith("\"")))
            {
                value = value.substr(1, value.length - 2);
            }

            row[colName] = value;


            if (csv[i] == sepChar)
            {
                i++;
                colNum++;
            }
            else
            {
                break;
            }
        }

        if ((i < csv.length) && (csv[i] == "\n"))
        {
            i++;            // skip over newline at end of line
        }

        return [row, i];
    };

    //---- init code ----
    if (hasHeader == null)
    {
        hasHeader = false;
    }

    if (sepChar == null)
    {
        sepChar = "\t";
    }

    var colNames = [];


    return closure;
};﻿///-----------------------------------------------------------------------------------------------------------------
/// curveFitting.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - curve fitting functions.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions in this file, unless specified otherwise, 
/// were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 11 Curve Fitting.  
///-----------------------------------------------------------------------------------------------------------------
vp.curveFitting = {};       // namespace object

vp.curveFitting.line = function (xa, ya)
{
    var values = [];

    if ((!xa) || (!xa.length) || (!ya) || (!ya.length))
    {
        vp.error("error - polyfit() requires X and Y number arrays");
    }

    if (xa.length != ya.length)
    {
        vp.error("error - polyfit() requires that X and Y be the same size");
    }

    var count = xa.length;
   
    //---- model: y = slope*x + intercept ----
    var xm = vp.average(xa);
    var ym = vp.average(ya);

    var btop = 0;
    var bbot = 0;

    for (var i = 0; i < count; i++)
    {
        btop += (ya[i] * (xa[i] - xm));
        bbot += (xa[i] * (xa[i] - xm));
    }

    var slope = btop / bbot;
    var intercept = ym - xm * slope;

    var sigma = 0;

    for (var i = 0; i < count; i++)
    {
        var t = ya[i] - intercept - (slope * xa[i]);
        sigma += t * t;
    }

    sigma = Math.sqrt(sigma / (count - 2));

    var ptFrom = { x: xa[0], y: slope * xa[0] + intercept };
    var ptTo = { x: xa[count - 1], y: slope * xa[count - 1] + intercept };

    values = { slope: slope, intercept: intercept, sigma: sigma, ptFrom: ptFrom, ptTo: ptTo };

    return values;
};

vp.matrix2d = function (rows, cols)
{
    var m = [];

    for (var i = 0; i < rows; i++)
    {
        var row = [];

        for (var j = 0; j < cols; j++)
        {
            row.push(0);
        }

        m.push(row);
    }

    return m;
};

vp.vector = function (cols)
{
    var row = [];

    for (var j = 0; j < cols; j++)
    {
        row.push(0);
    }

    return row;
};

//vp.curveFitting.linRegressPoly = function (xa, ya, degree)
//{
//    var f0 = function(x) {return 1;};
//    var f1 = function(x) {return x;};
//    var f2 = function(x) {return x*x;};
//    var f3 = function(x) {return x*x*x;};

//    var f = null;

//    if (degree == 1)
//    {
//        f = [f0, f1];
//    }
//    else if (degree == 2)
//    {
//        f = [f0, f1, f2];
//    }
//    else if (degree == 3)
//    {
//        f = [f0, f1, f2, f3];
//    }

//    var result = vp.curveFitting.linearRegression(xa, ya, f);
//    return result;
//};

/// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
vp.curveFitting.polyFit = function (xa, ya, degree)
{
    var m = degree + 1;
    var a = vp.matrix2d(m, m);
    var b = vp.vector(m);
    var n = xa.length;

    for (var k = 0; k < m; k++)
    {
        b[k] = 0;
        for (var i = 0; i < n; i++)
        {
            b[k] += Math.pow(xa[i], k) * ya[i];
        }
    }

    for (var j = 0; j < m; j++)
    {
        for (var k = 0; k < m; k++)
        {
            a[j][k] = 0;
            for (var i = 0; i < n; i++)
            {
                a[j][k] += Math.pow(xa[i], j + k);
            }
        }
    }

    var coef = vp.gaussJordan(a, b);

    //---- calculate the std deviation ----
    var s = 0;
    for (var i = 0; i < n; i++)
    {
        var s1 = 0;

        for (var j = 0; j < m; j++)
        {
            s1 += coef[j] * Math.pow(xa[i], j);
        }

        s += (ya[i] - s1) * (ya[i] - s1);
    }

    var sigma = Math.sqrt(s / (n - m));

    return { coef: coef, sigma: sigma };
};

/// "xa" are the x data values, "ya" are the y data values, "wa" are the weight values.
vp.curveFitting.weightedLinearRegression = function (xa, ya, wa)
{
    var n = xa.length;
    var xw = 0;
    var yw = 0;
    var b1 = 0;
    var b2 = 0;
    var a = 0;
    var b = 0;

    for (var i = 0; i < n; i++)
    {
        xw += xa[i] / n;
        yw = ya[i] / n;
    }

    for (var i = 0; i < n; i++)
    {
        b1 += wa[i] * wa[i] * ya[i] * (xa[i] - xw);
        //b2 += wa[i] * wa[i] * xa[i] * (xa[i] - xw);
        b2 += wa[i] * wa[i] * xa[i] * (ya[i] - yw);
    }

    b = b1 / b2;
    a = yw - xw * b;

    return {coef: [a, b] };
};

/// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
vp.curveFitting.exponentialFit = function (xa, ya)
{
    var logy = [];

    for (var i = 0; i < ya.length; i++)
    {
        logy[i] = Math.log(ya[i]);
    }

    var result = vp.curveFitting.weightedLinearRegression(xa, logy, ya);
    return result;
};

/// "xa" are the x data values, "ya" are the y data values, "f" is an array of model func (usually returns x**N).
vp.curveFitting.linearRegression = function (xa, ya, f)
{
    var m = f.length
    var a = vp.matrix2d(m, m);
    var b = vp.vector(m);
    var n = xa.length;

    for(var k=0; k < m; k++)
    {
        b[k] = 0;

        for(var i=0; i < n; i++)
        {
            var result = f[k](xa[i]);
            var term = result * ya[i];
            b[k] += term;
        }
    }

    for(var j=0; j < m; j++)
    {
        for(var k=0; k < m; k++)
        {
            a[j][k] = 0;

            for(var i=0; i < n; i++)
            {
                var result = f[j](xa[i]);
                var result2 = f[k](xa[i]);
                var term = result * result2;
                a[j][k] += term;
            }
        }
    }

    var coef = vp.gaussJordan(a, b);

    //---- calculate the std deviation ----
    var s = 0;
    for(var i =0; i < n; i++)
    {
        var s1 = 0;

        for(var j=0; j < m; j++)
        {
            s1 += coef[j] * f[j](xa[i]);
        }

        s+= (ya[i] - s1) * (ya[i] - s1);
    }

    var sigma = Math.sqrt(s / (n-m));

    return {coef: coef, sigma: sigma};
}

/// "a" is Matrix, "b" is array.
vp.gaussJordan = function (a, b)
{
    vp.triangulate(a, b);

    var n = b.length;
    var x = vp.vector(n);
     
    for (var i = n - 1; i >= 0; i--)
    {
        var d = a[i][i];

        if (Math.abs(d) < 1.0e-500)
        {
            vp.error("error: diagnoal element is too small for GaussJordan");
        }

        x[i] = (b[i] - vp.dotProduct(a[i], x)) / d;
    }

    return x;

};

/// "a" is array, "b" is array.
vp.dotProduct = function (a, b)
{
    var sum = 0;

    for (var i = 0; i < a.length; i++)
    {
        sum += a[i] * b[i];
    }

    return sum;
};

/// "a" is Matrix, "b" is array.
vp.triangulate = function (a, b)
{
    var n = a.length;
    var v = vp.vector(n);

    for (var i = 0; i < n - 1; i++)
    {
        var d = vp.pivot(a, b, i);

        if (Math.abs(d) < 1.0e-500)
        {
            vp.error("error: diagnoal element is too small for triangulate");
        }

        for (var j = i + 1; j < n; j++)
        {
            var dd = a[j][i] / d;
            for (var k = i + 1; k < n; k++)
            {
                a[j][k] -= dd * a[i][k];
            }

            b[j] -= dd * b[i];
        }
    }
};

/// "a" is Matrix, "b" is array, "q" in number.
vp.pivot = function (a, b, q)
{
    var n = b.length;
    var i = q;
    var d = 0;

    for(var j=q; j < n; j++)
    {
        var dd = Math.abs(a[j][q]);
        if (dd > d)
        {
            d = dd;
            i = j;
        }
    }

    if (i > q)
    {
        //---- swap rows "q" and "i" in a ----
        var temp = a[q];
        a[q] = a[i];
        a[i] = temp;

        //---- swap elements "q" and "i" in b ----
        temp = b[q];
        b[q] = b[i];
        b[i] = temp;
    }

    return a[q][q];
};

vp.curveFitting.spline = function (xx, yy)
{
    //---- convert xx,yy into points ----
    var points = xx.selectWithFunc(function (data, index)
    {
        return { x: xx[index], y: yy[index] };
    });

    var tension = .5;       // controls how smooth/sharp changes are at each point
    var tensions = null;
    var segments = [];

    if (points.length == 2)
    {
        if (tensions)
        {
            tension = tensions[0];
        }

        vp.addSplineSegment(segments, points[0], points[0], points[1], points[1], tension, tension);
    }
    else
    {
        for (var i = 0; i < points.length; i++)
        {
            var t1 = (tensions) ? tensions[i % tensions.length] : tension;
            var t2 = (tensions) ? tensions[(i + 1) % tensions.length] : tension;

            if (i == 0)
            {
                vp.addSplineSegment(segments, points[0], points[0], points[1], points[2], t1, t2);
            }
            else if (i == points.length - 2)
            {
                vp.addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 1], t1, t2);
            }
            else if (i != points.length - 1)
            {
                vp.addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 2], t1, t2);
            }
        }

    }

    return segments;
};

vp.addSplineSegment = function (segments, pt0, pt1, pt2, pt3, t1, t2)
{
    // adapted from Charles Petzold book:
    // See Petzold, "Programming Microsoft Windows with C#", pages 645-646 or 
    //     Petzold, "Programming Microsoft Windows with Microsoft Visual Basic .NET", pages 638-639
    // for derivation of the following formulas:

    var SX1 = t1 * (pt2.x - pt0.x);
    var SY1 = t1 * (pt2.y - pt0.y);
    var SX2 = t2 * (pt3.x - pt1.x);
    var SY2 = t2 * (pt3.y - pt1.y);

    var AX = SX1 + SX2 + 2 * pt1.x - 2 * pt2.x;
    var AY = SY1 + SY2 + 2 * pt1.y - 2 * pt2.y;
    var BX = -2 * SX1 - SX2 - 3 * pt1.x + 3 * pt2.x;
    var BY = -2 * SY1 - SY2 - 3 * pt1.y + 3 * pt2.y;

    var CX = SX1;
    var CY = SY1;
    var DX = pt1.x;
    var DY = pt1.y;

    var tolerance = .25;        // .25 is the standard tolerance for curve flattening (curve to lines)
    var num = Math.floor((Math.abs(pt1.x - pt2.x) + Math.abs(pt1.y - pt2.y)) / tolerance);

    var points = [];
    segments.push(points);

    // Notice begins at 1 so excludes the first point (which is just pt1)
    for (var i = 1; i < num; i++)
    {
        var t = i / (num - 1);

        var pt = {
            x: AX * t * t * t + BX * t * t + CX * t + DX,
            y: AY * t * t * t + BY * t * t + CY * t + DY
        };

        points.push(pt);
    }
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// dataAnimMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///   -part of the vuePlot library.
///   - manages a data source with respect to data changes, filtering, and related animation.
///-----------------------------------------------------------------------------------------------------------------
/// class: dataAnimMgr 
vp.dataAnimMgr = function (containerUW, pkFunc, appendSFCtor)
{
    //---- private state ----
    var enterShapes = [];           // new shapes for this data change
    var updateShapes = [];          // existing shapes for this data change
    var exitShapes = [];            // exiting shapes for this data change

    var container = ((containerUW) && (containerUW.length)) ? containerUW[0] : containerUW;
    var keys = {};                  // dict to map data to shape (by primary key + seriesIndex)
    var data = [];                  // the current set of data
    var masterAnim = null;          // the controlling animation for all ENTER/EXIT shapes
    var enterDataPairs = [];
    var pkCallback = pkFunc;
    var dataId = undefined;
    var seriesCount = 1;
    //var deferredSetDataCall = null;

    //---- property vars ----   
    var animDuration;               // in ms
    var animEasing;                 // ease obj
    var enterEffect;                // ENTER animation applied to ENTER shapes
    var exitEffect;                 // EXIT animation applied to EXIT shapes

    //---- closure ----
    var closure = function ()
    {
    };
    closure.ctr = "vp.dataAnimMgr";

    /// public: getData()
    //---- this has explict "get" signature because we need to specify "isNewDataSet" for setter ----
    closure.getData = function ()
    {
        return data;
    };

    /// do not assume that "container" has been set here - OK to create new shapes but don't append them yet.
    closure.setData = function (newData, isNewDataSet, newDataId, doNotDefer)
    {
        //if (!doNotDefer)
        //{
        //    if (newData)
        //    {
        //        newData = newData.clone();
        //    }

        //    //---- normal path thru is to defer, since we don't have the true value of "seriesCount" until we go thru plot.buildRecordDescriptions() ----
        //    deferredSetDataCall = { newData: newData, isNewDataSet: isNewDataSet, newDataId: newDataId };
        //    return;
        //}

        var existingShapes = updateShapes.concat(enterShapes);

        if (exitShapes.length > 0)
        {
            //---- about to overwrite exit shapes - remove them now ----
            closure.removeExitShapesNow(-1);
        }

        enterShapes = [];
        exitShapes = [];
        updateShapes = [];
        enterDataPairs = [];

        if ((isNewDataSet) || (animDuration == 0))
        {
            //---- get rid of all old items ----
            //if (container)
            //{
            //    vp.clear(container);
            //}

            keys = {};

            //---- put all new items on "enter" ----
            for (var i = 0; i < newData.length; i++)
            {
                var pair = { dataItem: newData[i], dataIndex: i };
                enterDataPairs.push(pair);
            }

            exitShapes = existingShapes;
        }
        else
        {
            //---- mark all existing elements as "not yet found" ----
            for (var i = 0; i < existingShapes.length; i++)
            {
                existingShapes[i].notYetFound = true;
            }

            //---- figure out split of new data into: enter, update groups ----
            for (var i = 0; i < newData.length; i++)
            {
                for (var s=0; s < seriesCount; s++)
                {
                    var key = getFullKey(newData[i], i, s);

                    var uelem = keys[key];
                    if (uelem == undefined)
                    {
                        var pair = { dataItem: newData[i], dataIndex: i };
                        enterDataPairs.push(pair);
                    }
                    else
                    {
                        uelem.notYetFound = false;

                        //---- update data/dataIndex fields to reflect data change ----
                        uelem.dataItem.data = newData[i];
                        uelem.dataIndex = i;

                        updateShapes.push(uelem);
                    }
                }
            }

            //---- move any elements that we didn't find in the new data into the "exit" elements ----
            for (var i = 0; i < existingShapes.length; i++)
            {
                var elem = existingShapes[i];

                if (elem.notYetFound === true)
                {
                    //---- remove key from keys ----
                    var key = getFullKey(elem.dataItem, elem.dataIndex, vp.shapeId(elem));
                    delete keys[key];

                    //---- update dataIndex to reflect that data is not in current data[] ----
                    elem.dataIndex = -(elem.dataIndex + 1);

                    exitShapes.push(elem);
                }
            }
        }

        data = newData;
        dataId = newDataId;

        return closure;
    };

    var createMultipleShapes = function (appendStrOrFunc, seriesCount, enterDataPairs)
    {
        var elements = [];
        var start = +Date.now();
        var count = seriesCount * enterDataPairs.length;

        if (appendStrOrFunc == null)
        {
            appendStrOrFunc = appendSFCtor;
        }

        if (vp.isFunction(appendStrOrFunc))
        {
            for (var s = 0; s < seriesCount; s++)
            {
                for (var i = 0; i < enterDataPairs.length; i++)
                {
                    var pair = enterDataPairs[i];

                    var elem = appendStrOrFunc(pair.dataItem, pair.dataIndex, s, data);
                    elements.push(elem);
                }
            }
        }
        else if (appendStrOrFunc)
        {
            //---- perf win for CREATE ----
            elements = vp.createElements(container, appendStrOrFunc, count);
        }

        var createElapsed = +Date.now() - start;
        var start = +Date.now();

        //---- perf win for APPEND ----
        vp.appendElements(container, elements);
        var appendElapsed = +Date.now() - start;

        return elements;
    }


    /// private: createShape()
    var createShape = function (appendStrOrFunc, dataRecord, index, key, seriesIndex)
    {
        var uelem = null;

        if (appendStrOrFunc == null)
        {
            appendStrOrFunc = appendSFCtor;
        }

        if (vp.isFunction(appendStrOrFunc))
        {
            uelem = appendStrOrFunc(dataRecord, index, seriesIndex, data);
        }
        else if (appendStrOrFunc)
        {
            uelem = vp.createElement(container, appendStrOrFunc);
        }

        if (uelem != null)
        {
            vp.append(container, uelem);

            // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord };
            var dataItemEx = { dataId: 1, shapeId: seriesIndex, key: key, data: dataRecord };

            uelem.dataItem = dataItemEx;
            uelem.dataIndex = index;
        }

        return uelem;
    };

    closure.createEnterShapesIfNeeded = function (seriesCount, appendStrOrFunc)
    {
        if (enterDataPairs.length > 0)
        {
            var start = +Date.now();
            enterShapes = createMultipleShapes(appendStrOrFunc, seriesCount, enterDataPairs);
            var multiElapsed = +Date.now() - start;
            var shapeIndex = 0;

            var start = +Date.now();

            //---- create shapes for all series NOW ----
            for (var s = 0; s < seriesCount; s++)
            {
                //---- loop thru all ENTER pair objects ----
                for (var i = 0; i < enterDataPairs.length; i++)
                {
                    var pair = enterDataPairs[i];
                    var pk = getPrimaryKey(pair.dataItem, pair.dataIndex);

                    var uelem = enterShapes[shapeIndex++];
                    //var uelem = createShape(appendStrOrFunc, pair.dataItem, pair.dataIndex, pk, s);
                    //enterShapes.push(uelem);

                    // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord };
                    var dataItemEx = { dataId: 1, shapeId: s, key: pk, data: pair.dataItem };

                    uelem.dataItem = dataItemEx;
                    uelem.dataIndex = pair.dataIndex;

                    var key = getFullKey(pair.dataItem, pair.dataIndex, s, pk);
                    keys[key] = uelem;
                }
            }

            var propsElapsed = +Date.now() - start;
            enterDataPairs = [];
        }
    };


    /// public: updateShapes()
    closure.updateShapes = function (seriesIndex, totalSeries, callBack, appendStrOrFunc)
    {
        seriesCount = totalSeries;

        //if (deferredSetDataCall)
        //{
        //    var sdc = deferredSetDataCall;
        //    deferredSetDataCall = null;

        //    closure.setData(sdc.newData, sdc.isNewDataSet, sdc.newDataId, true);
        //}

        var shapesTouched = [];

        if (seriesIndex == 0)
        {
            masterAnim.clear();
        }

        var start = +Date.now();
        closure.createEnterShapesIfNeeded(seriesCount, appendStrOrFunc);
        var enterElapsed = +Date.now() - start;
        var start = +Date.now();

        //---- update NEW shapes WITHOUT animation ----
        for (var i = 0; i < enterShapes.length; i++)
        {
            var uelem = enterShapes[i];
            var shapeId = vp.shapeId(uelem);

            if (shapeId == seriesIndex)
            {
                vp.animate(uelem, 0);               // turn off animation for this shape

                callBack(uelem, uelem.dataItem, uelem.dataIndex, true);

                shapesTouched.push(uelem);
            }
        }

        var noAnimElapsed = +Date.now() - start;
        var start = +Date.now();

        //---- update EXISTING shapes WITH animation ----
        for (var i = 0; i < updateShapes.length; i++)
        {
            var uelem = updateShapes[i];

            if (vp.shapeId(uelem) == seriesIndex)
            {
                vp.animate(uelem, animDuration, animEasing, masterAnim);

                callBack(uelem, uelem.dataItem, uelem.dataIndex, false);

                shapesTouched.push(uelem);
            }
        }

        var animElapsed = +Date.now() - start;
        var start = +Date.now();

        if (animDuration)
        {
            //---- create ENTER animations ----
            if (enterEffect)
            {
                for (var i = 0; i < enterShapes.length; i++)
                {
                    var uelem = enterShapes[i];

                    if (vp.shapeId(uelem) == seriesIndex)
                    {
                        var anim = vp.animation(uelem, animDuration, animEasing, masterAnim);

                        anim.applyEnterEffect(uelem, enterEffect);
                    }
                }
            }

            //---- create EXIT animations ----
            // CHW: make sure to call deleteElementsOnCompleted even if no exit effect; also make that duration 0ms

            //---- go thru list backwards, removing entries as we find seriesIndex matches ----
            for (var i = exitShapes.length - 1; i >= 0; i--)
            {
                var uelem = exitShapes[i];

                if (vp.shapeId(uelem) == seriesIndex)
                {
                    if (exitEffect)
                    {
                        var anim = vp.animation(uelem, animDuration, animEasing, masterAnim);

                        anim.applyExitEffect(uelem, exitEffect);
                        anim.deleteElementsOnCompleted(uelem);
                    }
                    else
                    {
                        var anim = vp.animation(uelem, 0, animEasing, masterAnim);

                        anim.deleteElementsOnCompleted(uelem);
                    }

                    exitShapes.removeAt(i);
                }
            }
        }
        else
        {
            closure.removeExitShapesNow(seriesIndex);
        }

        var deleteElapsed = +Date.now() - start;

        //---- return all shapes now in plot for this dataAnimMgr / seriesIndex ----
        return vp.wrapElements(shapesTouched);       //vp.wrapElements(enterShapes.concat(updateShapes));
    };

    closure.removeExitShapesNow = function (seriesIndex)
    {
        //---- no animation, so remove EXIT shapes now ----

        //---- go thru list backwards, removing entries as we find seriesIndex matches ----
        for (var i = exitShapes.length-1; i >= 0; i--)
        {
            var uelem = exitShapes[i];

            if ((seriesIndex == -1) || (vp.shapeId(uelem) == seriesIndex))
            {
                vp.remove(uelem);
                exitShapes.removeAt(i);
            }
        }

        //exitShapes = [];
    };

    // CHW: new method
    closure.lookupElement = function (dataItem, dataIndex, seriesIndex)
    {
        var key = getFullKey(dataItem, dataIndex, seriesIndex);
        return keys[key];
    }

    /// private: getPrimaryKey()
    var getPrimaryKey = function (dataItem, dataIndex)
    {
        var key = dataIndex;

        if (dataItem.key)
        {
            key = dataItem.key;
        }
        else if (pkCallback)
        {
            key =  pkCallback(dataItem, dataIndex);
        }

        return key;
    };

    /// private: getFullKey()
    var getFullKey = function (dataItem, dataIndex, seriesIndex, key)
    {
        if (!key)
        {
            key = getPrimaryKey(dataItem, dataIndex);
        }

        key += "+" + seriesIndex;

        return key;
    };


    /// public property: animDuration
    closure.animDuration = function (value)
    {
        if (arguments.length === 0)
        {
            return animDuration;
        }

        //---- setter ----
        animDuration = value;
        return closure;
    };

    /// public property: animEasing
    closure.animEasing = function (value)
    {
        if (arguments.length === 0)
        {
            return animEasing;
        }

        //---- setter ----
        animEasing = (value === true) ? new vp.powEase(2) : value;
        return closure;
    };

    /// public property: enterEffect
    closure.enterEffect = function (value)
    {
        if (arguments.length === 0)
        {
            return enterEffect;
        }

        //---- setter ----
        enterEffect = value;
        return closure;
    };

    /// public property: exitEffect
    closure.exitEffect = function (value)
    {
        if (arguments.length === 0)
        {
            return exitEffect;
        }

        //---- setter ----
        exitEffect = value;
        return closure;
    };

    /// public property: container
    closure.container = function (value)
    {
        if (arguments.length === 0)
        {
            return container;
        }

        //---- setter ----
        container = ((value) && (value.length)) ? value[0] : value;

        return closure;
    };

    /// public property: dataId
    closure.dataId = function (value)
    {
        if (arguments.length === 0)
        {
            return dataId;
        }

        //---- setter ----
        dataId = value;

        return closure;
    };

    /// public property: keyFunc
    closure.keyFunc = function (value)
    {
        if (arguments.length === 0)
        {
            return pkCallback;
        }

        //---- setter ----
        pkCallback = value;

        //---- todo: how do we update the keys of our shapes? ----

        return closure;
    };

    /// public: getExistingShapes()
    closure.getExistingShapes = function (value)
    {
        return enterShapes.concat(updateShapes);
    };

    //---- init code ----
    animDuration = 1000;
    animEasing = new vp.powEase(2);
    masterAnim = vp.animationContainer();

    if (pkCallback === undefined)
    {
        //---- provide default key callback ----
        pkCallback = vp.indexKeyFunc;
    }

    enterEffect = vp.makeEffects(vp.fadeType.none, vp.slideLoc.right);
    exitEffect = vp.makeEffects(vp.fadeType.none, vp.slideLoc.left);

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// dataBinder.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
//
//---- warning: "dataBinder()" is now obsolete.   use "dataAnimMgr" instead. ----
//
vp.dataBinder = function (container, data, pkFunc, isNewData)
{
    //alert("container=" + container);
    var wrappedElements = vp.select();      // conbination of elements from ENTER and UPDATE
    var exitWrappedElements = vp.select();
    var enterDataPairs = [];                // consists of dataPairHolder records
    var keys = {};

    //---- closure ----
    var closure = function () 
    {
    };
    closure.ctr = "vp.dataBinder";

    /// READONLY public: container
    closure.container = container;

    /// public: enter()
    closure.enter = function ()
    {
        var dws = vp.dataWrapperSet(closure, enterDataPairs);
        return dws;
    };

    /// public: update()
    closure.update = function ()
    {
        wrappedElements.id = "wrappedElements";
        return wrappedElements;
    };

    /// public: exit()
    closure.exit = function ()
    {
        return exitWrappedElements;
    };

    /// public: each()
    //---- each function signature: callBack(action, dataPairHolder, element) ----
    closure.each = function (callBack)
    {
        var enterElems = [];

        //---- ENTER items ----
        for (var i = 0; i < enterDataPairs.length; i++)
        {
            var dataPairHolder = enterDataPairs[i];
            var enterElem = callBack(vp.bindAction.enter, dataPairHolder, null);
            if (enterElem != null)
            {
                enterElem.dataItem = dataPairHolder.dataItem;
                enterElem.dataIndex = dataPairHolder.dataIndex;

                enterElems.push(enterElem);
            }
        }

        //---- update "wrappedElements" with newly created elements ----
        if (enterElems.length > 0)
        {
            closure.mergeEnterSet(enterElems);
        }

        //---- UPDATE items ----
        for (var i = 0; i < wrappedElements.length; i++)
        {
            var elem = wrappedElements[i];
            var dataPairHolder = new vp.dataPairHolder(elem.dataItem, elem.dataIndex);

            callBack(vp.bindAction.update, dataPairHolder, elem);
        }

        //---- EXIT items ----
        for (var i = 0; i < exitWrappedElements.length; i++)
        {
            var elem = exitWrappedElements[i];
            var dataPairHolder = new vp.dataPairHolder(elem.dataItem, elem.dataIndex);

            callBack(vp.bindAction.exit, dataPairHolder, exitWrappedElements[i]);
        }
    };

    /// private: getKey()
    var getKey = function (dataItem, dataIndex)
    {
        var pk = dataIndex;     // row index

        if (vp.isFunction(pkFunc))
        {
            pk = pkFunc(dataItem);
        }

        return pk;
    }

    /// public: setData()
    closure.setData = function (data, pkFunc, isNewData)
    {
        enterDataPairs = [];
        pkFunc = pkFunc;

        if (isNewData)
        {
            //---- get rid of all old items ----
            exitWrappedElements = wrappedElements;
            wrappedElements = vp.select();
            keys = {};

            //---- put all new items on "enter" ----
            for (var i = 0; i < data.length; i++)
            {
                var dataPairHolder = new vp.dataPairHolder(data[i], i);
                enterDataPairs.push(dataPairHolder);
            }
        }
        else
        {
            //---- mark all existing elements as "not yet found" ----
            for (var i = 0; i < wrappedElements.length; i++)
            {
                wrappedElements[i].notYetFound = true;
            }

            //---- figure out split of new data into: enter, update groups ----
            var updateElements = [];
            var exitElements = [];

            for (var i = 0; i < data.length; i++)
            {
                var pk = getKey(data[i], i);

                var element = keys[pk];
                if (element == undefined)
                {
                    var dataPairHolder = new vp.dataPairHolder(data[i], i);
                    enterDataPairs.push(dataPairHolder);
                }
                else
                {
                    element.notYetFound = false;

                    //---- update data/dataIndex fields to reflect data change ----
                    element.dataItem = data[i];
                    element.dataIndex = i;

                    updateElements.push(element);
                }
            }

            //---- move any elements that we didn't find in the new data into the "exit" elements ----
            for (var i = 0; i < wrappedElements.length; i++)
            {
                var elem = wrappedElements[i];

                if (elem.notYetFound == true)
                {
                    //---- remove key from keys ----
                    var pk = getKey(elem.dataItem, elem.dataIndex);
                    delete keys[pk];

                    //---- update dataIndex to reflect that data is not in current data[] ----
                    elem.dataIndex = -(elem.dataIndex + 1);

                    exitElements.push(elem);
                }
            }

            //---- now, wrap our 2 main arrays ----
            wrappedElements = vp.select(updateElements);
            exitWrappedElements = vp.select(exitElements);
        }
    };

    /// public: mergeEnterSet()
    closure.mergeEnterSet = function (enterSet)
    {
        //---- first, merge in the keys from enterSet ----
        for (var i = 0; i < enterSet.length; i++)
        {
            var element = enterSet[i];

            var pk = getKey(element.dataItem, element.dataIndex);
            keys[pk] = enterSet[i];
        }

        //---- now, merge the wrapped elements ----
        wrappedElements = wrappedElements.merge(enterSet);
    };

    //---- init code ----
    closure.setData(data, pkFunc, isNewData);

    return closure;

};

﻿///-----------------------------------------------------------------------------------------------------------------
/// dataFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - data-related functions.
///-----------------------------------------------------------------------------------------------------------------
/// format a number nicely (shortest decimal possible, add commas for thousands).
vp.format = function (value)
{
    if (vp.isNumber(value))
    {
        value = vp.formatters.comma(value);
    }

    return value;
};

/// test each value in data - if at least one can be converted to a valid number, 
/// return true; otherwise return false;
vp.isDataNumeric = function (data)
{
    var numberCount = 0;

    if (data.length)
    {
        for (var i = 0; i < data.length; i++)
        {
            var value = data[i];

            if (vp.isString(value))
            {
                value = value.trim();
                if (value == "")
                {
                    continue;
                }

                value = +value;
            }

            if (!isNaN(value))
            {
                numberCount++;
            }

            if (numberCount > 0)
            {
                break;
            }
        }
    }

    return (numberCount > 0);
};

vp.isNanOrBlank = function (value)
{
    var isNob = false;

    if (vp.isString(value))
    {
        value = value.trim();
        if (value == "")
        {
            isNob = true;
        }
    }

    if ((! isNob) && (isNaN(+value)))
    {
        isNob = true;
    }

    return isNob;
};

vp.nanCount = function (origData)
{
    var count = 0;

    for (var i=0; i < origData.length; i++)
    {
        var value = origData[i];

        if (vp.isNanOrBlank(value))
        {
            count++;
        }
    }

    return count;
};

vp.cleanData = function (origData, cleanValue)
{
    var newData = origData.selectWithFunc(function (data, index)
    {
        var value = +data;
        if (isNaN(value))
        {
            value = cleanValue;
        }

        return value;
    });

    return newData;
};﻿///-----------------------------------------------------------------------------------------------------------------
/// dataTransfer.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - functions to read and write data from URL's.
///-----------------------------------------------------------------------------------------------------------------

/// starts a async download of text from the specified url.  if "isJson" is true,
/// the data is requested in json format.  when the download is finished, either
/// successFunc or failFunc is called, with the param "xmlhttp".
///
/// if this is a file on a server, the true text is returned in xmlhttp.responseText.  if text is XML,
/// the XML document object is available in xmlhttp.responseXML.


vp.httpRead = function (url, isJson, successFunc, failFunc, callAsync)
{
    callAsync = (callAsync === undefined) ? true : callAsync;

    var xmlhttp = vp.createXMLHttpRequest();
    xmlhttp.open("GET", url, callAsync);

    if (isJson)
    {
        xmlhttp.setRequestHeader("accept", "application/json");
    }

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send();
};


vp.pagePath = function (getServicePrefix)
{
    var pagePath = window.location.href;

    //---- first, remove any parameters ----
    var index = pagePath.indexOf("?");
    if (index > -1)
    {
        pagePath = pagePath.substr(0, index);
    }

    //---- now, remove the page name ----
    index = pagePath.lastIndexOf("/");
    if (index > 0)
    {
        pagePath = pagePath.substr(0, index);

        if (getServicePrefix)
        {
            //---- remove next path near top (todo: remove all paths until top) ----
            index = pagePath.lastIndexOf("/");
            if (index > 0)
            {
                pagePath = pagePath.substr(0, index);
            }
        }
    }

    return pagePath;
};

vp.httpReadIncremental = function (url, isJson, offset, maxSize, successFunc, failFunc, callAsync)
{
    var pagePath = vp.pagePath(false);
    var servicePath = vp.pagePath(true);

    if (url.startsWith(".."))
    {
        url = pagePath + "/" + url;
    }

    //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
    var serviceUrl = servicePath + "/Service/Service1.asmx/IncrementalDownload";

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.httpRead(serviceUrl + "?url=" + url + "&offset=" + offset + "&maxSize=" + maxSize, false, function (xmlhttp)
    {
        if (successFunc)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

            successFunc(data);
        }
    },
        failFunc);
};


vp.writeFileText = function(fn, text, successCallback, failureCallback)
{
    var serverPath = vp.pagePath(true);
    var serviceUrl = serverPath + "/Service/Service1.asmx/writeFileText";

    var fullUrl = serviceUrl;
    var finalUrl = encodeURI(fullUrl);

    //alert("posting to url: " + finalUrl);

    var body = "fn=" + fn + "&text=" + text;
    body += "&timestamp=" + Date.now();         // add time to disable caching

    vp.httpPost(finalUrl, body, function (xmlhttp)
    {
        if (successCallback)
        {
            successCallback(xmlhttp);
        }
    },
    function (e)
    {
        if (failureCallback)
        {
            failureCallback(e);
        }
    }, false);
}

/// <summary>
/// Write an HTML file and its associated JavaScript/TypeScript file to the server's
/// "GeneratedPages" directory. 
/// </summary>
vp.writeFilePair = function (html, script, isTypeScript, successCallback, failureCallback)
{
    var serverPath = vp.pagePath(true);
    var serviceUrl = serverPath + "/Service/Service1.asmx/writeFilePair";

    var fullUrl = serviceUrl; 
    var finalUrl = encodeURI(fullUrl);

    var safeHtml = encodeURIComponent(html);
    var safeScript = encodeURIComponent(script);

    //alert("posting to url: " + finalUrl);

    var body = "?html=" + safeHtml + "&script=" + safeScript + "&isTypeScript=" + isTypeScript;
    body += "&timestamp=" + Date.now();         // add time to disable caching

    vp.httpPost(finalUrl, body, function (xmlhttp)
    {
        if (successCallback)
        {
            successCallback(xmlhttp);
        }
    },
    function (e)
    {
        if (failureCallback)
        {
            failureCallback(e);
        }
    }, false);

}


/// starts a async upload of text to the specified url.
vp.httpPost = function (url, stringToSend, successFunc, failFunc)
{
    var xmlhttp = vp.createXMLHttpRequest();
    xmlhttp.open("POST", url, true);

    xmlhttp.setRequestHeader("contentType", "application/x-www-form-urlencoded");

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send(stringToSend);
};

/// convert a XmlHttp responseXML to a json object.
vp.getJsonFromResponseXml = function (responseXML)
{
    var data = null;

    var node = responseXML.lastChild;
    if (node)
    {
        var str = (node.text) ? node.text : node.textContent;
        var data = null;

        try
        {
            data = JSON.parse(str);        // eval('(' + str + ')');
        }
        catch (ex)
        {
            //---- for debugging, try 1 record at a time, so we can see where the problem is ----
            if (str[0] == '[')
            {
                var index = 1;
                var recNum = 0;

                while (true)
                {
                    var start = str.indexOf('{', index);
                    if (start > -1)
                    {
                        var stop = str.indexOf('},', start + 1);
                        if (stop > -1)
                        {
                            var recStr = str.substr(start, stop - start + 1);
                            var jd = JSON.parse(recStr);
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }

                    recNum++;
                    index = stop + 1;
                }

                var a = 9;
            }
        }

        if ((data) && (data.d))
        {
            data = data.d;      // for json data
        }
    }

    return data;
};

/// convert an XmlHttp responseText to a json object.
vp.getJsonFromResponse = function (txt)
{
    var data = null;

    //var data = eval('(' + responseText + ')');

    var xmlStringPrefix = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<string xmlns=\"http://tempuri.org/\">";

    if (txt.startsWith(xmlStringPrefix))
    {
        txt = txt.substr(xmlStringPrefix.length);
        txt = txt.substr(0, txt.length - 9);        // remove "</string>" at end
    }
    else if (txt.startsWith("d:"))      // prefix appended by AspNetService (asp.net page)
    {
        txt = txt.substr(2);
    }

    var data = JSON.parse(txt);
    if (data.d)
    {
        data = data.d;      // for json data
    }

    return data;
};


///
/// download text data from a URL, using a specific service that is expected to
/// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadText
///
/// This is to get around problem "cross origin resource sharing".
///
vp.httpReadViaService = function (url, isJson, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
    serviceUrl = pagePath + "/Service/Service1.asmx/DownloadText";

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.httpRead(serviceUrl + "?url=" + url + "&isJson=" + isJson, isJson, function (xmlhttp)
    {
        if (successFunc)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

            successFunc(data);
        }
    },
        failFunc);
};

///
/// download JSON data from a SQL database.  
///
vp.httpReadSqlData = function (server, dbName, tableName, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    var serviceUrl = pagePath + "/Service/Service1.asmx/GetSqlData";
    //var serviceUrl = "/Service/Service1.asmx/GetSqlData";
    serviceUrl += "?server=" + server + "&dbName=" + dbName + "&tableName=" + tableName;

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.httpRead(serviceUrl, true,
        function (xmlhttp)
        {
            if (successFunc)
            {
                var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

                successFunc(data);
            }
        },
        function (xmlhttp)
        {
            if (failFunc)
            {
                failFunc(xmlhttp);
            }
        });
};

///
/// download names of tables in specified SQL database.  
///
vp.httpReadSqlTableNames = function (server, dbName, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    var serviceUrl = pagePath + "/Service/Service1.asmx/GetSqlTables";
    serviceUrl += "?server=" + server + "&dbName=" + dbName;

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.httpRead(serviceUrl, true,
        function (xmlhttp)
        {
            if (successFunc)
            {
                var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

                successFunc(data);
            }
        },
        function (xmlhttp)
        {
            if (failFunc)
            {
                failFunc(xmlhttp);
            }
        });
};

/// starts a async download of text from the specified url, using the "XDomainRequest" object which
/// is designed to work across domains.  To use this, the hosting service that supplys the data
/// must explictly support cross domain reads (by reading & writing certain headers).
///
/// if "isJson" is true, the data is requested in json format.  when the download is finished, either
/// successFunc or failFunc is called, with the param "xmlhttp".
vp.httpCrossDomainRead = function (url, isJson, successFunc, failFunc)
{
    if (window.XDomainRequest)
    {
        var xdr = new XDomainRequest();

        if (isJson)
        {
            xdr.setRequestHeader("accept", "application/json");
        }

        xdr.onload = function (xdr)
        {
            if (successFunc != null)
            {
                var data = null;

                //if (isJson)
                //{
                //    data = vp.getJsonFromResponseXml(xdr.responseXML);
                //}
                //else
                //{
                //    data = xdr.responseText;        // xmlhttp.xmlText;
                //}

                successFunc(xdr);
            }
        };

        xdr.ontimeout = function (ep)
        {
            alert("xdr.timeout");
        };

        xdr.onprogress = function (ep)
        {
            alert("xdr.timeout");
        };

        xdr.onerror = function (ep, ex)
        {
            if (failFunc != null)
            {
                failFunc(xdr);
            }
        };

        xdr.timeout = 99000;

        xdr.open("GET", url);
        xdr.send();
    }
    else
    {
        vp.error("XDomainRequest API not supported by this browser");
    }
};

/// reads OData data from the specified url.
vp.oDataRead = function (url, isJson, successFunc, failFunc)
{
    vp.httpReadViaService(url, isJson, function (data)
    {
        if (successFunc)
        {
            if ((data) && (data.results))
            {
                data = data.results;
            }

            successFunc(data);
        }
    }, failFunc);
};

/// reads all of the OData data from the specified url (adding parameters to the URL to
/// read each block of data).
vp.oDataReadAll = function (url, byCount, isJson, successFunc, failFunc)
{
    if (byCount == null)
    {
        byCount = 1000;
    }

    this.error = false;
    this.data = [];
    this.total = 0;
    this.byCount = byCount;
    var self = this;

    this.readMore = function ()
    {
        vp.oDataRead(url + "?$skip=" + self.total + "&$top=" + self.byCount, true,

            function (dataChunk)     // success func
            {
                var chunkSize = dataChunk.length;
                if (chunkSize > 0)
                {
                    self.byCount = chunkSize;

                    self.data = self.data.concat(dataChunk);
                    self.total = self.data.length;

                    self.readMore();
                }
                else
                {
                    if (successFunc != null)
                    {
                        successFunc(self.data);
                    }
                }
            },

            function (xmlhttp)      // failure func
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }

                self.error = true;
            }
        );
    };

    this.readMore();
};

/// create a instance of the XMLHttpRequest object.
vp.createXMLHttpRequest = function ()
{
    var req = null;

    if (XMLHttpRequest != null)
    {
        req = new XMLHttpRequest();
    }
    else
    {
        req = new ActiveXObject("Microsoft.XMLHTTP");
    }

    return req;
}

vp.pathHelper = function(nodeName)
{
    var getServicePrefix = true;
    var serverPath = window.location.href;

    //---- try easy one first ----
    if (serverPath.startsWith("http://localhost"))
    {
        serverPath = "http://localhost/" + nodeName;
    }
    else
    {
        //---- first, remove any parameters ----
        var index = serverPath.indexOf("?");
        if (index > -1)
        {
            serverPath = serverPath.substr(0, index);
        }

        //---- now, remove the page name ----
        index = serverPath.lastIndexOf("/");
        if (index > 0)
        {
            serverPath = serverPath.substr(0, index);

            if (getServicePrefix)
            {
                //---- remove LAST NODE ----
                index = serverPath.lastIndexOf("/");
                if (index > 0)
                {
                    serverPath = serverPath.substr(0, index);
                }

                //---- remove 2nd LAST NODE ----
                index = serverPath.lastIndexOf("/");
                if (index > 0)
                {
                    serverPath = serverPath.substr(0, index);
                }

                //---- both DEV and RELEASE machines now use nodeName ----
                serverPath += "/" + nodeName;
            }
        }
    }

    return serverPath;
}

vp.bigDataPath = function (fn)
{
    //var path = vp.pathHelper("VueBigData");
    var hostName = (window.location.hostname) ? window.location.hostname : "localhost";

    fn = "http://" + hostName + "/VueBigData/" + fn;

    return fn;
}﻿///-----------------------------------------------------------------------------------------------------------------
/// dataUtils.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
//---- class: dataPairHolder ----
//----      holds a data item and its data index ----
vp.dataPairHolder = function (dataItem, dataIndex)
{
    this.dataItem = dataItem;
    this.dataIndex = dataIndex;
};

vp.indexKeyFunc = function (dataRecord, index)
{
    return index;
};

vp.dataRepeat = function (value, count)
{
    var values = [];

    for (var i = 0; i < count; i++)
    {
        values[i] = value;
    }

    return values;
};

vp.lerp = function(percent, a, b)
{
    return a + percent * (b - a);
}

vp.generateItems = function (root, tagName, data)
{
    var elemArray = [];

    var start = new Date();

    if (root.multiAppend)
    {
        elemArray = root.multiAppend(tagName, data.length);

        for (var i = 0; i < elemArray.length; i++)
        {
            var elem = elemArray[i];

            var dataItem = data[i];

            vp.dataItem(elem, dataItem);
            vp.dataIndex(elem, i);
        }
    }
    else
    {
        for (var i = 0; i < data.length; i++)
        {
            //---- this does the right thing for canvas, SVG, and HTML elements ----
            var elem = root.append(tagName);

            var dataItem = data[i];

            elem.dataItem(dataItem); 
            elem.dataIndex(i);

            elemArray.push(elem[0]);
        }
    }

    var elapsed = new Date() - start;
    //alert("append of " + data.length + " elements took: " + elapsed + "ms");

    var ss = vp.wrapElements(elemArray);
    return ss;
};

/// public: dataJoin(data, "name", data2, "name2", ...)
/// this joins the data in each array into a new array, with each field given the associated name.
vp.dataJoin = function (data, name1)
{
    var records = [];

    for (var i = 0; i < data.length; i++)
    {
        //---- loop thru all the fields and create a record ----
        var record = {};

        for (var a = 0; a < arguments.length; a += 2)
        {
            var dataX = arguments[a];
            var nameX = arguments[a + 1];

            var valueX = dataX[i];

            record[nameX] = valueX;
        }

        records.push(record);
    }

    return records;
};

/// public: $.dataFrame(desc)
/// this builds an array of records whose name/vector pairs are given as key/values of the desc object.
vp.dataFrame = function (desc)
{
    var records = [];
    var firstVector = null;

    for (var k in desc)
    {
        firstVector = desc[k];
        break;
    }

    if (firstVector)
    {
        for (var i = 0; i < firstVector.length; i++)
        {
            //---- loop thru all the fields and create a record ----
            var record = {};

            for (var name in desc)
            {
                record[name] = desc[name][i];
            }

            records.push(record);
        }
    }

    return records;
};

/// public: dataSelect(data, fieldName)
/// "data" is an array of records.
/// "fieldName" is the name of one of the record's fields.
/// returns an array of "fieldName" values (one entry from each record in data).
vp.dataSelect = function (data, field)
{
    var values = [];        // empty array, by default

    if (!field)
    {
        //---- if no field specified, just return the data as is ----
        values = data;
    }
    else if (data.length > 0)
    {
        var firstRecord = data[0];
        if (firstRecord[field] !== undefined)
        {
            values = data.selectWithFunc(function (data, index) { return data[field]; });
        }
    }

    return values;
}

﻿///-----------------------------------------------------------------------------------------------------------------
/// dataWrapperSet.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
//---- class: dataWrapperSet ----
//----      "dataPairs" is an array of dataPair objects ----
vp.dataWrapperSet = function (dataBinder, dataPairs)
{
    //---- private state ----
    var container = dataBinder.container;

    /// closure
    var closure = function ()
    {
    };
    closure.ctr = "vp.dataWrapperSet";

    ///
    /// timing: append(10,000) took 553ms on roland's home machine (3/23/2012):
    ///     - createElementNS("rect")   - 3ms
    ///     - wrappedElement()          - 4ms
    ///     - container.append()        - 143ms

    /// these very expensive calls have been replaced by simple attribute settings:
    ///     - wrappedElement.data(first)     - 140ms
    ///     - wrappedElement.data(second)    - 110ms

    /// this very expensive call in-loop call has been replaced by building an array
    /// of elements and then wrapping them at the end:
    ///     - wrappedSet = wrappedSet.add(wrappedElement)     - 10 secs!
    ///

    /// public: append(stringOrFunc)
    closure.append = function (stringOrFunc)
    {
        //var startTime = new Date().getTime();
        var elementArray = [];
        elementArray[dataPairs.length - 1] = null;        // create array the size we need it

        for (var i = 0; i < dataPairs.length; i++)
        {
            var dataPairHolder = dataPairs[i];
            var element = null;

            if (vp.isFunction(stringOrFunc))
            {
                element = stringOrFunc(dataPairHolder.dataItem, dataPairHolder.dataIndex);
            }
            else
            {
                element = document.createElementNS('http://www.w3.org/2000/svg', stringOrFunc);
            }

            if (element != null)
            {
                elementArray[i] = element;

                element.dataItem = dataPairHolder.dataItem;
                element.dataIndex = dataPairHolder.dataIndex;
            }
        }

        var wrappedSet = vp.select(elementArray);
        container.append(wrappedSet);

        dataBinder.mergeEnterSet(wrappedSet);

        //var elapsedMs = new Date().getTime() - startTime;
        return wrappedSet;
    };

    /// public: each(eachFunc)
    //---- each function signature: eachFunc(dataItem, index) ----
    closure.each = function (eachFunc)
    {
        var elementArray = [];
        elementArray[dataPairs.length - 1] = null;        // create array the size we need it

        for (var i = 0; i < dataPairs.length; i++)
        {
            var dataPairHolder = dataPairs[i];

            var element = eachFunc(dataPairHolder.dataItem, dataPairHolder.dataIndex);

            if (element != null)
            {
                elementArray[i] = element;

                element.dataItem = dataPairHolder.dataItem;
                element.dataIndex = dataPairHolder.dataIndex;
            }

        }

        var wrappedSet = vp.select(elementArray);

        dataBinder.mergeEnterSet(wrappedSet);

        //var elapsedMs = new Date().getTime() - startTime;
        return wrappedSet;
    };

    //---- init code ----
    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// formatters.js.  Copyright (c) 2012 Microsoft Corporation.
///   - part of the vuePlot library 
///   - defines a set of chart label formatting functions
///-----------------------------------------------------------------------------------------------------------------
vp.formatters = {};     // namespace

/// format a number nicely (shortest decimal possible, add commas for thousands).
vp.formatters.comma = function (value, numDecimalPlaces, forceDecimalPlaces, removeLeadingSingleZero)
{
    if (numDecimalPlaces === undefined)
    {
        numDecimalPlaces = 2;
    }

    //---- convert to a number, if possible ----
    var num = parseFloat(value);
    
    if ((vp.isNumber(num)) && (! isNaN(num)))
    {
        value = num;

        var isWholeNum = (Math.abs(value - Math.round(value)) == 0);        // < vp.epsilon);

        if ((!forceDecimalPlaces) && (isWholeNum))
        {
            value = Math.round(value).toString();
        }
        else
        {
            //---- ensure "numDecimalPlaces" is a legal value ----
            numDecimalPlaces = Math.round(numDecimalPlaces);
            numDecimalPlaces = Math.max(0, Math.min(20, numDecimalPlaces));

            var isLessThanOne = (Math.abs(value) < 1);

            if (false)      // (value != 0) && (isLessThanOne) && (numDecimalPlaces > 0))
            {
                value = num + "";   // default formatting

                var index = value.indexOf(".");
                if (index > 0)
                {
                    var signifCount = 0;
                    var excessIndex = -1;
                    var firstSignifIndex = -1;
                    var excessCount = 0;

                    //---- remove excess digits after "numDecimalPlaces" ----
                    for (var i = index + 1; i < value.length; i++)
                    {
                        if (value[i] >= "0" && value[i] <= "9")
                        {
                            //---- its a DIGIT (vs. +E..) ----
                            if ((value[i] > "0") && (firstSignifIndex == -1))
                            {
                                firstSignifIndex = i;
                            }

                            if (firstSignifIndex > -1)
                            {
                                signifCount++;
                            }

                            if ((signifCount > numDecimalPlaces) && (excessIndex == -1))
                            {
                                excessIndex = i;
                            }

                            if (excessIndex > -1)
                            {
                                excessCount++;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    //---- reached end of digits after the "." ----
                    if (excessIndex > -1)
                    {
                        //---- delete digits at "excessIndex" ----
                        value = value.substr(0, excessIndex) + value.substr(excessIndex + excessCount);
                    }

                }
            }
            else
            {
                value = value.toFixed(numDecimalPlaces);

                if ((isLessThanOne) && (removeLeadingSingleZero) && (forceDecimalPlaces))
                {
                    value = value.substr(1);
                }

                //---- remove extra zeros ----
                if ((!forceDecimalPlaces) && (value.contains(".")))
                {
                    var allZeros = (0).toFixed(numDecimalPlaces).substr(1);
                    if (value.endsWith(allZeros))
                    {
                        var len = value.length - allZeros.length;
                        value = value.substr(0, len);
                    }
                }
            }
        }

        //---- add commas, as needed ----
        var parts = value.split('.');
        var left = parts[0];
        var right = (parts.length > 1) ? "." + parts[1] : "";

        var len = left.length;

        //---- don't add commas to 4 digit numbers ----
        if ((len > 4) || (len > 5 && len[0] == "-"))
        {
            var startLen = (len % 3) == 0 ? 3 : len % 3;
            var newLeft = left.substring(0, startLen);

            for (var i = startLen; i < len; i += 3)
            {
                newLeft += "," + left.substring(i, i + 3);
            }

            value = newLeft + right;
        }

        //---- look for exception to rule ----
        if (value.startsWith("-,"))
        {
            value = "-" + value.substr(2);
        }
    }

    return value;
};

//---- format a number as a percentage ----
vp.formatters.percent = function (value, numDecimalPlaces)
{
    //---- convert to a number, if possible ----
    var num = parseFloat(value);
    
    if (vp.isNumber(num))
    {
        value = 100 * num;
        value = vp.formatters.comma(value, numDecimalPlaces) + "%";
    }

    return value;
};

//---- format a number as a dollar amount (US only for now) ----
vp.formatters.dollar = function (value, numDecimalPlaces)
{
    if (numDecimalPlaces === undefined)
    {
        numDecimalPlaces = 2;
    }

    //---- convert to a number, if possible ----
    var num = parseFloat(value);

    if (vp.isNumber(num))
    {
        value = "$" + vp.formatters.comma(value, numDecimalPlaces, true);
    }

    return value;
};

//---- format a number in scientific notation ----
vp.formatters.scientific = function (value, numDecimalPlaces)
{
    //---- convert to a number, if possible ----
    var num = parseFloat(value);

    if (vp.isNumber(num))
    {
        if (numDecimalPlaces === undefined)
        {
            value = value.toExponential(2);
        }
        else
        {
            value = value.toExponential(numDecimalPlaces);
        }
    }

    return value;
};


vp.formatters.date = function (value)
/// returns: the date in "vaule" formatted as a general date
{
    return value;       // for now
};

vp.formatters.string = function (value)
    /// returns: the string in "vaule" formatted as ???
{
    return value;       // for now
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// incrementalCsvLoader.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - downloads a large CSV file in chunks, returning the records from each chunk so that visualization can 
///       can be built incrementally.
///-----------------------------------------------------------------------------------------------------------------

vp.incrementalCsvLoader = function (url, hasHeader, sepChar, findTypes, recordsCallback)
{
    //---- private state ----
    var offset = 0;
    var csvLoader = null;

    //---- closure ----
    var closure = function ()
    {
    };

    //---- public readNextChunk(size) ----
    closure.readNextChunk = function (size)
    {
        vp.httpReadIncremental(url, false, offset, size,
        function (jsonResult)
        {
            //---- success: got next chunk ----
            var chunk = jsonResult.data;
            var isMore = jsonResult.isMore;

            offset += chunk.length;

            var records = csvLoader.load(chunk, true);
            recordsCallback(records, isMore);
        },
        function (xmlhttp)
        {
            //---- read failed ----
            vp.error("Error reading CSV file: " + url);
        });
    };

    //---- init code ----
    csvLoader = vp.csvLoader(hasHeader, sepChar, findTypes);

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// interpolation.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - smooth interpolation between points.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 10 Data Interpolations.  
///-----------------------------------------------------------------------------------------------------------------
vp.interpolation = {};       // namespace object

vp.interpolation.lagrangePoint = function (xa, ya, x)
{
    var y = 0;
    var product = ya[0];

    for (var i = 0; i < xa.length; i++)
    {
        product = ya[i];

        for (var j = 0; j < xa.length; j++)
        {
            if (i != j)
            {
                product *= (x - xa[j]) / (xa[i] - xa[j]);
            }
        }

        y += product;
    }

    return y;
};

vp.interpolation.lagrange = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.lagrangePoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.barycentricPoint = function (xa, ya, x)
{
    var c1 = 0;
    var c2 = 0;
    var n = xa.length;
    var wt = [];

    for (var i = 0; i < n; i++)
    {
        var product = 1;

        for (var j = 0; j < n; j++)
        {
            if (i != j)
            {
                product *= (xa[i] - xa[j]);
                wt[i] = 1 / product;
            }
        }
    }

    for (var i = 0; i < n; i++)
    {
        var dx = wt[i] / (x - xa[i]);
        c1 += ya[i] * dx;
        c2 += dx;
    }

    return c1/c2;
};

vp.interpolation.barycentric = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.barycentricPoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.newtonDividedDiffPoint = function (xa, ya, x)
{
    var n = xa.length;
    var temp = [];

    for (var i = 0; i < n; i++)
    {
        temp[i] = ya[i];
    }

    for (var i = 0; i < n - 1; i++)
    {
        for (var j = n - 1; j > i; j--)
        {
            temp[j] = (temp[j-1] - temp[j]) / (xa[j-1-i] - xa[j]);
        }
    }

    var y = temp[n - 1];

    for (var i = n - 2; i >= 0; i--)
    {
        y = temp[i] + (x - xa[i]) * y;
    }

    return y;
};

vp.interpolation.newtonDividedDiff = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.newtonDividedDiffPoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.secondDerrivatives = function (xa, ya)
{
    var n = xa.length;
    var c1 = [];
    var c2 = [];
    var c3 = [];
    var dx = [];
    var derivative = [];

    for (var i = 1; i < n; i++)
    {
        dx[i] = xa[i] - xa[i - 1];
        derivative[i] = (ya[i] - ya[i - 1]) / dx[i];
    }

    for (var i=1; i < n-1; i++)
    {
        c2[i - 1] = 2;
        c3[i - 1] = dx[i + 1] / (dx[i] + dx[i + 1]);
        c1[i - 1] = 1 - c3[i - 1];
        derivative[i-1] = 6*(derivative[i+1] - derivative[i])/(dx[i] + dx[i+1]);
    }

    derivative = vp.interpolation.tridiagonal(n - 2, c1, c2, c3, derivative);
    return derivative;
};

vp.interpolation.tridiagonal = function (n, c1, c2, c3, derivative)
{
    var tol = 1.0e-12;
    var isSingular = (c2[0] < tol);

    for (var i = 1; i < n && !isSingular; i++)
    {
        c1[i] = c1[i] / c2[i - 1];
        c2[i] = c2[i] - c1[i] * c3[i - 1];
        isSingular = (c2[i] < tol);
        derivative[i] = derivative[i] - c1[i] * derivative[i - 1];
    }

    if (!isSingular)
    {
        derivative[n - 1] = derivative[n - 1] / c2[n - 1];

        for (var i = n - 2; i >= 0; i--)
        {
            derivative[i] = (derivative[i] - c3[i] * derivative[i + 1]) / c2[i];
        }

        return derivative;
    }

    return null;
};

vp.interpolation.splinePoint = function (xarray, yarray, x)
{
    var xa = [];
    var ya = [];

    //---- workaround for not handling "zero" values in xarray ----
    var xFirst = (xarray[0] == 0) ? -1.0e-5 : xarray[0];

    xa[0] = (1.0 - 1.0e-6) * xFirst;
    ya[0] = (1.0 - 1.0e-6) * yarray[0];

    for (var i = 0; i < xarray.length; i++)
    {
        xa[i + 1] = xarray[i];
        ya[i + 1] = yarray[i];
    }

    xarray = xa;
    yarray = ya;

    var y = NaN;
    var n = xarray.length;
    var dx = [];
    var derivative = vp.interpolation.secondDerrivatives(xarray, yarray);

    for (var i = 1; i < n; i++)
    {
        dx[i] = xarray[i] - xarray[i - 1];
    }

    for(var i=1; i < n-1; i++)
    {
        if (x >= xarray[i] && x < xarray[i+1])
        {
            var d1 = x - xarray[i];
            var d2 = xarray[i+1] - x;

            y = derivative[i-1] * d2 * d2 * d2 / (6.0 * dx[i+1]) + 
                derivative[i] * d1 * d1 * d1 / (6.0 * dx[i+1]) + 
                (yarray[i+1] / dx[i+1] - derivative[i] * dx[i+1] / 6.0) * d1 + 
                (yarray[i] / dx[i+1] - derivative[i-1] * dx[i+1] / 6.0) * d2;
        }
    }

    return y;
};

/// returns a set of Y coordinates that fit the xa/ya line.  The X coordinates of the fit are specified by
/// by caller.
vp.interpolation.spline = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.splinePoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.linear = function (xa, ya, x)
{
    var y = [];
    var firstx = x[0];

    for (var i = 0; i < x.length; i++)
    {
        var xx = x[i];

        //---- find index of "xa" values that surround "x" ----
        for (var j = 0; j < xa.length; j++)
        {
            if (xa[j] > firstx)
            {
                break;
            }
        }

        if ((j == 0) || (j == xa.length))
        {
            throw "error - bad x values in linear interpolation";
        }

        var xbefore = xa[j - 1];
        var xafter = xa[j];
        var xdelta = xafter - xbefore;
        var percent = (xx - xbefore) / xdelta;

        var ybefore = ya[j - 1];
        var yafter = ya[j];
        var ydelta = yafter - ybefore;
        var yy = ybefore + percent*ydelta;

        y[i] = yy;
    }

    return y;
};

vp.interpolation.lerpArray = function (ya, yb, percent)
{
    var yNew = [];

    for (var i = 0; i < ya.length; i++)
    {
        var aa = ya[i];
        var bb = yb[i];

        var yy = aa + percent * (bb - aa);
        yNew[i] = yy;
    }

    return yNew;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// statFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - statistic functions.
///-----------------------------------------------------------------------------------------------------------------


/// "meshGrid" produces a set of records representing all combinations of specified "x", "y" fields, along with a 
/// callback-specified and "value" fields.
/// Note - this is a different behavior than the MATLAB meshgrid function, which produces a matrix of height values.
/// "dx" is a vector of x values to use.
/// "dy" is a vector of y values to use.  if not specified, the values in "vx" will be used here also.
/// "valueOrFunc" is used to set the "value" field of each record.
vp.meshGrid = function (dx, dy, valueOrFunc)
{
    var rows = [];

    if (!vp.isArray(dy))
    {
        valueOrFunc = dy;
        dy = dx;
    }

    var hasValue = (vp.isDefined(valueOrFunc));
    var valueIsFunc = vp.isFunction(valueOrFunc);

    //---- must specify functions here to get a numeric sort ----
    dx = dx.sort(function (a, b) { return a - b });
    dy = dy.sort(function (a, b) { return a - b });

    var ycount = dy.length;
    var xcount = dx.length;

    for (var r = 0; r < ycount; r++)
    {
        var y = dy[r];
        for (var c = 0; c < xcount; c++)
        {
            var x = dx[c];
            var record = { x: x, y: y };

            if (hasValue)
            {
                record.value = (valueIsFunc) ? valueOrFunc(x, y) : valueOrFunc;
            }

            rows.push(record);
        }
    }

    return rows;
};

vp.average = function (nums)
{
    var total = 0;
    var count = nums.length;

    for (var i = 0; i < nums.length; i++)
    {
        total += nums[i];
    }

    var avg = (count > 0) ? total / count : 0;
    return avg;
};


///-----------------------------------------------------------------------------------------------------------------
/// azimuth.js.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - class for translating 3D points to 2D (3D scaling).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (draw3d) {
        /**  the base class for a plotLayer object. "T" is the outer layer class. */
        var azimuthClass = (function () {
            /** builds a 3D matrix that can be used to translate points from 3D to 2D.  The projection
            is specified by an azimuth and an elevation (both in degrees of rotation).  The
            standard MATLAB setting for a 3D view is azimuth=-37.5, elevation=30.  For a direct overhead (2D)
            view, use azimuth=0, elevation=90. */
            function azimuthClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax) {
                //---- private state ----
                this._mat = null;
                this._azimuth = 0;
                this._elevation = 0;
                this._screenWidth = 0;
                this._screenHeight = 0;
                this._xMin = 0;
                this._xMax = 0;
                this._yMin = 0;
                this._yMax = 0;
                this._zMin = 0;
                this._zMax = 0;
                this._xRange = 0;
                this._yRange = 0;
                this._zRange = 0;
                this._azimuth = azimuth;
                this._elevation = elevation;

                this._xMin = xMin;
                this._xMax = xMax;
                this._yMin = yMin;
                this._yMax = yMax;
                this._zMin = zMin;
                this._zMax = zMax;

                this._xRange = this.safeRange(xMax, xMin);
                this._yRange = this.safeRange(yMax, yMin);
                this._zRange = this.safeRange(zMax, zMin);

                this._screenWidth = screenWidth;
                this._screenHeight = screenHeight;

                this.rebuild();
            }
            azimuthClass.prototype.rebuild = function () {
                var elevation = this._elevation;
                var azimuth = this._azimuth;

                //elevation = 90 + (-elevation % 180);    // vp.clamp(this._elevation, -90, 90);
                //azimuth = -80 + (-azimuth % 360);       // vp.clamp(this._azimuth, -180, 180);
                //---- convert to radians ----
                elevation = elevation * Math.PI / 180;
                azimuth = azimuth * Math.PI / 180;

                //---- pre-compute 4 values ----
                var se = Math.sin(elevation);
                var ce = Math.cos(elevation);
                var sa = Math.sin(azimuth);
                var ca = Math.cos(azimuth);

                this._mat = vp.matrix4.fromFloats(ca, -se * sa, ce * sa, 0, sa, se * ca, -ce * ca, 0, 0, ce, se, 0, 0, 0, 0, 1);

                return this;
            };

            azimuthClass.prototype.mat = function () {
                return this._mat;
            };

            azimuthClass.prototype.safeRange = function (max, min) {
                var range = max - min;
                if (range == 0) {
                    range = 1;
                }

                return range;
            };

            azimuthClass.prototype.testTheMatrix = function () {
                //---- test out mat ----
                var pt = this.transformPoint(0, 0, 0);
                vp.assert(vp.floatEq(pt.x, this._screenWidth / 2));
                vp.assert(vp.floatEq(pt.y, this._screenHeight / 2));
            };

            azimuthClass.prototype.screenWidth = function (value) {
                if (arguments.length == 0) {
                    return this._screenWidth;
                }

                this._screenWidth = value;

                return this;
            };

            azimuthClass.prototype.screenHeight = function (value) {
                if (arguments.length == 0) {
                    return this._screenHeight;
                }

                this._screenHeight = value;

                return this;
            };

            azimuthClass.prototype.azimuth = function (value) {
                if (arguments.length == 0) {
                    return this._azimuth;
                }

                this._azimuth = value;

                return this;
            };

            azimuthClass.prototype.elevation = function (value) {
                if (arguments.length == 0) {
                    return this._elevation;
                }

                this._elevation = value;

                return this;
            };

            /** transform a point from 3D to 2D */
            azimuthClass.prototype.transformPoint = function (x, y, z) {
                //---- using azimuth/elevation projection ----
                //---- normalize the points to (.5..5) ----
                var x = (x - this._xMin) / this._xRange - .5;
                var y = (y - this._yMin) / this._yRange - .5;
                var z = (z - this._zMin) / this._zRange - .5;

                var v = vp.matrix4.transformPoint(this._mat, vp.vector3(x, y, z));

                var xShift = 1;
                var xScale = 1;
                var yShift = 1;
                var yScale = 1;

                v.x = (xShift + xScale * v.x) * (this._screenWidth / 2);
                v.y = (yShift - yScale * v.y) * (this._screenHeight / 2);

                return v;
            };
            return azimuthClass;
        })();
        draw3d.azimuthClass = azimuthClass;

        function createAzimuth(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax) {
            return new azimuthClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax);
        }
        draw3d.createAzimuth = createAzimuth;
    })(vp.draw3d || (vp.draw3d = {}));
    var draw3d = vp.draw3d;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// utils3d.js.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - utilities related to 3D drawing.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (draw3d) {
        /**  builds a matrix of records in X and Y, dim size x size, with a "value" field that has some peaks and valleys. */
        function peaks(size, flatten) {
            var baseNum = 3;
            var incr = (2 * baseNum) / size;
            var rows = [];

            for (var y = -baseNum; y <= baseNum; y += incr) {
                var row = (flatten) ? rows : [];

                for (var x = -baseNum; x <= baseNum; x += incr) {
                    //z =  3*(1-x)^2*exp(-(x^2) - (y+1)^2) ...
                    //   - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
                    //   - 1/3*exp(-(x+1)^2 - y^2)
                    var z1 = 3 * (1 - x) * (1 - x) * Math.exp(-(x * x) - (y + 1) * (y + 1));
                    var z2 = -10 * (x / 5 - x * x * x - Math.pow(y, 5)) * Math.exp(-(x * x) - (y * y));
                    var z3 = -1 / 3 * Math.exp(-(x + 1) * (x + 1) - (y * y));

                    var z = z1 + z2 + z3;

                    //var value = 5*Math.sin(x) + 4*Math.cos(y);
                    var record = { x: x, y: y, z: z };
                    row.push(record);
                }

                if (row != rows) {
                    rows.push(row);
                }
            }

            return rows;
        }
        draw3d.peaks = peaks;
    })(vp.draw3d || (vp.draw3d = {}));
    var draw3d = vp.draw3d;
})(vp || (vp = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// colors.js.  Copyright (c) 2012 Microsoft Corporation.
///             part of the vuePlot library - color helper and related functions.
///-----------------------------------------------------------------------------------------------------------------
vp.getNamedColors = function ()
{
    var colors = {};

    colors.aliceblue = [240, 248, 255];
    colors.antiquewhite = [250, 235, 215];
    colors.aqua = [0, 255, 255];
    colors.aquamarine = [127, 255, 212];
    colors.azure = [240, 255, 255];
    colors.beige = [245, 245, 220];
    colors.bisque = [255, 228, 196];
    colors.black = [0, 0, 0];
    colors.blanchedalmond = [255, 235, 205];
    colors.blue = [0, 0, 255];
    colors.blueviolet = [138, 43, 226];
    colors.brown = [165, 42, 42];
    colors.burlywood = [222, 184, 135];
    colors.cadetblue = [95, 158, 160];
    colors.chartreuse = [127, 255, 0];
    colors.chocolate = [210, 105, 30];
    colors.coral = [255, 127, 80];
    colors.cornflowerblue = [100, 149, 237];
    colors.cornsilk = [255, 248, 220];
    colors.crimson = [220, 20, 60];
    colors.cyan = [0, 255, 255];
    colors.darkblue = [0, 0, 139];
    colors.darkcyan = [0, 139, 139];
    colors.darkgoldenrod = [184, 134, 11];
    colors.darkgray = [169, 169, 169];
    colors.darkgreen = [0, 100, 0];
    colors.darkkhaki = [189, 183, 107];
    colors.darkmagenta = [139, 0, 139];
    colors.darkolivegreen = [85, 107, 47];
    colors.darkorange = [255, 140, 0];
    colors.darkorchid = [153, 50, 204];
    colors.darkred = [139, 0, 0];
    colors.darksalmon = [233, 150, 122];
    colors.darkseagreen = [143, 188, 143];
    colors.darkslateblue = [72, 61, 139];
    colors.darkslategray = [47, 79, 79];
    colors.darkturquoise = [0, 206, 209];
    colors.darkviolet = [148, 0, 211];
    colors.deeppink = [255, 20, 147];
    colors.deepskyblue = [0, 191, 255];
    colors.dimgray = [105, 105, 105];
    colors.dodgerblue = [30, 144, 255];
    colors.firebrick = [178, 34, 34];
    colors.floralwhite = [255, 250, 240];
    colors.forestgreen = [34, 139, 34];
    colors.fuchsia = [255, 0, 255];
    colors.gainsboro = [220, 220, 220];
    colors.ghostwhite = [248, 248, 255];
    colors.gold = [255, 215, 0];
    colors.goldenrod = [218, 165, 32];
    colors.gray = [128, 128, 128];
    colors.green = [0, 128, 0];
    colors.greenyellow = [173, 255, 47];
    colors.honeydew = [240, 255, 240];
    colors.hotpink = [255, 105, 180];
    colors.indianred = [205, 92, 92];
    colors.indigo = [75, 0, 130];
    colors.ivory = [255, 255, 240];
    colors.khaki = [240, 230, 140];
    colors.lavender = [230, 230, 250];
    colors.lavenderblush = [255, 240, 245];
    colors.lawngreen = [124, 252, 0];
    colors.lemonchiffon = [255, 250, 205];
    colors.lightblue = [173, 216, 230];
    colors.lightcoral = [240, 128, 128];
    colors.lightcyan = [224, 255, 255];
    colors.lightgoldenrodyellow = [250, 250, 210];
    colors.lightgray = [211, 211, 211];
    colors.lightgreen = [144, 238, 144];
    colors.lightpink = [255, 182, 193];
    colors.lightsalmon = [255, 160, 122];
    colors.lightseagreen = [32, 178, 170];
    colors.lightskyblue = [135, 206, 250];
    colors.lightslategray = [119, 136, 153];
    colors.lightsteelblue = [176, 196, 222];
    colors.lightyellow = [255, 255, 224];
    colors.lime = [0, 255, 0];
    colors.limegreen = [50, 205, 50];
    colors.linen = [250, 240, 230];
    colors.magenta = [255, 0, 255];
    colors.maroon = [128, 0, 0];
    colors.mediumaquamarine = [102, 205, 170];
    colors.mediumblue = [0, 0, 205];
    colors.mediumorchid = [186, 85, 211];
    colors.mediumpurple = [147, 112, 219];
    colors.mediumseagreen = [60, 179, 113];
    colors.mediumslateblue = [123, 104, 238];
    colors.mediumspringgreen = [0, 250, 154];
    colors.mediumturquoise = [72, 209, 204];
    colors.mediumvioletred = [199, 21, 133];
    colors.midnightblue = [25, 25, 112];
    colors.mintcream = [245, 255, 250];
    colors.mistyrose = [255, 228, 225];
    colors.moccasin = [255, 228, 181];
    colors.navajowhite = [255, 222, 173];
    colors.navy = [0, 0, 128];
    colors.oldlace = [253, 245, 230];
    colors.olive = [128, 128, 0];
    colors.olivedrab = [107, 142, 35];
    colors.orange = [255, 165, 0];
    colors.orangered = [255, 69, 0];
    colors.orchid = [218, 112, 214];
    colors.palegoldenrod = [238, 232, 170];
    colors.palegreen = [152, 251, 152];
    colors.paleturquoise = [175, 238, 238];
    colors.palevioletred = [219, 112, 147];
    colors.papayawhip = [255, 239, 213];
    colors.peachpuff = [255, 218, 185];
    colors.peru = [205, 133, 63];
    colors.pink = [255, 192, 203];
    colors.plum = [221, 160, 221];
    colors.powderblue = [176, 224, 230];
    colors.purple = [128, 0, 128];
    colors.red = [255, 0, 0];
    colors.rosybrown = [188, 143, 143];
    colors.royalblue = [65, 105, 225];
    colors.saddlebrown = [139, 69, 19];
    colors.salmon = [250, 128, 114];
    colors.sandybrown = [244, 164, 96];
    colors.seagreen = [46, 139, 87];
    colors.seashell = [255, 245, 238];
    colors.sienna = [160, 82, 45];
    colors.silver = [192, 192, 192];
    colors.skyblue = [135, 206, 235];
    colors.slateblue = [106, 90, 205];
    colors.slategray = [112, 128, 144];
    colors.snow = [255, 250, 250];
    colors.springgreen = [0, 255, 127];
    colors.steelblue = [70, 130, 180];
    colors.tan = [210, 180, 140];
    colors.teal = [0, 128, 128];
    colors.thistle = [216, 191, 216];
    colors.tomato = [255, 99, 71];
    colors.transparent = [255, 255, 255];
    colors.turquoise = [64, 224, 208];
    colors.violet = [238, 130, 238];
    colors.wheat = [245, 222, 179];
    colors.white = [255, 255, 255];
    colors.whitesmoke = [245, 245, 245];
    colors.yellow = [255, 255, 0];
    colors.yellowgreen = [154, 205, 50];

    return colors;
};

//---- class: colorHelper ----
vp.colorHelperClass = function ()
{
    this.colors = vp.getNamedColors();

    ///--------------------------------------------------------
    /// parse 1 of 147 predefined SVG color names
    /// and return its value as a 3 element number array.
    ///--------------------------------------------------------
    this.getColorFromName = function (name)
    {
        var value = this.colors[name.toLowerCase()];
        if (vp.isUndefined(value))
        {
            //value = this.colors.black;
        }

        return value;
    }

    ///--------------------------------------------------------
    /// parse 3 or 6 char hex string without leading "#"
    /// and return its value as a 3 element number array.
    ///--------------------------------------------------------
    this.getColorFromHexString = function (str)
    {
        var value = this.colors.black;

        if (str.length == 3)
        {
            var redStr = str[0] + str[0];
            var r = parseInt(redStr, 16);

            var greenStr = str[1] + str[1];
            var g = parseInt(greenStr, 16);

            var blueStr = str[2] + str[2];
            var b = parseInt(blueStr, 16);

            value = [r, g, b];
        }
        else if (str.length == 6)
        {
            var redStr = str[0] + str[1];
            var r = parseInt(redStr, 16);

            var greenStr = str[2] + str[3];
            var g = parseInt(greenStr, 16);

            var blueStr = str[4] + str[5];
            var b = parseInt(blueStr, 16);

            value = [r, g, b];
        }

        return value;
    }

    this.parseRGBPart = function (part)
    {
        var value = 0;

        part = part.trim();
        if (part.endsWith("%"))
        {
            //---- remove the "%" ----
            part = part.substring(0, part.length - 1).trim();
            var percent = parseFloat(part);
            value = Math.max(0, Math.min(255, Math.round(255 * percent)));
        }
        else
        {
            value = parseInt(part);
        }

        return value;
    }

    ///--------------------------------------------------------
    /// parse a comma separate rgb string (should be: xx, xx, xx)
    /// and return its value as a 3 element number array.  Each "xx"
    /// is either an integer number or a float followed by a "%" char.
    ///--------------------------------------------------------
    this.getColorFromRgbString = function (str)
    {
        var value = this.colors.black;

        var parts = str.split(',');
        if (parts.length == 3)
        {
            var r = this.parseRGBPart(parts[0]);
            var g = this.parseRGBPart(parts[1]);
            var b = this.parseRGBPart(parts[2]);

            value = [r, g, b];
        }
        else if (parts.length == 4)
        {
            var r = this.parseRGBPart(parts[0]);
            var g = this.parseRGBPart(parts[1]);
            var b = this.parseRGBPart(parts[2]);
            var a = this.parseRGBPart(parts[3]);

            value = [r, g, b];    // for now, don't return the "a"
        }

        return value;
    }

    /// converts an array of 3 RGB numbers (0-255) into a valid HTML/SVG color string.
    this.toColor = function (r, g, b, a)
    {
        var str = null;

        if (vp.isString(r))
        {
            str = r;            // already a color string
        }
        else
        {

            if (arguments.length == 1)
            {
                var aray = r;

                r = aray[0];
                g = aray[1];
                b = aray[2];

                if (aray.length > 3)
                {
                    a = aray[3];
                }
            }

            var red = vp.clamp(Math.round(r), 0, 255);
            var green = vp.clamp(Math.round(g), 0, 255);
            var blue = vp.clamp(Math.round(b), 0, 255);

            //if (true)       // for now, always use just 3 colors   // a === undefined)
            if (a === undefined)
            {
                //---- caution: SVG (at least in IE9) does NOT accept spaces betweeen commas ----
                str = ("rgb(" + red + "," + green + "," + blue + ")");
            }
            else
            {
                var alpha = vp.clamp(Math.round(a), 0, 255);

                str = ("rgba(" + red + "," + green + "," + blue + "," + alpha + ")");
            }
        }

        return str;
    }

    this.getColorFromString = function (str)
    {
        var value = str;

        if (vp.isString(str))
        {
            str = str.trim();

            if (str.startsWith("#"))
            {
                value = this.getColorFromHexString(str.substring(1));
            }
            else if (str.startsWith("rgb("))
            {
                value = this.getColorFromRgbString(str.substring(4, str.length - 1));
            }
            else if (str.startsWith("rgba("))
            {
                value = this.getColorFromRgbString(str.substring(5, str.length - 1));
            }
            else
            {
                value = this.getColorFromName(str);
            }
        }

        return value;
    }
};

//---- static color helper ----
vp.colorHelper = new vp.colorHelperClass();

/// public: interpolateColors(color1, color2, percent)
/// interpolate between color1 and color2, using "percent".  
/// returns the interpolated value.
vp.interpolateColors = function (color1, color2, percent)
{
    if (!vp.isArray(color1))
    {
        color1 = vp.colorHelper.getColorFromString(color1);
    }

    if (!vp.isArray(color2))
    {
        color2 = vp.colorHelper.getColorFromString(color2);
    }

    var value = [];

    for (var i = 0; i < 3; i++)
    {
        var min = color1[i];
        var max = color2[i];

        value[i] = min + percent * (max - min);
    }

    return value;
};

vp.isValidColor = function (value)
{
    var isValid = false;

    if (vp.isNumber(value))
    {
        isValid = true;
    }
    else if (vp.isString(value))
    {
        var parts = vp.colorHelper.getColorFromString(value);
        isValid = (parts !== undefined);
    }

    return isValid;
};

vp.colorFromPalette = function (palette, index)
{
    index = (index % palette.length);       // recycle entires to fulfill request
    var cr = palette[index];

    if (!vp.isString(cr))
    {
        cr = vp.colorHelper.toColor(cr);
    }

    return cr;
}



﻿///-----------------------------------------------------------------------------------------------------------------
/// globalEval.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///
///     - adapted from code on the web.  Need URL...
///-----------------------------------------------------------------------------------------------------------------

vp.globalEval = function (js, wantReturn)
    /// signature:  globalEval(exp)
    ///     summary: evaluates the expression at the global context and returns its value
    ///     paramType(exp): string
    ///     snippet: var a = 15;
    ///     snippet: var result = $.globalEval("10*a");       // result will be 150
    ///     returns: returns the result of evaluating the expression at the global context
{
    //---- eval in global context by adding a script element to the <head> ----
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.text = (wantReturn) ? "window._evalResult = " + js : js;

    var head = document.getElementsByTagName("head")[0];
    if (!head)
    {
        vp.error("Error - HTML missing head element (required for globalEval)");
    }

    head.appendChild(script);
    head.removeChild(script);

    var retVal = (wantReturn) ? window._evalResult : undefined;

    return retVal;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// isFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - functions to test the type of an object.
///-----------------------------------------------------------------------------------------------------------------
vp.isUndefined = function (obj)
    /// signature:  isUndefined(thing)
    ///     summary: return true if "thing" is an undefined value (missing parameter or undefined property)
    ///     paramType(thing): object or undefined value
    ///     snippet: var myObj = {sales: 100, profit: 20};
    ///     snippet: var noTaxes = $.isUndefined(myObj.taxes);      // noTaxes will be true
    ///     returns: true if "thing" is an undefined value; false otherwise
{
    return (typeof obj === "undefined");
};

vp.isDefined = function (obj)
    /// signature:  isDefined(thing)
    ///     summary: return true if "thing" is not an undefined value (missing parameter or undefined property)
    ///     paramType(thing): object or undefined value
    ///     snippet: var myObj = {sales: 100, profit: 20};
    ///     snippet: var hasSales = $.isDefined(myObj.sales);      // hasSales will be true
    ///     returns: true if "thing" is not an undefined value; false otherwise
{
    return (!(typeof obj === "undefined"))
};

/// returns true if obj is a VuePlot visualization element.
vp.isVuePlotControl = function (obj)
{
    return (obj && (!(typeof obj.control === "undefined")));
};

/// is obj an svg child element?
vp.isSvgElement = function (obj)
    /// signature:  isSvgElement(elem)
    ///     summary: returns true if "elem" is an SVG child element
    ///     paramType(elem): object
    ///     snippet: var rect = $("#svgDoc").apend("rect");
    ///     snippet: var svgTest = $.isSvgElement(rect);
    ///     returns: true if "elem" is an SVG child element; false otherwise
{
    var isSvg = (obj && obj.tagName == "svg") ? false : vp.isSvgDocOrElement(obj);
    return isSvg;
};

/// is this element an svg document or svg child element?
vp.isSvgDocOrElement = function (elem)
{
    var isSvg = false;
    var parent = elem;

    while ((parent != null) && (parent != document))
    {
        if (parent.tagName == "svg")
        {
            isSvg = true;
            break;
        }

        if (parent.tagName == "foreignObject")
        {
            isSvg = false;
            break;
        }

        if (parent.parentNode == null)
        {
            // CHW: return true when root is an SVG.*Element
            var cname = parent.constructor.toString();

            if (cname.match(/object SVG.*Element/i))
            {
                // consider part of SVG tree if root element is an SVG element
                isSvg = true;
                break;
            }
        }

        parent = parent.parentNode;
    }

    return isSvg;
};


/// is obj an HTML 5 canvas ----
vp.isCanvas = function (obj)
    /// signature:  isCanvas(elem)
    ///     summary: returns true if "elem" is an HTML 5 Canvas document
    ///     paramType(elem): object
    ///     snippet: var canvas2 = $("#canvas2");
    ///     snippet: var canvasTest = $.isCanvas(canvas2);
    ///     returns: true if "elem" is an SVG document or child element; false otherwise
{
    return ((obj != null) && (obj.tagName == "CANVAS"));
}

/// is obj a lightweight canvas child? ----
vp.isCanvasChild = function (obj)
    /// signature:  isCanvasChild(elem)
    ///     summary: returns true if "elem" is lightweight canvas element (created thru vuePlot)
    ///     paramType(elem): object
    ///     snippet: var rect = $("#canvasRect");
    ///     snippet: var cc = $.isCanvasChild(rect);
    ///     returns: true if "elem" is a lightweight canvas element; false otherwise
{
    return ((obj != null) && (obj.rootContainer) && (obj.rootContainer.canvas.tagName == "CANVAS"));
};

vp.isCanvasContainer = function (obj)
    /// signature:  isCanvasContainer(elem)
    ///     summary: returns true if "elem" is a canvas container object (created thru vuePlot)
    ///     paramType(elem): object
    ///     snippet: var parent = $("#canvasRect").parentNode;
    ///     snippet: var cc = $.isCanvasContainer(parent);
    ///     returns: true if "elem" is a canvas container object; false otherwise
{
    return ((obj != null) && (obj.rootContainer == obj));
};

/// returns true if obj is a function.
vp.isFunction = function (obj)
    /// signature:  isFunction(obj)
    ///     summary: returns true if "obj" is a user-defined function
    ///     paramType(obj): object
    ///     snippet: var isFunc = myobj.sortFunc;
    ///     returns: true if "obj" is a user-defined function; false otherwise
{
    return (typeof obj === "function");
};

/// returns true if obj is a number.
vp.isNumber = function (obj)
    /// signature:  isNumber(obj)
    ///     summary: returns true if "obj" is a javascript number object
    ///     paramType(obj): object
    ///     snippet: var num = 56;
    ///     snippet: var numTest = $.isNumber(num);     // numTest will be set to true
    ///     returns: true if "obj" is a javascript number; false otherwise
{
    return (typeof obj === "number");
};

/// returns true if obj is an object (not a primitive).
vp.isObject = function (obj)
{
    return (typeof obj === "object");
};

/// returns true if obj is a boolean value (true/false).
vp.isBoolean = function (obj)
    /// signature:  isBoolean(obj)
    ///     summary: returns true if "obj" is a javascript boolean value
    ///     paramType(obj): object
    ///     snippet: var value = true;
    ///     snippet: var boolTest = $.isBoolean(value);     // boolTest will be set to true
    ///     returns: true if "obj" is a javascript boolean; false otherwise
{
    return (typeof obj === "boolean");
};

/// returns true if obj is a number and not a NAN and not infinity
vp.isValidNumber = function (obj)
    /// signature:  isValidNumber(obj)
    ///     summary: returns true if "obj" is a javascript number object and not a NAN or INFINITY value
    ///     paramType(obj): object
    ///     snippet: var num = 56/0;
    ///     snippet: var numTest = $.isValidNumber(num);     // numTest will be set to false
    ///     returns: true if "obj" is a valid javascript number; false otherwise
{
    return ((typeof obj === "number") && (!isNaN(obj)) && (isFinite(obj)));
};

/// returns true if obj is an array.
vp.isArray = function (obj)
    /// signature:  isArray(obj)
    ///     summary: returns true if "obj" is a javascript array
    ///     paramType(obj): object
    ///     snippet: var param = [4, 5, 6];
    ///     snippet: var arayTest = $.isArray(param);    // arayTest will be set to true
    ///     returns: true if "obj" is a javascript array object; false otherwise
{
    //return (typeof this === "array");
    return (obj == null) ? false : Object.prototype.toString.call(obj) === "[object Array]";
};

/// returns true if obj is a string.
vp.isString = function (obj)
    /// signature:  isString(obj)
    ///     summary: returns true if "obj" is a javascript string
    ///     paramType(obj): object
    ///     snippet: var param = "hi there";
    ///     snippet: var strTest = $.isString(param);    // strTest will be set to true
    ///     returns: true if "obj" is a javascript string; false otherwise
{
    return (typeof obj === "string");
};

/// returns true if obj is a selected set.
vp.isSelectedSet = function (elem)
{
    return ((elem.ctr == "vp.selectedSet") || (elem instanceof vp.visuals.singleWrapperClass));
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// props.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - getters and setters for element attributes and CSS properties.
///-----------------------------------------------------------------------------------------------------------------
/// get/set the "left" css propperty (relative to its parent).  this supports HTML elements, 
/// including the SVG and Canvas documents.
/// SVG and Canvas children should use the "x" and "cx" attributes.
vp.left = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----

        //---- first, try modern HTML ----
        value = elem.offsetLeft;       

        if (value === undefined)
        {
            if (elem.getBBox)
            {
                //---- SVG element ----
                var rc = elem.getBBox();
                value = rc.x;
            }
            else if (elem.getOffset)
            {
                //---- canvas element ----
                value = elem.getOffset().x;
            }
        }

        return value;
    }
    else
    {
        //---- SET value ----
        if (vp.isNumber(value))
        {
            //---- ensure number without units get interpreted as pixels ----
            value = value + "px";
        }

        if (vp.isUndefined(elem.animation))
        {
            //---- no animation is active - just set in instantly ----
            elem.style.left = value;
        }
        else
        {
            //---- add to current animation object ----
            elem.animation.animateAttr(elem, "left", value, undefined, undefined, undefined, true);
        }
    }
};

/// get/set the "top" css propperty (relative to its parent).  this supports HTML elements, 
/// including the SVG and Canvas documents.
/// SVG and Canvas children should use the "x" and "cx" attributes.
vp.top = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----

        //---- first, try modern HTML ----
        value = elem.offsetTop;    

        if (value === undefined)
        {
            if (elem.getBBox)
            {
                //---- SVG element ----
                var rc = elem.getBBox();
                value = rc.y;
            }
            else if (elem.getOffset)
            {
                //---- canvas element ----
                value = elem.getOffset().y;
            }
        }

        return value;
    }
    else
    {
        //---- SET value ----
        if (vp.isNumber(value))
        {
            //---- ensure number without units get interpreted as pixels ----
            value = value + "px";
        }

        if (vp.isUndefined(elem.animation))
        {
            //---- no animation is active - just set it instantly ----
            elem.style.top = value;
        }
        else
        {
            //---- add to current animation object ----
            elem.animation.animateAttr(elem, "top", value, undefined, undefined, undefined, true);
        }
    }
};

/// public getBounds(elem) - return a RECT that represents the x, y, width, height relative 
/// to its parent.  Works for HTML, SVG, and CANVAS elements.
vp.getBounds = function (elem, relToParent)
{
    var rc = undefined;

    //---- checking "getBoundingClientRect" was working but now seems to have broken ----
    //---- switched to check getBBox first on 10/23/2012 - rfernand ----

    if (elem.getBBox)             // try SVG and CANVAS
    {
        var rcx = elem.getBBox();

        //---- convert to true rect ----
        var rc = vp.rect(rcx.x, rcx.y, rcx.width, rcx.height);

        if ((!relToParent) && (elem.parentNode))
        {
            var rcp = vp.getBounds(elem.parentNode, false);

            rc = vp.offsetRect(rc, rcp.left, rcp.top);
        }
    }
    else if (elem.getBoundingClientRect)   // try modern HTML 
    {
        rc = elem.getBoundingClientRect();

        if ((relToParent) && (elem.parentNode))
        {
            var rcp = elem.parentNode.getBoundingClientRect();

            rc = vp.offsetRect(rc, -rcp.left, -rcp.top);
        }
    }

    return rc;
};

vp.parentOffset = function (elem)
{
    return { left: vp.left(elem), top: vp.top(elem) };
};

/// return size of browser window.
vp.windowSize = function ()
{
    return { width: window.innerWidth, height: window.innerHeight };
}

/// return the actual width of the specified element.
vp.getWidth = function (elem)
{
    //---- get "width" value ----
    var width = 0;
    if (elem)
    {
        try
        {

            if ((elem == window) || (elem == document))
            {
                width = vp.windowSize().width;
            }
            else if (elem.rootContainer)
            {
                //---- this is a vueplot canvasContainerElement ----
                if (elem.rootContainer == elem)
                {
                    elem = elem.canvas;
                    width = elem.getBoundingClientRect().width;
                }
                else
                {
                    //---- its a canvas 2d/3d lightweight element ----
                    width = elem.getWidth.call(elem);
                }
            }
            else if ((elem.tagName == "svg") && (vp.isFireFox))
            {
                //---- SVG document on FireFox ----
                if (elem.clientWidth)
                {
                    //---- svg document on Chrome needs this ----
                    width = elem.clientWidth;
                }

                if (width == 0)
                {
                    //---- sampleData.html needs this checked before checking elem.width.baseVal ----
                    if ((elem.style) && (elem.style.width !== undefined))
                    {
                        width = vp.getCssNumber(elem.style.width, vp.width(elem.parentNode));
                    }
                }

                if (width == 0)
                {
                    if ((elem.width) && (elem.width.baseVal))
                    {
                        width = vp.getBaseVal(elem, "width", elem.width);
                    }
                }
            }
            else
            {
                if (vp.isSvgDocOrElement(elem))
                {
                    //---- SVG document not on FireFox ----
                    if (elem.clientWidth)
                    {
                        //---- svg document on Chrome needs this ----
                        width = elem.clientWidth;
                    }
                    else
                    {
                        //---- sometimes we call too early and elem.getBoundingClientRect() gets an "unspecified error" ----
                        try
                        {
                            width = elem.getBoundingClientRect().width;
                        }
                        catch (ex)
                        {
                        }

                        //---- simplfy this ASAP ----
                        if (width == 0)
                        {
                            if ((elem.width) && (elem.width.baseVal))
                            {
                                width = vp.getBaseVal(elem, "width", elem.width);
                            }
                            else
                            {
                                //---- last resort ----
                                width = parseFloat(window.getComputedStyle(elem).width);
                            }
                        }

                        //---- should check this sooner? ----
                        if ((width == 0) || (isNaN(width)))
                        {
                            width = +elem.getAttribute("width");
                        }
                    }
                }
                else
                {
                    //---- HTML element ----
                    width = elem.offsetWidth;
                }
            }
        }
        catch (ex)
        {
        }
    }

    return width;
};

vp.totalWidth = function (elem)
{
    var width = vp.getWidth(elem);

    //---- add borders ----
    var cs = window.getComputedStyle(elem);
    var bs = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);

    width += bs;
    return width;
};

vp.totalHeight = function (elem)
{
    var height = vp.getHeight(elem);

    //---- add borders ----
    var cs = window.getComputedStyle(elem);
    var bs = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);

    height += bs;
    return height;
};

vp.elementSizes = function (elem)
{
    //---- core width/height ----
    var width = vp.getWidth(elem);
    var height = vp.getHeight(elem);

    var cs = window.getComputedStyle(elem);

    //---- margins ----
    var marginWidth = parseFloat(cs["marginLeft"]) + parseFloat(cs["marginRight"]);
    var marginHeight = parseFloat(cs["marginTop"]) + parseFloat(cs["marginBottom"]);

    //---- borders ----
    var borderWidth = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);
    var borderHeight = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);

    //---- padding ----
    var paddingWidth = parseFloat(cs["paddingLeft"]) + parseFloat(cs["paddingRight"]);
    var paddingHeight = parseFloat(cs["paddingTop"]) + parseFloat(cs["paddingBottom"]);

    var sizes =
    {
        width: width, height: height,
        marginWidth: marginWidth, marginHeight: marginHeight,
        borderWidth: borderWidth, borderHeight: borderHeight,
        paddingWidth: paddingWidth, paddingHeight: paddingHeight
    };

    return sizes;
};

vp.getBaseVal = function (elem, propName, prop)
{
    var value = 0;

    try
    {
        if ((prop) && (prop.baseVal))
        {
            var unitType = prop.baseVal.unitType;
            if ((unitType == 1) || (unitType == 5))     // number or pixels
            {
                value = prop.baseVal.value;
            }
            else if (unitType == 2)
            {
                //---- percentage (of parent) ----
                if ((elem) && (elem.parentNode))
                {
                    var pValue = 0;
                    var parent = elem.parentNode;

                    if (vp.isSvgElement(parent))
                    {
                        pValue = vp.attt(parent, propName);
                    }
                    else if (vp.isCanvasChild(parent))
                    {
                        pValue = vp.attt(parent, propName);
                    }
                    else
                    {
                        pValue = vp.css(parent, propName);
                    }

                    var factor = prop.baseVal.valueInSpecifiedUnits;

                    value = factor/100 * pValue;
                }
            }
        }
    }
    catch (err)
    {
    }

    return value;
};

/// return the actual height of the specified element.
vp.getHeight = function (elem)
{
    //--- get "height" value ----
    var height = 0;
    if (elem)
    {
        try
        {
            if ((elem == window) || (elem == document))
            {
                height = vp.windowSize().height;
            }
            else if (elem.rootContainer)
            {
                //---- this is a vueplot canvasContainerElement ----
                if (elem.rootContainer == elem)
                {
                    elem = elem.canvas;
                    height = elem.getBoundingClientRect().height;
                }
                else
                {
                    //---- its a canvas 2d/3d lightweight element ----
                    height = elem.getHeight.call(elem);
                }
            }
            else if ((elem.tagName == "svg") && (vp.isFireFox))
            {
                //---- SVG document on FireFox ----
                if (elem.clientHeight)
                {
                    //---- svg document on Chrome needs this ----
                    height = elem.clientHeight;
                }

                if (height == 0)
                {
                    if ((elem.style) && (elem.style.height !== undefined))
                    {
                        height = vp.getCssNumber(elem.style.height, vp.height(elem.parentNode));
                    }
                }

                if (height == 0)
                {
                    if ((elem.height) && (elem.height.baseVal))
                    {
                        height = vp.getBaseVal(elem, "height", elem.height);
                    }
                }

            }
            else
            {
                if (vp.isSvgDocOrElement(elem))
                {
                    //---- SVG document not on FireFox ----
                    if (elem.clientHeight)
                    {
                        //---- svg document on Chrome needs this ----
                        height = elem.clientHeight;
                    }
                    else
                    {
                        //---- sometimes we call too early and elem.getBoundingClientRect() gets an "unspecified error" ----
                        try
                        {
                            height = elem.getBoundingClientRect().height;
                        }
                        catch (ex)
                        {
                        }

                        //---- simplfy this ASAP ----
                        if (height == 0)
                        {
                            if ((elem.height) && (elem.height.baseVal))
                            {
                                height = vp.getBaseVal(elem, "height", elem.height);
                            }
                            else
                            {
                                //---- last resort ----
                                height = parseFloat(window.getComputedStyle(elem).height);
                            }
                        }

                        //---- should check this sooner? ----
                        if ((height == 0) || (isNaN(height)))
                        {
                            height = +elem.getAttribute("height");
                        }

                    }
                }
                else
                {
                    //---- HTML element ----
                    height = elem.offsetHeight;
                }
            }
        }
        catch (ex)
        {
        }
    }

    return height;
};

vp.setWidth = function (elem, value)
{
    if (value == 72)
    {
        var dummy = 9;
    }

    var isSvg = vp.isSvgDocOrElement(elem);

    if (vp.isNumber(value))
    {
        value = value + "px";       // important to have units specified
    }

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----

        if (isSvg || vp.isCanvasChild(elem))
        {
            elem.setAttribute("width", value);

            //---- .css does its own triggerResize() call, but setAttribute does NOT ----
            vp.triggerResize(elem);
        }
        else
        {
            vp.css(elem, "width", value);
        }
    }
    else
    {
        //---- add to current animation object ----
        elem.animation.animateAttr(elem, "width", value, undefined, undefined, undefined, true);
    }
};

vp.setHeight = function (elem, value)
{
    //---- SET value ----
    if (vp.isNumber(value))
    {
        value = value + "px";       // important to have units specified
    }

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        {
            if (vp.isSvgDocOrElement(elem) || vp.isCanvasChild(elem))
            {
                elem.setAttribute("height", value);

                //---- .css does its own triggerResize() call, but setAttribute does NOT ----
                vp.triggerResize(elem);
            }
            else
            {
                vp.css(elem, "height", value);
            }
        }
    }
    else
    {
        //---- add to current animation object ----
        elem.animation.animateAttr(elem, "height", value, undefined, undefined, undefined, true);
    }
};

vp.width = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        return vp.getWidth(elem);
    }

    vp.setWidth(elem, value);
};

vp.height = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        return vp.getHeight(elem);
    }

    //---- SET value ----
    vp.setHeight(elem, value);
};

vp.background = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        return vp.css(elem, "background");
    }

    //---- SET value ----
    vp.css(elem, "background", value);
};


/// parse a css style string as a number.
vp.getCssNumber = function (cssValueStr, parentValue)
{
    //---- can get fancier in future, but see if this basic functionality helps ----
    var value = 0;

    if (cssValueStr != "")
    {
        value = parseFloat(cssValueStr);
    }

    if (cssValueStr.endsWith("%"))
    {
        if (vp.isNumber(parentValue))
        {
            //---- base percentage of size/width of parent ----
            value = (value * parentValue) / 100;
        }
    }

    return value;
}

vp.center = function (elem, cx, cy)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("cx", cx);
        elem.setAttribute("cy", cy);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "cx", cx);
        elem.animation.animateAttr(elem, "cy", cy);
    }
};

vp.from = function (elem, x1, y1)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("x1", x1);
        elem.setAttribute("y1", y1);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "x1", x1);
        elem.animation.animateAttr(elem, "y1", y1);
    }
};

vp.font = function (elem, family, size, weight, style)
{
    if (weight === false)
    {
        weight = undefined;
    }
    else if (weight === true)
    {
        weight = "bold";
    }

    if (style === false)
    {
        style = undefined;
    }
    else if (style === true)
    {
        style = "italic";
    }

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("font-family", family);
        elem.setAttribute("font-size", size);

        if (weight != undefined)
        {
            elem.setAttribute("font-weight", weight);
        }

        if (style != undefined)
        {
            elem.setAttribute("font-style", style);
        }
    }
    else
    {
        //---- add to current animation ----
        selectedSet.animation.animateAttr(elem, "font-family", family);
        selectedSet.animation.animateAttr(elem, "font-size", size);

        if (weight != undefined)
        {
            selectedSet.animation.animateAttr(elem, "font-weight", weight);
        }

        if (style != undefined)
        {
            selectedSet.animation.animateAttr(elem, "font-style", style);
        }
    }
};

vp.to = function (elem, x2, y2)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("x2", x2);
        elem.setAttribute("y2", y2);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "x2", x2);
        elem.animation.animateAttr(elem, "y2", y2);
    }

};

vp.translate = function (elem, x, y)
{
    vp.transform(elem, "translate(" + x + "," + y + ")");
};

vp.transform = function (elem, strTransform)
{
    if (arguments.length == 1)
    {
        var value = undefined;

        if (vp.isSvgDocOrElement(elem))
        {
            value = elem.getAttribute("transform");
        }
        else if (vp.isCanvasChild(elem))
        {
            value = elem.transform();
        }
        else if (vp.isDefined(elem.style.transform))
        {
            value = elem.style.transform;
        }
        else if (vp.isDefined(elem.style.msTransform))
        {
            value = elem.style.msTransform;
        }
        else if (vp.isDefined(elem.style.webkitTransform))
        {
            value = elem.style.webkitTransform;
        }
        else if (vp.isDefined(elem.style.MozTransform))
        {
            value = elem.style.MozTransform;
        }

        return value;
    }

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        if (vp.isSvgDocOrElement(elem))
        {
            elem.setAttribute("transform", strTransform);
        }
        else if (vp.isCanvasChild(elem))
        {
            elem.transform = strTransform;
        }
        else if (vp.isDefined(elem.style.transform))
        {
            elem.style.transform = strTransform;
        }
        else if (vp.isDefined(elem.style.msTransform))
        {
            elem.style.msTransform = strTransform;
        }
        else if (vp.isDefined(elem.style.webkitTransform))
        {
            elem.style.webkitTransform = strTransform;
        }
        else if (vp.isDefined(elem.style.MozTransform))
        {
            elem.style.MozTransform = strTransform;
        }
}
    else
    {
        //---- add to current animation ----
        //---- TODO: add support for transform here ----
        elem.animation.animateAttr(elem, "transform", strTransform);
    }
};


vp.transformOrigin = function (elem, value)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        if (vp.isSvgDocOrElement(elem))
        {
            elem.setAttribute("transformOrigin", value);
        }
        else if (vp.isDefined(elem.style.transformOrigin))
        {
            elem.style.transformOrigin = value;
        }
        else if (vp.isDefined(elem.style.msTransformOrigin))
        {
            elem.style.msTransformOrigin = value;
        }
        else if (vp.isDefined(elem.style.webkitTransformOrigin))
        {
            elem.style.webkitTransformOrigin = value;
        }
        else if (vp.isDefined(elem.style.MozTransformOrigin))
        {
            elem.style.MozTransformOrigin = value;
        }
    }
    else
    {
        //---- add to current animation ----
        //---- TODO: add support for transform here ----
        elem.animation.animateAttr(elem, "transformOrigin", value);
    }
};


vp.position = function (elem, x, y)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("x", x);
        elem.setAttribute("y", y);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "x", x);
        elem.animation.animateAttr(elem, "y", y);
    }
};

vp.absPosition = function (elem, left, top)
{
    vp.css(elem, "position", "absolute");

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        vp.css(elem, "left", left);
        vp.css(elem, "top", top);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "left", left, undefined, undefined, undefined, true);
        elem.animation.animateAttr(elem, "top", top, undefined, undefined, undefined, true);
    }
};

/// private
vp.isSizeName = function (name)
{
    var isSizeName = ((name == "width") || (name == "height") || (name == "radius"));
    return isSizeName;
};

vp.attr = function (elem, name, value)
{
    if (arguments.length == 2)
    {
        //---- GET value ----
        if (elem)
        {
            var needGetAttr = true;

            if ((elem.control) && (elem.control.getAttribute))
            {
                var isSizeName = vp.isSizeName(name);   // CHW: pass name

                if (!isSizeName)
                {
                    //---- let control handle the attribute GET ----
                    value = elem.control.getAttribute(name);
                    needGetAttr = false;
                }
            }

            if (needGetAttr)
            {
                value = elem.getAttribute(name);
            }
        }
        return value;
    }

    //---- SET value ----
    var origValue = value;

    if (typeof origValue === "function")
    {
        value = origValue(elem.dataItem, elem.dataIndex);
    }

    //---- if attribute is not animatable, we need to apply now ----
    var isAttrAnimatable = ((name != "points") && (name != "title") && (name != "d"));

    if ((vp.isUndefined(elem.animation)) || (! isAttrAnimatable))
    {
        var needSetAttr = true;

        //---- no animation is active - just set in instantly ----
        if ((elem.control) && (elem.control.setAttribute))
        {
            var isSizeName = vp.isSizeName();
            if (!isSizeName)
            {
                //---- let control handle the attribute SET ----
                elem.control.setAttribute(name, value);
                needSetAttr = false;
            }
        }

        if (needSetAttr)
        {
            if (value+"" === "NaN")
            {
                var a = 9;
                vp.error("Error: cannot set attr value to NaN: " + name);
            }

            elem.setAttribute(name, value);
        }

        if ((name == "width") || (name == "height") || (name == "radius"))
        {
            vp.triggerResize(elem);
        }
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, name, value);
    }
};

vp.attrNS = function (elem, ns, name, value)
{
    if (arguments.length == 3)
    {
        //---- GET value ----
        value = elem.getAttributeNS(ns, name);
        return value;
    }

    //---- SET value ----
    var origValue = value;

    if (typeof origValue === "function")
    {
        value = origValue(elem.dataItem, elem.dataIndex);
    }

    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttributeNS(ns, name, value);
    }
    else
    {
        //---- add to current animation ----
        //---- TODO: pass "ns" along to animation... ----
        elem.animation.animateAttr(elem, name, value);
    }
};

vp.href = function (elem, value)
{
    if (arguments.length == 1)
    {
        
        if (vp.isSvgDocOrElement(elem))
        {
            value = vp.attrNS(elem, "http://www.w3.org/1999/xlink", "href");
        }
        else
        {
            value = elem.getAttribute("href");
        }

        return value;
    }

    if (vp.isSvgDocOrElement(elem))
    {
        vp.attrNS(elem, "http://www.w3.org/1999/xlink", "href", value);
    }
    else
    {
        elem.setAttribute("href", value);
    }
};


vp.prop = function (elem, name, value)
    /// signature: vp.prop(element, name)
    ///     summary: returns the value associated with the property "name" on the element.
    ///     paramType(element): element (the element that has the property).
    ///     paramType(name): string (the name of the property to be retreived).
    ///     snippet: myElem.prop("hitCount");       // get the value associated with the named property
    ///     returns: if the property exists on the element, the value associated with the property; otherwise undefined.
    /// signature: vp.prop(element, name, value)
    ///     summary: sets a property/value pair on the element.
    ///     paramType(element): element (the element that will have the property).
    ///     paramType(name): string (the name of the property to be set).
    ///     paramType(value): object (the value of the property to be set).
    ///     snippet: myElem.prop("hitCount", 100);       // store the value 100 under the property name "hitCount" on myElem
    ///     returns: undefined.
{
    if (arguments.length == 2)
    {
        //---- GET value ----
        value = elem[name];
        return value;
    }

    //---- SET value ----
    var origValue = value;

    if (typeof origValue === "function")
    {
        value = origValue(elem.dataItem, elem.dataIndex);
    }

    //---- animation NOT supported for custom properties (most of them we do NOT want animated) ----
    if (true)       // vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem[name] = value;
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, name, value);
    }
};

//---- todo: we should probably only define one of these and zap the other one ---
vp.customAttr = vp.prop;

/// get/set the "opacity" css property on the item.
vp.opacity = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = (elem.rootContainer) ? elem.opacity : elem.style.opacity;
        return value;
    }
    else
    {
        //---- SET value ----
        if (vp.isUndefined(elem.animation))
        {
            //---- no animation is active - just set in instantly ----
            if (elem.rootContainer)
            {
                elem.opacity = value;
            }
            else
            {
                elem.style.opacity = value;
            }
        }
        else
        {
            //---- add to current animation ----
            elem.animation.animateAttr(elem, "opacity", value, undefined, undefined, undefined, true);
        }
    }
}

/// get/set the "checked" property on the item.
vp.checked = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.checked;
    }
    else
    {
        //---- SET value ----
        elem.checked = value;
    }

    return value;
}

vp.removeAttribute = function (elem, name)
    /// signature: vp.removeAttribute(element, name)
    ///     summary: removes the attribute/value pair stored under "name" on the element.
    ///     paramType(element): element (the element whose attribute list is to be modified).
    ///     paramType(name): string (the name of the attribute to be removed).
    ///     snippet: myElem.setAttribute("hitCount", 0);        // create a custom attribute (name/value pair)
    ///     snippet: myElem.removeAttribute("hitCount");        // remove the custom attribute "hitCount"
    ///     returns: null.
{
    elem.removeAttribute(name);
};

vp.removeProp = function (elem, name)
    /// signature: vp.removeProp(element, name)
    ///     summary: removes the property/value pair stored under "name" on the element.
    ///     paramType(element): element (the element whose property list is to be modified).
    ///     paramType(name): string (the name of the property to be removed).
    ///     snippet: myElem.setProp("hitCount", 0);        // create a custom property (name/value pair)
    ///     snippet: myElem.removeProp("hitCount");        // remove the custom property "hitCount"
    ///     returns: true (whether or not the property existed).
{
    return delete elem[name];
};

vp.id = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.getAttribute("id");
        return value;
    }
    else
    {
        //---- SET value ----
        elem.setAttribute("id", value);
    }
};

vp.toolTipEnabled = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.toolTipEnabled;
        return value;
    }
    else
    {
        //---- SET value ----
        elem.toolTipEnabled = value;
    }
};

vp.getClass = function (elem)
{
    var name = "";

    if ((vp.isSvgDocOrElement(elem)) && (elem.getAttribute))
    {
        name = elem.getAttribute("class");
    }
    else
    {
        name = elem.className;
    }

    if (name == null)
    {
        name = "";
    }

    return name;
};

/// sets the class name of the element to just the specified name.
vp.setClass = function (elem, name)
{
    if ((vp.isSvgDocOrElement(elem)) && (elem.getAttribute))
    {
        elem.setAttribute("class", name);
    }
    else
    {
        elem.className = name;
    }
};


/// add the specified class name to the element, if it doesn't already have it.
vp.addClass = function (elem, name)
{
    if (!vp.hasClass(elem, name))
    {
        var cnBefore = vp.getClass(elem);
        var newName = "";

        if (cnBefore == "")
        {
            newName = name;
        }
        else
        {
            newName = cnBefore + " " + name;
        }

        vp.setClass(elem, newName);
    }
};

/// returns true if the element has the specified class name.
vp.hasClass = function (elem, name)
{
    var hasIt = false;
    var cn = vp.getClass(elem);

    if ((cn == name) || (cn.startsWith(name + " ")) || (cn.endsWith(" " + name)) || (cn.contains(" " + name + " ")))
    {
        hasIt = true;
    }

    return hasIt;
};

/// removes the specified class name from the element, if it is found in it.
vp.removeClass = function (elem, name)
{
    var cn = vp.getClass(elem);
    var nameLen = name.length;
    var newcn = cn;

    if (cn == name)
    {
        newcn = "";
    }
    else
    {
        var index = (cn.indexOf(" " + name + " "));
        if (index > -1)
        {
            newcn = cn.substring(0, index) + cn.substring(index + nameLen + 1);
        }
        else
        {
            if (cn.endsWith(" " + name))
            {
                var len = cn.length - (nameLen + 1);
                newcn = cn.substring(0, len);
            }
            else if (cn.startsWith(name + ""))
            {
                newcn = cn.substring(name.length + 1);
            }
        }
    }

    if (newcn != cn)
    {
        vp.setClass(elem, newcn);
    }
};

/// if the class name is found in the element, it is removed.  otherwise, it is added.
vp.toggleClass = function (elem, name)
{
    if (vp.hasClass(elem, name))
    {
        vp.removeClass(elem, name);
    }
    else
    {
        vp.addClass(elem, name);
    }
};

/// if the class name is found in the element, it is removed.  otherwise, it is added.
vp.tabIndex = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.getAttribute(elem, "tabIndex");
        return value;
    }
    else
    {
        //---- SET value ----
        var actualValue = value;

        if (typeof value === "function")
        {
            actualValue = value(elem.dataItem, elem.dataIndex);
        }

        elem.setAttribute("tabIndex", value);
    }
};

/// get/set the "text" property on the element.
vp.text = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.textContent;
        return value;
    }
    else
    {
        //---- SET value ----
        var actualValue = value;

        if (typeof value === "function")
        {
            actualValue = value(elem.dataItem, elem.dataIndex);
        }

        elem.textContent = actualValue;
    }
};

/// return the "title" child, if any, for the element.
vp.getTitleChild = function (elem)
{
    var title = null;

    for (var i = 0; i < elem.childNodes.length; i++)
    {
        var child = elem.childNodes[i];
        if (child.tagName == "title")
        {
            title = child;
            break;
        }
    }

    return title;
};

/// get/set the "title" property on the element (standard tooltip).
vp.title = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = null;

        if (vp.isSvgElement(elem))
        {
            var title = vp.getTitleChild(elem);
            if (title)
            {
                value = title.textContent;
            }
        }
        else if (elem.getAttribute)
        {
            value = elem.getAttribute("title");
        }

        return value;
    }
    else
    {
        //---- SET value ----
        var actualValue = value;

        if (typeof value === "function")
        {
            actualValue = value(elem.dataItem, elem.dataIndex);
        }

        if (vp.isSvgElement(elem))
        {
            var title = vp.getTitleChild(elem);
            if (!title)
            {
                title = vp.createSvg("title");
                elem.appendChild(title);
            }

            title.textContent = value;

            //---- seems to work without this, for HTML and SVG, except for IE/SVG ----
            //---- and for IE/SVG, this doesn't help ----

            //---- for native tooltips honoring newline chars ----
            //vp.css(title, "white-space", "pre-wrap");

        }
        else
        {
            elem.setAttribute("title", actualValue);
        }
    }
};

vp.html = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.innerHTML;
        return value;
    }
    else
    {
        //---- SET value ----
        var actualValue = value;

        if (typeof value === "function")
        {
            actualValue = value(elem.dataItem, elem.dataIndex);
        }

        elem.innerHTML = actualValue;
    }
}

/// get/set the "value" property on the element.
vp.value = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.value;
        return value;
    }
    else
    {
        //---- SET value ----
        var actualValue = value;

        if (typeof value === "function")
        {
            actualValue = value(elem.dataItem, elem.dataIndex);
        }

        elem.value = actualValue;
    }
}

/// remove all childNodes or children of the element.
vp.clear = function (element)
{
    if (vp.isCanvasChild(element))
    {
        element.clear();
    }
    else if (vp.isCanvasContainer(element))
    {
        element.clear();
    }
    else if (element.childNodes)
    {
        while (element.childNodes.length > 0)
        {
            var child = element.childNodes[0];
            element.removeChild(child);

            //---- Firefox doesn't allow this; is it needed? ----
            //child.parentNode = null;
        }
    }
};

/// hide an element.
vp.hide = function (elem)
{
    vp.visibility(elem, "hidden");
};

/// collapse an element.
vp.collapse = function (elem)
{
    //vp.visibility(elem, "collapse");
    vp.css(elem, "display", "none");
};

/// uncollapse an element.
vp.expand = function (elem)
{
    //vp.visibility(elem, "collapse");
    vp.css(elem, "display", "block");
};

/// show an element.
vp.show = function (elem, showIt)
{
    if (showIt === false)
    {
        vp.visibility(elem, "hidden");
    }
    else
    {
        vp.visibility(elem, "visible");
    }
};

vp.visibility = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        if (elem.rootContainer == elem)
        {
            value = elem.canvas.style.visibility;
        }
        else if (elem.rootContainer)
        {
            //---- its a canvas lightweight element ----
            value = elem.visibility;
        }
        else
        {
            //---- normal HTML/SVG element ----
            value = elem.style.visibility;
        }

        return value;
    }

    //---- SET value ----
    if (elem.rootContainer == elem)
    {
        elem.canvas.style.visibility = value;
    }
    else if (elem.rootContainer)
    {
        //---- its a canvas lightweight element ----
        elem.visibility = value
    }
    else
    {
        //---- normal HTML/SVG element ----
        elem.style.visibility = value
    }
}

/// toggle an element between hidden and visible
vp.showToggle = function (elem)
{
    var vis = vp.visibility(elem);
    if ((vis == "") || (vis == "visible"))
    {
        vp.visibility(elem, "collapse");
    }
    else
    {
        vp.visibility(elem, "visible");
    }
};


/// get/set single CSS style property.
vp.css = function (elem, prop, value)
{
    if (elem.canvas)        // if this is context holder, use actual cnavas element
    {
        elem = elem.canvas;
    }

    //---- provide translation from prop names like "short-shape" to "shortShape" for Firefox ----
    var index = prop.indexOf('-');
    while (index > -1)
    {
        prop = prop.substr(0, index) + prop.substr(index + 1, 1).toUpperCase() + prop.substr(index + 2);
        index = prop.indexOf('-');
    }

    if (arguments.length == 2)
    {
        //---- GET value ----
        if (prop == "width")
        {
            value = vp.getWidth(elem);
        }
        else if (prop == "height")
        {
            value = vp.getHeight(elem);
        }
        else
        {
            value = elem.style[prop];
        }

        return value;
    }

    //---- SET value ----
    if (vp.isUndefined(elem.animation))
    {
        //---- set it directly ----
        if (vp.isNumber(value))
        {
            if ((prop != "z-index") && (prop != "zIndex") && (prop != "opacity"))
            {
                value += "px";
            }
        }

        if ((prop == "height") && (value) && (value.startsWith("0")))
        {
            var dummmy = 9;
        }

        elem.style[prop] = value;

        if ((prop == "width") || (prop == "height") || (prop == "radius"))
        {
            vp.triggerResize(elem);
        }
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, prop, value, undefined, undefined, undefined, true);
    }

};


vp.parent = function (elem)
{
    var parent = null;

    if (elem.parentNode)
    {
        parent = elem.parentNode;
    }

    return parent;
}

vp.children = function (parentElem, includeAll)
    /// signature: vp.children(parentElem)
    ///     summary: returns children ELEMENTS of the parent element(s)
    ///     paramType(parentElem): an HTML, SVG, or Canvas document/element
    ///     paramType(includeAll): if false, only direct children are included
    ///     snippet: var kids = $.children(svgDoc);
    ///     returns: an array of the child elements of the element if it has children; null otherwise
{
    var kids = [];

    if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement))
    {
        parentElem = parentElem.canvasContainerElement;
    }

    if ((parentElem.ctr == "vp.selectedSet") || (parentElem.ctr == "vp.canvasSelectedSet"))
    {
        for (var i = 0; i < parentElem.length; i++)
        {
            var hisKids = vp.children(parentElem[i]);
            kids = kids.concat(hisKids);
        }
    }
    else if (parentElem.ctr == "vp.singleWrapper") 
    {
        kids = vp.children(parentElem.elem);
    }
    else if (parentElem.children)
    {
        kids = parentElem.children;
    }
    else if (parentElem.childNodes)
    {
        //---- SVG document ----
        kids = parentElem.childNodes;
    }

    //---- convert from HTML Collection to array, if needed ----
    if (!vp.isArray(kids))
    {
        var collect = kids;
        kids = [];

        for (var i = 0; i < collect.length; i++)
        {
            kids.push(collect[i]);
        }
    }

    //---- include indirect children, if specified ----
    if (includeAll)
    {
        for (var i = 0; i < kids.length; i++)
        {
            var ikids = vp.children(kids[i]);
            kids = kids.concat(ikids);
        }
    }

    return kids;
};

vp.childNodes = function (parentElem, includeAll)
    /// signature: vp.childNodes(parentElem)
    ///     summary: returns children NODES of the parent element(s)
    ///     paramType(parentElem): an HTML, SVG, or Canvas document/element
    ///     paramType(includeAll): if false, only direct children are included
    ///     snippet: var kids = $.childNodes(svgDoc);
    ///     returns: an array of the child elements of the element if it has children; null otherwise
{
    var kids = [];

    if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement))
    {
        parentElem = parentElem.canvasContainerElement;
    }

    if ((parentElem.ctr == "vp.selectedSet") || (parentElem.ctr == "vp.canvasSelectedSet"))
    {
        for (var i = 0; i < parentElem.length; i++)
        {
            var hisKids = vp.childNodes(parentElem[i]);
            kids = kids.concat(hisKids);
        }
    }
    else if (parentElem.ctr == "vp.singleWrapper")
    {
        kids = vp.childNodes(parentElem.elem);
    }
    else if (parentElem.childNodes)
    {
        kids = parentElem.childNodes;
    }

    //---- convert from HTML Collection to array, if needed ----
    if (!vp.isArray(kids))
    {
        var collect = kids;
        kids = [];

        for (var i = 0; i < collect.length; i++)
        {
            kids.push(collect[i]);
        }
    }

    //---- include indirect children, if specified ----
    if (includeAll)
    {
        for (var i = 0; i < kids.length; i++)
        {
            var ikids = vp.childNodes(kids[i]);
            kids = kids.concat(ikids);
        }
    }

    return kids;
};

vp.bounds = function (elem, x, y, width, height)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        if (height == null)
        {
            //---- for circle-types ----
            elem.setAttribute("cx", x);
            elem.setAttribute("cy", y);
            elem.setAttribute("r", width);
        }
        else
        {
            if (vp.isSvgDocOrElement(elem) || vp.isCanvasChild(elem))
            {
                elem.setAttribute("x", x);
                elem.setAttribute("y", y);
                elem.setAttribute("width", width);
                elem.setAttribute("height", height);
            }
            else
            {
                vp.css(elem, "left", x);
                vp.css(elem, "top", y);
                vp.css(elem, "width", width);
                vp.css(elem, "height", height);
            }
        }
    }
    else
    {
        //---- add to current animation ----
        if (height == null)
        {
            //---- for circle-types ----
            elem.animation.animateAttr(elem, "cx", x);
            elem.animation.animateAttr(elem, "cy", y);
            elem.animation.animateAttr(elem, "r", width);
        }
        else
        {
            if (vp.isSvgDocOrElement(elem) || vp.isCanvasChild(elem))
            {

                elem.animation.animateAttr(elem, "x", x);
                elem.animation.animateAttr(elem, "y", y);
                elem.animation.animateAttr(elem, "width", width);
                elem.animation.animateAttr(elem, "height", height);
            }
            else
            {
                elem.animation.animateAttr(elem, "left", x, undefined, undefined, undefined, true);
                elem.animation.animateAttr(elem, "top", y, undefined, undefined, undefined, true);
                elem.animation.animateAttr(elem, "width", width, undefined, undefined, undefined, true);
                elem.animation.animateAttr(elem, "height", height, undefined, undefined, undefined, true);
            }
        }
    }
};

vp.colors = function (elem, fill, stroke, strokeWidth)
{
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        if (fill !== undefined)
        {
            elem.setAttribute("fill", fill);
        }

        if (stroke !== undefined)
        {
            elem.setAttribute("stroke", stroke);
        }

        if (strokeWidth != undefined)
        {
            elem.setAttribute("stroke-width", strokeWidth);
        }
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "fill", fill);
        elem.animation.animateAttr(elem, "stroke", stroke);
        elem.animation.animateAttr(elem, "strokeWidth", strokeWidth);
    }
};

vp.addStop = function (brush, offset, color, opacity)
{
    var ss = "stop-color: " + color;
    if (opacity != null)
    {
        ss += "; stop-opacity: " + opacity;
    }

    if (vp.isUndefined(brush.animation))
    {
        //---- no animation is active - just set in instantly ----
        var stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");

        stop.setAttribute("offset", offset);
        stop.setAttribute("style", ss);

        brush.appendChild(stop);
    }
    else
    {
        //---- add to current animation ----
        //---- TODO: support animation of stops ----
        brush.animation.animateAttr(brush, "x", x);
        brush.animation.animateAttr(brush, "y", y);
    }
};

vp.dataItem = function (elem, value)
{
    if (arguments.length == 1)
    {
        return elem.dataItem;
    }

    elem.dataItem = value;
}

vp.dataIndex = function (elem, value)
{
    if (arguments.length == 1)
    {
        return elem.dataIndex;
    }

    elem.dataIndex = value;
}

vp.data = function (elem, dataItem, dataIndex)
{
    elem.dataItem = dataItem;
    elem.dataIndex = dataIndex;
}

//
//---- warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. ----
//
vp.dataBind = function (elem, ss, bindingName, data, pkFunc, isNewData)
{
    var binder = null;
    
    //---- make sure name doesn't step on another property name ----
    bindingName = "binder_" + bindingName;

    //--- the binder object is stored on the associated HTML/SVG element as a named property ----
    if (!elem.hasOwnProperty(bindingName))
    {
        binder = vp.dataBinder(ss, data, pkFunc, isNewData);
        elem[bindingName] = binder;
    }
    else
    {
        binder = elem[bindingName];
        binder.setData(data, pkFunc, isNewData);
    }

    return binder;
};

vp.animate = function (elem, duration, ease, container)
{
    if (duration)
    {
        //---- store the animation object on the element so it can be retreived later, if needed ----
        elem.animation = vp.animation(elem, duration, ease, container);
    }
    else
    {
        delete elem.animation;   // mark it as not animating, so we set attributes, etc. directly
    }
};

vp.frameRateChanged = function (elem, callBack)
{
    elem.frameRateChanged = callBack;
};

vp.radius = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.getAttribute("radius");
        return value;
    }

    //---- SET value ----
    if (vp.isUndefined(elem.animation))
    {
        //---- no animation is active - just set in instantly ----
        elem.setAttribute("radius", value);
    }
    else
    {
        //---- add to current animation ----
        elem.animation.animateAttr(elem, "radius", value);
    }
};

vp.returnFalse = function ()
{
    return false;
};


vp.dataPair = function (elem, dataItem, dataIndex)
{
    elem.dataItem = dataItem;
    elem.dataIndex = dataIndex;
};

vp.focus = function (elem)
{
    elem.focus();
};

vp.dataId = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.dataItem.dataId;
        return value;
    }

    //---- SET value ----
    elem.dataItem.dataId = value; 
};

vp.shapeId = function (elem, value)
{
    if (arguments.length == 1)
    {
        //---- GET value ----
        value = elem.dataItem.shapeId;
        return value;
    }

    //---- SET value ----
    elem.dataItem.shapeId = value;
};

/// used to temp. disable HTML element selection by the user with mouse/touch
/// during a control's dragging operation.
vp.enableElementSelection = function (elem, enable)
{
    if (enable)
    {
        if (vp.isDefined(elem.onselectstart))
        {
            elem.onselectstart = null;
        }
        else if (vp.isDefined(elem.style.MozUserSelect))
        {
            //---- restore default of "text" ----
            elem.style.MozUserSelect = "text";
        }
        else if (elem.onmousedown == vp.returnFalse)
        {
            elem.onmousedown = null;
        }
    }
    else
    {
        if (vp.isDefined(elem.onselectstart))
        {
            elem.onselectstart = vp.returnFalse;
        }
        else if (vp.isDefined(elem.style.MozUserSelect))
        {
            elem.style.MozUserSelect = "none";
        }
        else
        {
            //---- caution: this could break other things ----
            elem.onmousedown = vp.returnFalse;
        }
    }
};

/// returns the scroll offset for the HTML page.  This value is in pixels from the document origin.
/// verified correct by roland on 6/21/2013 on Windows 8 for: IE10, Chrome 27, and FireFox 21.0.
vp.getBodyScroll = function ()
{
    return { x: window.pageXOffset, y: window.pageYOffset };
};

/// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
/// verified correct by roland on 5/12/2012 on Windows 7 for: IE9, Chrome 18.0, and FireFox 11.0.
/// testing included HMTL document, HTML element, SVG doc, SVG element, Canvas 2d doc, Canvas 2d elem,
/// Canvas 3d doc, Canvas 3d elem.
vp.docOffset = function (elem)
{
    var left = 0;
    var top = 0;
    var origElem = elem;

    //---- walk up the parent hierarchy until we hit a real HTML element ----
    while ((elem) && (elem != document.body))
    {
        if ((elem.rootContainer) && (elem.rootContainer == elem))
        {
            elem = elem.canvas;
        }

        if (elem.rootContainer)
        {
            //---- its a canvas 2d/3d lightweight element ----
            var offset = elem.getOffset();

            left += offset.x;
            top += offset.y;
        }
        else if ((elem.tagName == "svg") && (!vp.isIE))
        {
            //---- special handling for SVG document for Chrome/FireFox ----
            //---- these browsers do wierd things when a viewBox is set on the SVG document, so we use this workaround ----

            if (vp.isFireFox)
            {
                //---- FireFox ----
                //var rc = elem.getBoundingClientRect();

                // problem: getBoundingClinetRect() varies with viewBox on svgdoc, so it is not simple to use.
                // as our workaround, we use elem.getBBox() for parent offset and then the location of the parent.

                var vb = elem.viewBox;
                if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0))
                {
                    //---- viewbox is active ----
                    //---- add offset to parent ----
                    var box = elem.getBBox();
                    left += box.x;
                    top += box.y;

                    //---- wait - getBBox() is measured from outside box of parent (not content); so we need to ----
                    //---- adjust by adding the left/top margin and the left/top border size (yuck) ----
                    left -= vp.getCssNumber(elem.parentNode.style.marginLeft);
                    left -= vp.getCssNumber(elem.parentNode.style.borderLeft);

                    top -= vp.getCssNumber(elem.parentNode.style.marginTop);
                    top -= vp.getCssNumber(elem.parentNode.style.borderTop);

                    //---- and continue up the hierarchy ----
                }
                else
                {
                    //---- viewbox is inactive ----
                    var rc = elem.getBoundingClientRect();

                    left += rc.left;
                    top += rc.top;

                    //---- this stuff is really strange; now we seem to need to offset it by getBBox() ----
                    var bb = elem.getBBox();
                    left -= bb.x;
                    top -= bb.y;

                    break;
                }
            }
            else
            {
                //---- Chrome ----
                if (vp.isDefined(elem.offsetLeft))
                {
                    //---- this fixes "mouse" and "panAndZoom" samples for Chrome, but more adjustments may be needed ----
                    //---- we also need to work for "stdChart" bar selection dragging ----

                    //---- as a temp workaround, use 2 code paths (one for active viewBox, one for other case) ----
                    var vb = elem.viewBox;
                    if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0))
                    {
                        //---- viewbox is active ----
                        left += elem.offsetLeft;
                        top += elem.offsetTop;
                        break;
                    }
                    else
                    {
                        //---- viewbox is inactive ----
                        var rc = elem.getBoundingClientRect();

                        left += rc.left;
                        top += rc.top;

                        break;
                    }
                }
            }

            //            if (elem.parentNode)
            //            {
            //                //--- get location of parent ----
            //                var rc = elem.parentNode.getBoundingClientRect();

            //                left += rc.left;
            //                top += rc.top;
            //            }

            //            //---- add location of svg doc relative to parent ----
            //            left += elem.clientLeft;
            //            top += elem.clientTop;
        }
        else
        {
            //---- HTML element ----
            //---- "modern browser" assumption - we rely on getBoundClientRect() to do the hard work ----
            var rc = elem.getBoundingClientRect();

            left += rc.left;
            top += rc.top;

            break;
        }

        elem = elem.parentNode;
    }


    //---- must always add the scroll offset of the body ----
    var bs = vp.getBodyScroll();
    left += bs.x;
    top += bs.y;

    return { left: left, top: top };

};



﻿///-----------------------------------------------------------------------------------------------------------------
/// startup.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - startup & document/script loading functions.
///-----------------------------------------------------------------------------------------------------------------
/// internal: initialize the vuePlot function and global object.
vp.init = function ()
{
    this.readyFuncs = [];
    this.readyTriggered = false;
    this.keyboardKeys = {};
    this.scripts = {};          // {url, isLoaded} for scripts being downloaded
    this.isIE = navigator.userAgent.toLowerCase().contains("trident");
    this.isFireFox = navigator.userAgent.toLowerCase().contains("firefox");
    this.isSafari = navigator.userAgent.toLowerCase().contains("safari");
    this.isChrome = navigator.userAgent.toLowerCase().contains("chrome");

    //alert(navigator.userAgent.toLowerCase());

    var self = this;

    if (document.addEventListener != null)
    {
        document.addEventListener("DOMContentLoaded", function ()
        {
            self.checkReady();
        });
    }
    else if (document.attachEvent != null)
    {
        //---- IE8 and earlier ----
        document.attachEvent("onreadystatechange", function ()
        {
            self.checkReady();
        });
    }

}

/// internal: check to see if document and all requested scripts are fully loaded.
vp.checkReady = function ()
{
    //vp.debug("checkReady...");
    if (!allLoaded)            // ignore these calls once we are all loaded
    {
        //---- ensure document is fully loaded ----
        var state = document.readyState;
        if ((state === "complete") || (state == "interactive"))
        {
            //---- watch for IE timing isssue; might need another tick ----
            if (!document.body)
            {
                setTimeout(vp.cb(this.checkReady, this));
                return;
            }

            var allLoaded = true;

            //---- ensure all requested scripts have loaded ----
            for (var url in this.scripts)
            {
                if (this.scripts[url] === null)
                {
                    allLoaded = false;
                    break;
                }
            }

            if (allLoaded)
            {
                //---- now, execute each script in declared order ----
                for (var url in this.scripts)
                {
                    var js = this.scripts[url];
                    vp.globalEval(js);
                }

                this.scripts = {};      // so we don't run them again

                //---- now, everything has been loaded ----
                this.onReady();
            }
        }
    }
};

/// internal: called when document and all requested scripts are fully loaded.
vp.onReady = function ()
{
    //vp.debug("onReady called");

    if (!this.readyTriggered)
    {
        for (var i = 0; i < this.readyFuncs.length; i++)
        {
            this.readyFuncs[i]();
        }

        this.readyFuncs = [];       // only call these once

        this.readyTriggered = true;
    }
};

//---- intialize are global function/object now ----
vp.init();

vp.ready = function (readyFunc)
    /// signature: vp.ready(func)
    ///     summary: adds the specified function to a list of functions that will be called when the document and all requested scripts are fully loaded.
    ///     paramType(func): the function to be called when the document/scripts are loaded.
    ///     snippet: $.ready(function()  { buildItems(); });     // call buildItems() when doc is loaded
    ///     returns: null.
{
    this.readyFuncs.push(readyFunc);
};

/// internal - don't expose
vp.httpReadText = function (url, successFunc, failFunc)
{
    var xmlhttp = null;

    if (XMLHttpRequest != null)
    {
        xmlhttp = new XMLHttpRequest();
    }
    else
    {
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }

    xmlhttp.open("GET", url, true);

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send();
}

vp.startScriptLoad = function (url)
{
    //---- don't load the same script twice ----
    if (vp.isUndefined(vp.scripts[url]))
    {
        var head = document.getElementsByTagName("head")[0];
        if (head)
        {
            vp.scripts[url] = null;        // mark it as being loaded

            vp.httpReadText(url, function (xhr)
            {
                var text = xhr.responseText;
                vp.scripts[url] = text;
                vp.checkReady();
            });
        }
    }
}
﻿///-----------------------------------------------------------------------------------------------------------------
/// styleSheet.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///
///     - adapted from code on the web.  Need URL...
///-----------------------------------------------------------------------------------------------------------------

vp.createStyleSheet = function ()
{
    //---- local state ----
    var styleSheet = null;
    var elem = null;

    //---- dummy closure function ----
    var update = function ()
    {
    };

    //---- add a rule to this style sheet ----
    update.addRule = function (selector, style)
    {
        var myRules = styleSheet.rules || styleSheet.cssRules;

        var atIndex = myRules.length;
        styleSheet.insertRule(selector + ' {' + style + '}', atIndex);

        return update;
    };

    //---- remove this style sheet from the document
    update.remove = function ()
    {
        styleSheet.remove();
    };

    update.sheet = function ()
    {
        return styleSheet;
    };

    /// propety: id
    update.id = function (value)
    {
        if (arguments.length === 0)
        {
            return vp.id(elem);
        }

        vp.id(elem, value);
    };

    //---- init code ----
    elem = document.createElement('style');
    elem.type = 'text/css';

    //---- append to document <head> section ----
    var head0 = document.getElementsByTagName('head')[0];
    head0.appendChild(elem);

    //---- elem is not the final sheet object, so get the newly created sheet ----
    styleSheet = document.styleSheets[document.styleSheets.length - 1];

    return update;
};

vp.setFocus = function (elem)
{
    while ((elem) && (!elem.focus))
    {
        elem = vp.parent(elem);
    }

    if (elem.focus)
    {
        elem.focus();
    }
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// event.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - keyboard, mouse, and touch related event handling.
///-----------------------------------------------------------------------------------------------------------------
/// cross-browser support for cancelling an event.
vp.cancelEvent = function (evt)
{
    if (evt.preventDefault)
    {
        evt.preventDefault()
    }
    else
    {
        return false;
    }
}

//---- keyCodes (for keyboard test, see: http://unixpapa.com/js/testkey.html) ----
vp.keyCodes = {
    //enter: "Enter", shift: 16, ctrl: 17, alt: 18, escape: "Esc", left: 37, up: 38, right: 39, down: 40,
    enter: 13, shift: 16, ctrl: 17, alt: 18, escape: 27, left: 37, up: 38, right: 39, down: 40,
    insert: 45, home: 36, pageUp: 33, "delete": 46, end: 35, pageDown: 34, space: 32,
    A: 65, Z: 90
};

vp.monitorKeyboard = function (enable)
{
    if (enable)
    {
        vp.attach(window, "keydown", vp.onKeyDown);
        vp.attach(window, "keyup", vp.onKeyUp);
    }
    else
    {
        vp.detach(window, "keydown", vp.onKeyDown);
        vp.detach(window, "keyup", vp.onKeyUp);
    }
};

vp.isKeyPressed = function (keyCode)
{
    return (vp.keyboardKeys[keyCode] == "down");
};

/// used by vp.monitorKeyboard.
vp.onKeyDown = function (evt)
{
    vp.keyboardKeys[evt.keyCode] = "down";
    //vp.debug("keydown: " + evt.keyCode);
};

/// used by vp.monitorKeyboard.
vp.onKeyUp = function (evt)
{
    vp.keyboardKeys[evt.keyCode] = "up";
    //vp.debug("keyup: " + evt.keyCode);
};


/// returns the current mouse positon from the event object "e".  This value is in logical window space,
/// which includes scroll offsets.
vp.mousePosition = function (e, relToParent)
{
    //    var isIe = (document.all);
    //    var xPos = (isIe) ? window.event.clientX + document.documentElement.scrollLeft : e.pageX;
    //    var yPos = (isIe) ? window.event.clientY + document.documentElement.scrollTop : e.pageY;

    var x = e.pageX;
    var y = e.pageY;

    if (relToParent)
    {
        var off = vp.docOffset(relToParent);
        x -= off.left;
        y -= off.top;
    }

    return { x: x, y: y };
};


/// captures the mouse for mouse events on "element".  if "setCapture" is not supported by
/// the browser, it tries to simulate it.  The "mouseMoveCallback" and "mouseUpCallback", if supplied, 
/// are attached to the best element for the situation.
///
/// tested on roland's home machine - 8/5/2012.  seems to work perfectly now on IE9, Chrome, Firefox!
///   - no blue selection as we drag
///   - no system drag/drop interference
///   - cursor stays as specified during drag
///   - on releaseCapture(), all is restored to normal.
vp.setCapture = function (element, evt, mouseMoveCallback, mouseUpCallback)
{
    var useCapture = (element.setCapture);

    vp.mouseMoveWrapper = function (e) { e.vp_element = element; mouseMoveCallback(e) };
    vp.mouseUpWrapper = function (e) { e.vp_element = element; mouseUpCallback(e) };

    if (useCapture)
    {
        //---- listen to events on the ELEMENT ----
        if (mouseMoveCallback)
        {
            vp.attach(element, "mousemove", vp.mouseMoveWrapper);
        }

        if (mouseUpCallback)
        {
            vp.attach(element, "mouseup", vp.mouseUpWrapper);
        }

        //---- prevent text selection by browser during our drag operation (for FireFox) ----
        vp.enableElementSelection(document.body, false);

        element.setCapture();

        element._turnedOffDrawDrop = null;
    }
    else
    {
        //---- listen to events on the DOCUMENT ----
        if (mouseMoveCallback)
        {
            vp.attach(document, "mousemove", vp.mouseMoveWrapper);
        }

        if (mouseUpCallback)
        {
            vp.attach(document, "mouseup", vp.mouseUpWrapper);
        }

        //---- prevent text selection by browser during our drag operation (for Chrome) ----
        vp.enableElementSelection(document.body, false);

        element._turnedOffDrawDrop = vp.enableDragDrop(false);

        var cursorState = vp.css(element, "cursor");
        if (cursorState)
        {
            //---- create a style sheet that keeps cursor constant during capture ----
            var sheet = vp.createStyleSheet()
                .addRule("*", "cursor: " + cursorState)
                .id("vp_setCapture_ss")
        }
    }

    if (evt)
    {
        evt.preventDefault();     // don't allow selection to select text, etc. during our capture
        evt.stopPropagation();
        evt.cancelBubble = true;
    }

    return useCapture;
};

/// captures the mouse for mouse events on "element".
vp.releaseCapture = function (element, evt, mouseMoveCallback, mouseUpCallback)
{
    var callRelease = (element.releaseCapture);

    if (callRelease)
    {
        element.releaseCapture();

        //---- clear events on the ELEMENT ----
        if (vp.mouseMoveWrapper)
        {
            vp.detach(element, "mousemove", vp.mouseMoveWrapper);
            vp.mouseMoveWrapper = null;
        }

        if (vp.mouseUpWrapper)
        {
            vp.detach(element, "mouseup", vp.mouseUpWrapper);
            vp.mouseUpWrapper = null;
        }

        //---- re-enable text selection by browser (for FireFox) ----
        vp.enableElementSelection(document.body, true);
    }
    else
    {
        //---- clear events on the DOCUMENT ----
        if (vp.mouseMoveWrapper)
        {
            vp.detach(document, "mousemove", vp.mouseMoveWrapper);
            vp.mouseMoveWrapper = null;
        }

        if (vp.mouseUpWrapper)
        {
            vp.detach(document, "mouseup", vp.mouseUpWrapper);
            vp.mouseUpWrapper = null;
        }

        //---- re-enable text selection by browser (for Chrome) ----
        vp.enableElementSelection(document.body, true);

        if (element._turnedOffDrawDrop)
        {
            vp.enableDragDrop(true);
        }

        //---- remove the stylesheet, if we created it ----
        var elem = document.getElementById("vp_setCapture_ss");
        if (elem)
        {
            vp.remove(elem);
        }
    }

    return callRelease;
};

vp.stopDragDrop = function(evt)
{
    evt.dataTransfer.dropEffect = 'none';
    evt.stopPropagation();
    evt.preventDefault();
}

vp._isDragDropEnabled = true;

vp.enableDragDrop = function (isEnabled)
{
    if (vp._isDragDropEnabled != isEnabled)
    {
        var body = vp.select(document.body);

        body.attach("dragstart", function (e)
        {
            return isEnabled;
        });

        body.attr("draggable", isEnabled);

        if (isEnabled)
        {
            body.detach("dragenter", vp.stopDragDrop);
            body.detach("ondragover", vp.stopDragDrop);
            body.detach("ondrop", vp.stopDragDrop);
        }
        else
        {
            body.attach("dragenter", vp.stopDragDrop);
            body.attach("ondragover", vp.stopDragDrop);
            body.attach("ondrop", vp.stopDragDrop);
        }

        vp._isDragDropEnabled = isEnabled;
    }
};

vp.attach = function (elem, eventName, funcToCall, useCapturePhase)
{
    if ((eventName == "mousewheel") && (vp.isFireFox))
    {
        eventName = "DOMMouseScroll";
    }

    if ((eventName == "resize") && (elem != window))
    {
        //---- add support for resize events on non-window elements ----
        if (!elem.resizeEvent)
        {
            if (elem.tagName == "circle")
            {
                elem.resizeEvent = { prevWidth: vp.width(elem), prevRadius: vp.attr(elem, "radius"), callBacks: [] };
            }
            else
            {
                elem.resizeEvent = { prevWidth: vp.width(elem), prevHeight: vp.height(elem), callBacks: [] };
            }
        }

        elem.resizeEvent.callBacks.push(funcToCall);
    }
    else
    {
        if ((elem.control) && (elem.control.addEventListener))
        {
            //---- let the control handle the event management ----
            elem.control.addEventListener(eventName, funcToCall);
        }
        else if (elem.addEventListener)
        {
            elem.addEventListener(eventName, funcToCall, useCapturePhase);
        }
        else if (elem.attachEvent)
        {
            elem.attachEvent(eventName, funcToCall);
        }
    }
}

/// trigger the vuePlot "resize" event on the specified elem.
vp.triggerResize = function (elem)
{
    //---- has someone hooked the "resize" event on this elem? ----
    if (!elem.resizeEvent)
    {
        //---- try his kids ----
        var kids = vp.children(elem);
        for (var i = 0; i < kids.length; i++)
        {
            vp.triggerResize(kids[i]);
        }
    }
    else
    {
        var resizeEvent = elem.resizeEvent;

        //---- see if at least one of size properties has really changed ----
        var changed = false;

        if (elem.tagName == "circle")
        {
            var radius = elem.attr("radius");
            changed = (radius != resizeEvent.prevRadius);
            if (changed)
            {
                resizeEvent.prevRadius = radius;
            }
        }
        else
        {
            var width = vp.width(elem);
            var changeWidth = (width != resizeEvent.prevWidth);
            if (changeWidth)
            {
                resizeEvent.prevWidth = width;
            }

            var height = vp.height(elem);
            var changeHeight = (height != resizeEvent.prevHeight);
            if (changeHeight)
            {
                resizeEvent.prevHeight = height;
            }

            changed = (changeWidth || changeHeight);
        }

        if (changed)
        {
            var callBacks = resizeEvent.callBacks;

            for (var i = 0; i < callBacks.length; i++)
            {
                var callBack = callBacks[i];
                var e = { target: elem, type: "resize", currentTarget: elem, cancelable: false, bubbles: false };

                callBack(e);
            }
        }
    }
};

/// window was resized; trigger the "resize" event on the element and all its children
vp.triggerResizeRecursive = function (elem)
{
    if (elem.resizeEvent)
    {
        vp.triggerResize(elem);
    }

    var kids = vp.children(elem);
    if ((kids) && (kids.length > 0))
    {
        for (var i = 0; i < kids.length; i++)
        {
            vp.triggerResizeRecursive(kids[i]);
        }
    }
}

vp.wheelDelta = function (evt)
{
    return (evt.detail) ? -40 * evt.detail : evt.wheelDelta;
};

vp.detach = function (elem, eventName, funcToCall)
{
    if ((eventName == "mousewheel") && (vp.isFireFox))
    {
        eventName = "DOMMouseScroll";
    }

    if ((eventName == "resize") && (elem != window))
    {
        //---- add support for resize events on non-window elements ----
        if (elem.resizeEvent)
        {
            var callBacks = elem.resizeEvent.callBacks;

            for (var i = 0; i < callBacks.length; i++)
            {
                if (callBacks[i] == funcToCall)
                {
                    callBacks.removeAt(i);
                }
            }
        }
    }
    else
    {
        if ((elem.control) && (elem.control.removeEventListener))
        {
            //---- let the control handle the event management ----
            elem.control.removeEventListener(eventName, funcToCall);
        }
        else if (elem.removeEventListener)
        {
            elem.removeEventListener(eventName, funcToCall);
        }
        else if (elem.detachEvent)
        {
            elem.detachEvent(eventName, funcToCall);
        }
    }
}

/// returns the HTML, SVG, or lightweight cavnas element at the specified x,y
/// (pixels from document origin).
vp.elementFromPoint = function (x, y)
{
    //---- first, get the HTML or SVG element from the DOM ----
    var elem = document.elementFromPoint(x, y);
    if (elem != null)
    {
        //---- now, see if there is a canvas element at that location ----
        if (elem.canvasContainerElement)    // its a canvas that contains elements
        {
            //---- make x, y relative to canvas ----
            var off = vp.docOffset(elem);
            x -= off.left;
            y -= off.top;

            elem = elem.canvasContainerElement.getCanvasElementAtPoint(x, y);
        }
    }

    return elem;
}

//---- local init code ----
vp.attach(window, "resize", function (e)
{
    vp.triggerResizeRecursive(document.body);
});



﻿///-----------------------------------------------------------------------------------------------------------------
/// panAndZoom.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library - supports panning and zooming.
///-----------------------------------------------------------------------------------------------------------------
//---- class: zoomBoxHelper ----
vp.zoomBoxHelper = function (wrappedElem)
{
    /// local state
    var origWidth = wrappedElem.width();
    var origHeight = wrappedElem.height();
    var isSvg = vp.isSvgDocOrElement(wrappedElem[0]);
    var left = 0;
    var top = 0;
    var width = 0;
    var height = 0;
    var transformName = "";

    /// closure.
    var closure = function ()
    {
    };

    var init = function ()
    {
        if (!isSvg)
        {
            if (vp.isIE)
            {
                transformName = "msTransform";
            }
            else if (vp.isFireFox)
            {
                transformName = "MozTransform";
            }
            else
            {
                transformName = "-webkit-transform";
            }

        }

        left = 0;
        top = 0;
        width = origWidth;
        height = origHeight;

        vp.debug("zoomBoxHelper: origWidth=" + origWidth + ", origHeight=" + origHeight);
    };

    /// private: updateViewBox().
    var updateViewBox = function ()
    {
        var box = left + ", " + top + ", " + width + ", " + height;
        vp.debug(".updateViewBox: box=" + box);

        if (isSvg)
        {
            wrappedElem.attr("viewBox", box);
        }
        else
        {
            //---- use transform with translate/scale operations ----
            var name = transformName + "Origin";
            var transValue = left + "px " + top + "px";
            wrappedElem.css(name, transValue);

            var xScale = origWidth / width;
            var yScale = origHeight / height;

            var xoff = -left;  //x - xScale * x;
            var yoff = -top;   // y - yScale * y;

            var translate = "translate(" + xoff + "px, " + yoff + "px)";
            var scale = "scale(" + xScale + ", " + yScale + ")";

            //---- transform must come BEFORE scale in this model ----
            var value = translate + " " + scale;

            wrappedElem.css(transformName, value);

        }
    }

    /// public: zoom(factor, cx, cy).
    closure.zoom = function (factor, cx, cy)
    {
        vp.debug(".zoom: cx=" + cx + ", cy=" + cy);

        var oldFactor = width / origWidth;

        //---- adjust zoom factor ----
        width *= factor;
        height *= factor;

        var newFactor = width / origWidth;

        left += cx * (oldFactor - newFactor);
        top += cy * (oldFactor - newFactor);

        updateViewBox();

    }

    /// public pan(dx, dy).
    closure.pan = function (dx, dy)
    {
        //vp.debug(".pan: dx=" + dx + ", dy=" + dy);

        var factor = width / origWidth;

        left += factor * dx;
        top += factor * dy;

        updateViewBox();

    }

    /// public: reset().
    closure.reset = function ()
    {
        left = 0;
        top = 0;
        width = origWidth;
        height = origHeight;

        updateViewBox();
    }

    //---- init code ----
    init();

    return closure;
};

////---- scriptLoader class ----
//vp.onScriptLoaded = function (url)
//{
//    //vp.debug("script loaded: " + url);

//    scripts[url] = 1;
//    checkReady();
//}
﻿///-----------------------------------------------------------------------------------------------------------------
/// rubberBandSelector.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library 
///     - allows user to drag-select elements using a rectangle outline.
///-----------------------------------------------------------------------------------------------------------------
/// public vp.rubberBandSelector(canvasUW, selectCallback)
///     canvasUW - SVG or HTML element that will be used to drag out and draw the selection rectangle
///     selectCallback - the function that will be called when the user completes the selection action
vp.rubberBandSelector = function (canvasUW, selectCallback)
{
    //---- private state ----
    var isEnabled = true;
    var isBanding = false;
    var ptMouseDown = null;
    var rubberBand = null;      // an HTML absolute positioned DIV or SVG rect
    var canvas = vp.unwrap(canvasUW);
    var isSvgCanvas = vp.isSvgDocOrElement(canvas);

    /// closure
    var closure = function ()
    {
    };

    var initBuild = function ()
    {
        if (!isSvgCanvas)
        {
            //---- change canvas so that we can put an absolutely positioned span onto it ----
            vp.css(canvas, "position", "relative");
        }

        vp.attach(canvas, "mousedown", closure.onDown);
        //vp.attach(window, "mousedown", closure.onDown);

        vp.attach(canvas, "keydown", function (e)
        {
            if (e.keyCode == vp.keyCodes.Escape)
            {
                cancelBanding(true, e);
            }
        });
    };

    var setRubberBand = function(rc)
    {
        if (!rubberBand)
        {
            if (isSvgCanvas)
            {
                rubberBand = vp.append(canvas, "rect")

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var da = vp.currentTheme().getDrawingAttributes("dragRect");

                vp.applyShapeAttributes(rubberBand, da);
            }
            else
            {
                rubberBand = vp.append(canvas, "div")
                   .setClass("rubberBand")
                   .css("z-index", "99999")
            }
        }

        if (isSvgCanvas)
        {
            rubberBand
                .bounds(rc.left, rc.top, rc.width, rc.height)
        }
        else
        {
            rubberBand
                .absPosition(rc.left, rc.top)
                .width(rc.width)
                .height(rc.height)
        }
    };

    var clearRubberBand = function()
    {
        if (rubberBand)
        {
            rubberBand.remove();
            rubberBand = null;
        }
    }

    var cancelBanding = function(clearBanding, evt)
    {
        clearRubberBand();
        vp.releaseCapture(canvas, evt);

        if (clearBanding)
        {
            isBanding = false;
        }
    };

    var isToggleKey = function(evt)
    {
        return (evt.ctrlKey);
    };

    closure.onUp = function (evt)
    {
        cancelBanding(false, evt);
        var cancelEvent = false;

        vp.debug("got MOUSE UP on RUBBER BAND canvas");

        try
        {
            if (isBanding)
            {
                var toggle = isToggleKey(evt);

                var ptCurrent = vp.mousePosition(evt, canvas);
                var rcBand = vp.rectFromPoints(ptCurrent, ptMouseDown);

                vp.debug("rcBand: width=" + rcBand.width + ", height=" + rcBand.height);

                //---- allow for a direct click (no movement) ----
                if (true)   //(rcBand.width > 3) && (rcBand.height > 3))
                {
                    vp.debug("calling selectCallback from RUBBER BAND...");

                    if (selectCallback)
                    {
                        selectCallback(rcBand, toggle);
                    }

                    cancelEvent = true;
                }
            }
        }
        catch (ex)
        {
            vp.debug("Exception in rubber banding: " + ex);
            //throw ex;
        }
        finally
        {
            //---- re-enable text selection by browser (for Chrome, FireFox) ----
            vp.enableElementSelection(document.body, true);

            cancelBanding(true, null);
        }

        //if (cancelEvent)
        //{
        //    vp.debug("trying to cancel UP event on RUBBER BAND canvas");

        //    //---- what's the minimum needed here?  this doesn't work in preventing subsequent click event ----
        //    //---- in this particular case ----
        //    evt.preventDefault();
        //    evt.cancelBubble = true;
        //    evt.stopPropagation();
        //    window.event.returnValue = false;
        //    return false;
        //}
    };
    
    closure.onMove = function (evt)
    {
        //try
        {
            if (isBanding)
            {
                var ptCurrent = vp.mousePosition(evt, canvas);
                var rc = vp.rectFromPoints(ptCurrent, ptMouseDown);

                setRubberBand(rc);
            }
        }
        //catch (ex)
        //{
        //    vp.debug("MouseMove Exception: " + ex);
        //}
    };

    closure.onDown = function (evt)
    {
        if (isBanding)                // something went wrong
        {
            cancelBanding(true, evt);
        }
        else if (isEnabled)
        {
            var toggle = isToggleKey(evt);

            //---- prevent text selection by browser during our drag operation (for Chrome, FireFox) ----
            vp.enableElementSelection(document.body, false);

            //---- use chart-relative point & then add chart-relative offset of each series ----
            ptMouseDown = vp.mousePosition(evt, canvas);
            isBanding = true;

            vp.setCapture(canvas, evt, closure.onMove, closure.onUp);
        }
    };

    /// public property: isEnabled
    closure.isEnabled = function (value)
    {
        if (arguments.length == 0)
        {
            return isEnabled;
        }

        isEnabled = value;
        return closure;
    };

    //---- init code ----
    initBuild();

    return closure;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// tooltip.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - class for supporting rich tooltips.
///-----------------------------------------------------------------------------------------------------------------
//---- class: tooltip ----
vp.toolTip = function (ttDiv, ttShowingFunc, swapCtrlKey)
{
    //---- private state ----
    var ttElem = null;          // the element we are showing a tooltip for
    var mousePos = null;        // the current position of the mouse
    var showDelay = 1000;       // how long to wait before making the tooltip visible
    var showDuration = 5000;    // how long to display the tooltip before starting to hide it
    var hideDelay = 500;        // if tooltip is no longer over a tooltip-able item, how long to wait before hiding tooltip
    var timer = null;           // controls timing of showing/hiding tooltip
    var isTooltipEnabled = true;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.toolTip";

    /// public property: isEanbled
    closure.isEnabled = function (value)
    {
        if (arguments.length == 0)
        {
            return isTooltipEnabled;
        }

        isTooltipEnabled = value;
    };

    /// public property: showDelay
    closure.showDelay = function (value)
    {
        if (arguments.length == 0)
        {
            return showDelay;
        }

        showDelay = value;
    };

    /// private: mouseMove()
    var mouseMove = function (e)
    {
        var isCtrlKey = (swapCtrlKey) ? (!e.ctrlKey) : e.ctrlKey;

        //---- hold ctrl key down for debugging (move cursor without triggering event) ----
        if ((isTooltipEnabled) && (!isCtrlKey))
        {
            var pos = vp.mousePosition(e);
            mousePos = pos;

            //---- elementFromPoint() doesn't work for nested SVG documents in some browsers ----
            //---- it turns out "e.target" is very reliable and easy to use. ----
            var elem = vp.elementFromPoint(pos.x, pos.y);
            //var elem = e.target;

            var found = false;

            //vp.debug("tooltip.mouseMove: x=" + pos.x + ", y=" + pos.y + ", elem=" + elem);

            if (elem != null)
            {
                //vp.debug("elem.ctr=" + elem.ctr);
            }

            //---- find the interesting parent of closure child ----
            var parent = elem;
            while ((parent != null) && (parent != ttDiv) && (parent.toolTipContext === undefined))
            {
                parent = parent.parentNode;
            }

            //var isShowing = ((timer != null) || (ttDiv.style.visibility == "visible"));

            if (parent != null)
            {
                found = true;           // found a tooltip element or the tooltip itself

                if (parent == ttDiv)
                {
                    //---- on the tooltip (or one of its children); give it some more time ----
                    //closure.hide(showDuration);
                }
                else if (parent != ttElem)
                {
                    //---- active tooltip elem has changed ----
                    if ((ttElem == null) || (ttDiv.style.visibility == "hidden"))
                    {
                        ttElem = parent;
                        closure.show(showDelay);
                    }
                    else
                    {
                        //---- if an elem was active, make it an instant switch ----
                        ttElem = parent;
                        closure.showNow();
                    }
                }
            }

            if (!found)
            {
                closure.hide(hideDelay);
            }
        }
    };

    /// private: setPositionFromMouse()
    closure.setPositionFromMouse = function ()
    {
        var pos = mousePos;
        pos.y += 20;            // move below mouse cursor bottom

        var tt = ttDiv;

        var tw = vp.width(window);
        var th = vp.height(window);

        var w = vp.width(tt);
        var h = vp.height(tt);

        var scroll = vp.getBodyScroll();

        var ttTop = vp.docOffset(ttElem).top;

        //---- slide left, if needed ----
        var shadowPlus = 10;        // leave some space for shadow & asthetics
        var xover = (pos.x + w + shadowPlus) - tw;
        if ((xover > 0) && (xover <= pos.x))
        {
            //vp.debug("tw=" + tw + ", w=" + w + ", xover=" + xover + ", pos.x=" + pos.x);

            pos.x -= xover;
        }
        else
        {
            //vp.debug("w=" + w + ", h=" + h);
        }

        //---- move above item, if needed ----
        var yover = (pos.y + h + shadowPlus) - th;
        if ((yover > 0) && (h < ttTop))
        {
            pos.y = ttTop - (h + shadowPlus);
        }

        tt.style.left = pos.x + "px";
        tt.style.top = pos.y + "px";
    };

    /// private: cancelTimers()
    closure.cancelTimers = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    /// public: show()
    /// show the tooltip in delay ms (or now, if delay is undefined.
    closure.show = function (delay)
    {
        closure.cancelTimers();

        if (isTooltipEnabled)
        {
            if (delay)
            {
                timer = setTimeout(closure.showNow, delay);
            }
            else
            {
                closure.showNow();
            }
        }
    }

    /// public: showNow()
    /// show the tooltip immediately and set a timer for when to start hiding it.
    closure.showNow = function ()
    {
        if ((ttElem != null) && (isTooltipEnabled))
        {
            var showIt = true;

            if (ttShowingFunc)
            {
                showIt = ttShowingFunc(ttElem);
            }

            if (showIt)
            {
                //---- make visible first, so "setPositionFromMouse" can correctly measure size of tooltip ----
                vp.left(ttDiv, -100000);        // move offscreen while we calculate its desired position
                ttDiv.style.visibility = "visible";

                setTimeout(closure.onTooltipReadyToMeasure, 1);
                //closure.setPositionFromMouse();
                //closure.hide(showDuration);
            }
        }
    };

    closure.onTooltipReadyToMeasure = function (e)
    {
        closure.setPositionFromMouse();
        //closure.hide(showDuration);
    };

    /// public: hide()
    closure.hide = function (delay)
    {
        //vp.debug("tt.hide called");

        closure.cancelTimers();

        if (delay)
        {
            timer = setTimeout(closure.hideNow, delay);
        }
        else
        {
            closure.hideNow();
        }
    };

    closure.hideNow = function ()
    {
        //---- experiment ----
        var w = vp.width(ttDiv);

        closure.cancelTimers();
        ttElem = null;

        ttDiv.style.visibility = "hidden";
    };

    //---- init code ----
    document.addEventListener("mousemove", mouseMove);

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// touch.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - handles touch events.
///-----------------------------------------------------------------------------------------------------------------
///
/// touchEventHandler class
///
///     this class adapted from microsoft blog code:
///         adapted from: http://blogs.msdn.com/b/ie/archive/2011/10/19/handling-multi-touch-and-mouse-input-in-all-browsers.aspx
///
///     target - the HTML element object which is the target of the touch event
///
///     touchDownFunc - called when one of a TOUCH DOWN (or mouse/stylus down) event occurs.
///          5 params: target, pointerId, x, y, evt.        x and y are guaranteed to be within target's rectange.
///
///     touchMoveFunc - called when one of a TOUCH MOVE (or mouse/stylus move) event occurs.  same params.
///
///     touchUpFunc - called when one of a TOUCH UP (or mouse/stylus up) event occurs.  same params.
///
///     - The "touchXXXFunc" params are all optional.
///     - The target element cannot move within the document during drawing.
///
vp.touchEventHandlerFactory = function (target, touchDownFunc, touchMoveFunc, touchUpFunc)
{
    //---- lastXYById is an object to keep track of the last x/y positions of the mouse/pointer/touch point ----
    //---- used to reject redundant moves and as a flag to determine if we're in the "down" state ----
    this.lastXYById = {};

    //--- opera doesn't have Object.keys so we use this wrapper ----
    this.numberOfKeys = function (theObject)
    {
        if (Object.keys)
            return Object.keys(theObject).length;

        var n = 0;
        for (var key in theObject)
            ++n;

        return n;
    };

    //  IE10's implementation in the Windows Developer Preview requires doing all of this
    //  Not all of these methods remain in the Windows Consumer Preview, hence the tests for method existence.
    this.preventDefaultManipulationAndMouseEvent = function (evtObj)
    {
        if (evtObj.preventDefault)
            evtObj.preventDefault();

        if (evtObj.preventManipulation)
            evtObj.preventManipulation();

        if (evtObj.preventMouseEvent)
            evtObj.preventMouseEvent();
    };

    //  we send target-relative coordinates to the draw functions
    //  this calculates the delta needed to convert pageX/Y to offsetX/Y because offsetX/Y don't exist in the TouchEvent object or in Firefox's MouseEvent object
    this.computeDocumentToElementDelta = function (theElement)
    {
        var off = vp.docOffset(theElement);
        var elementLeft = off.left;
        var elementTop = off.top;

        //        for (var offsetElement = theElement; offsetElement != null; offsetElement = offsetElement.offsetParent)
        //        {
        //            //  the following is a major hack for versions of IE less than 8 to avoid an apparent problem on the IEBlog with double-counting the offsets
        //            //  this may not be a general solution to IE7's problem with offsetLeft/offsetParent
        //            if (navigator.userAgent.match(/\bMSIE\b/) && (!document.documentMode || document.documentMode < 8) && offsetElement.currentStyle.position == "relative" && offsetElement.offsetParent && offsetElement.offsetParent.currentStyle.position == "relative" && offsetElement.offsetLeft == offsetElement.offsetParent.offsetLeft)
        //            {
        //                // add only the top
        //                elementTop += offsetElement.offsetTop;
        //            }
        //            else
        //            {
        //                elementLeft += offsetElement.offsetLeft;
        //                elementTop += offsetElement.offsetTop;
        //            }
        //        }

        return { x: elementLeft, y: elementTop };
    };

    //  function needed because IE versions before 9 did not define pageX/Y in the MouseEvent object
    this.ensurePageXY = function (eventObj)
    {
        if (typeof eventObj.pageX == 'undefined')
        {
            //  initialize assuming our source element is our target
            eventObj.pageX = eventObj.offsetX + documentToTargetDelta.x;
            eventObj.pageY = eventObj.offsetY + documentToTargetDelta.y;

            if (eventObj.srcElement.offsetParent == target && document.documentMode && document.documentMode == 8 && eventObj.type == "mousedown")
            {
                //  source element is a child piece of VML, we're in IE8, and we've not called setCapture yet - add the origin of the source element
                eventObj.pageX += eventObj.srcElement.offsetLeft;
                eventObj.pageY += eventObj.srcElement.offsetTop;
            }
            else if (eventObj.srcElement != target && !document.documentMode || document.documentMode < 8)
            {
                //  source element isn't the target (most likely it's a child piece of VML) and we're in a version of IE before IE8 -
                //  the offsetX/Y values are unpredictable so use the clientX/Y values and adjust by the scroll offsets of its parents
                //  to get the document-relative coordinates (the same as pageX/Y)
                var sx = -2, sy = -2;   // adjust for old IE's 2-pixel border
                for (var scrollElement = eventObj.srcElement; scrollElement != null; scrollElement = scrollElement.parentNode)
                {
                    sx += scrollElement.scrollLeft ? scrollElement.scrollLeft : 0;
                    sy += scrollElement.scrollTop ? scrollElement.scrollTop : 0;
                }

                eventObj.pageX = eventObj.clientX + sx;
                eventObj.pageY = eventObj.clientY + sy;
            }
        }
    };

    //  functions to convert document-relative coordinates to target-relative and constrain them to be within the target
    this.targetRelativeX = function (px)
    {
        return Math.max(0, Math.min(px - documentToTargetDelta.x, vp.width(target)));
    };

    this.targetRelativeY = function (py)
    {
        return Math.max(0, Math.min(py - documentToTargetDelta.y, vp.height(target)));
    };

    var self = this;

    //  common event handler for the mouse/pointer/touch models and their down/start, move, up/end, and cancel events
    this.doEvent = function (theEvtObj)
    {
        //vp.debug("touchEventHandler.doEvent: BEFORE FILTER: theEvtObj.type=" + theEvtObj.type);

        //  optimize rejecting mouse moves when mouse is up
        if ((theEvtObj.type == "mousemove") && (vp.numberOfKeys(self.lastXYById) == 0))
        {
            return;
        }

        vp.debug("touchEventHandler.doEvent: theEvtObj.type=" + theEvtObj.type);

        self.preventDefaultManipulationAndMouseEvent(theEvtObj);

        var pointerList = theEvtObj.changedTouches ? theEvtObj.changedTouches : [theEvtObj];

        for (var i = 0; i < pointerList.length; ++i)
        {
            var pointerObj = pointerList[i];
            var pointerId = (typeof pointerObj.identifier != 'undefined') ? pointerObj.identifier : (typeof pointerObj.pointerId != 'undefined') ? pointerObj.pointerId : 1;

            //  use the pageX/Y coordinates to compute target-relative coordinates when we have them (in ie < 9, we need to do a little work to put them there)
            self.ensurePageXY(pointerObj);

            var pageX = pointerObj.pageX;
            var pageY = pointerObj.pageY;

            if (theEvtObj.type.match(/(start|down)$/i))
            {
                //  clause for processing MSPointerDown, touchstart, and mousedown

                //  refresh the document-to-target delta on start in case the target has moved relative to document
                documentToTargetDelta = self.computeDocumentToElementDelta(target);

                //  protect against failing to get an up or end on this pointerId
                if (self.lastXYById[pointerId])
                {
                    if (touchUpFunc)
                    {
                        touchUpFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    }

                    delete self.lastXYById[pointerId];
                }

                if (touchDownFunc)
                {
                    var result = touchDownFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    if (result !== undefined)
                    {
                        self.useCapture = result;
                    }
                }

                //  init last page positions for this pointer
                self.lastXYById[pointerId] = { x: pageX, y: pageY };

                //  in the Microsoft pointer model, set the capture for this pointer
                //  in the mouse model, set the capture or add a document-level event handlers if this is our first down point
                //  nothing is required for the iOS touch model because capture is implied on touchstart
                if (target.msSetPointerCapture)
                {
                    target.msSetPointerCapture(pointerId);
                }
                else if (theEvtObj.type == "mousedown" && self.numberOfKeys(self.lastXYById) == 1)
                {
                    if ((self.useCapture) && (target.setCapture))
                    {
                        target.setCapture(true);
                        vp.debug("mouse captured on TARGET: " + target);
                    }
                    else
                    {
                        //---- if we cannot capture the mouse, we must listen to all document move/up events ----
                        //---- to simulate a mouse capture.  In particular, it is CRITICAL that we listen to ----
                        //---- document mouseup so we know when to terminate the caller's drag operation ----
                        document.body.addEventListener("mousemove", this.doEvent, false);
                        document.body.addEventListener("mouseup", this.doEvent, false);

                        if ((self.useCapture) && (document.body.setCapture))
                        {
                            document.body.setCapture(true);
                            vp.debug("mouse captured on DOCUMENT.BODY");
                        }
                    }
                }
            }
            else if (theEvtObj.type.match(/move$/i))
            {
                //  clause handles mousemove, MSPointerMove, and touchmove

                if (self.lastXYById[pointerId] && !(self.lastXYById[pointerId].x == pageX && self.lastXYById[pointerId].y == pageY))
                {
                    documentToTargetDelta = self.computeDocumentToElementDelta(target);

                    //  only extend if the pointer is down and it's not the same as the last point
                    if (touchMoveFunc)
                    {
                        touchMoveFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    }

                    //  update last page positions for this pointer
                    self.lastXYById[pointerId].x = pageX;
                    self.lastXYById[pointerId].y = pageY;
                }
            }
            else if (self.lastXYById[pointerId] && theEvtObj.type.match(/(up|end|cancel)$/i))
            {
                //  clause handles up/end/cancel

                if (touchUpFunc)
                {
                    touchUpFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                }

                //  delete last page positions for this pointer
                delete self.lastXYById[pointerId];

                //  in the Microsoft pointer model, release the capture for this pointer
                //  in the mouse model, release the capture or remove document-level event handlers if there are no down points
                //  nothing is required for the iOS touch model because capture is implied on touchstart
                if (target.msReleasePointerCapture)
                {
                    target.msReleasePointerCapture(pointerId);
                }
                else if (theEvtObj.type == "mouseup" && self.numberOfKeys(self.lastXYById) == 0)
                {
                    if ((self.useCapture) && (target.releaseCapture))
                    {
                        target.releaseCapture();
                    }
                    else
                    {
                        document.removeEventListener("mousemove", this.doEvent, false);
                        document.removeEventListener("mouseup", this.doEvent, false);
                    }
                }
            }
        }
    };

    //---- start up code ----
    self.useCapture = false;

    //---- cache the delta from the document to our event target ----
    var documentToTargetDelta = this.computeDocumentToElementDelta(target);

    if (window.navigator.msPointerEnabled)
    {
        //---- hook Microsoft "pointer model" events ----
        target.addEventListener("MSPointerDown", this.doEvent, false);
        target.addEventListener("MSPointerMove", this.doEvent, false);
        target.addEventListener("MSPointerUp", this.doEvent, false);
        target.addEventListener("MSPointerCancel", this.doEvent, false);

        //---- prevent panning when we touch our target area ----
        if (typeof target.style.msContentZooming != 'undefined')
        {
            target.style.msContentZooming = "none";
        }

        //---- don't let IE steal our touch events ----
        if (typeof target.style.msTouchAction != 'undefined')
        {
            target.style.msTouchAction = "none";
        }
    }
    else if (target.addEventListener)
    {
        //---- hook IOS touch model events ----
        target.addEventListener("touchstart", this.doEvent, false);
        target.addEventListener("touchmove", this.doEvent, false);
        target.addEventListener("touchend", this.doEvent, false);
        target.addEventListener("touchcancel", this.doEvent, false);

        //---- hook mouse events ----
        target.addEventListener("mousedown", this.doEvent, false);

        //---- does this browser support capturing the mouse? ----
        if (true)      
        {
            //---- don't hook for Gecko browsers since they don't send events when the mouse is outside target ----
            if (true)   // set to true to fix for Chrome     //!window.navigator.userAgent.match(/\bGecko\b/))
            {
                self.useCapture = true;

                target.addEventListener("mousemove", this.doEvent, false);
                target.addEventListener("mouseup", this.doEvent, false);
            }
        }
    }
    else if ((target.attachEvent) && (target.setCapture))
    {
        //---- legacy IE mode - hook mouse events and use mouse capture ----
        self.useCapture = true;

        target.attachEvent("onmousedown", function ()
        {
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });

        target.attachEvent("onmousemove", function ()
        {
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });

        target.attachEvent("onmouseup", function ()
        { 
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });
    }
};

vp.touchEventHandler = function (target, touchDownFunc, touchMoveFunc, touchUpFunc)
{
    return new vp.touchEventHandlerFactory(target, touchDownFunc, touchMoveFunc, touchUpFunc);
};
///-----------------------------------------------------------------------------------------------------------------
/// baseLayout.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - base class for layouts.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        var baseLayoutClass = (function () {
            function baseLayoutClass() {
                //---- private state ----
                this._width = 100;
                this._height = 100;
                this._count = 1;
                this._useCenter = false;
            }
            baseLayoutClass.prototype.getBoundsByIndex = function (index) {
                return this.makeBounds(0, 0, this._width, this._height);
            };

            baseLayoutClass.prototype.makeBounds = function (x, y, w, h) {
                if (this._useCenter) {
                    x += w / 2;
                    y += h / 2;
                }

                return { x: x, y: y, width: w, height: h };
            };

            baseLayoutClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._width;
                } else {
                    //--- SET value ----
                    this._width = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._height;
                } else {
                    //--- SET value ----
                    this._height = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.count = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._count;
                } else {
                    //--- SET value ----
                    this._count = Math.round(value);
                    return this;
                }
            };

            baseLayoutClass.prototype.useCenter = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._useCenter;
                } else {
                    //--- SET value ----
                    this._useCenter = value;
                    return this;
                }
            };
            return baseLayoutClass;
        })();
        layouts.baseLayoutClass = baseLayoutClass;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dock.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items within a docking container.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /**  returns a path layout object that will layout items within a docking container. */
        var dockClass = (function (_super) {
            __extends(dockClass, _super);
            //_childDatas = [];
            //_layoutNeeded = false;
            function dockClass() {
                _super.call(this);
                //---- private state ----
                this._needInit = true;
                this._left = 0;
                this._top = 0;
                this._right = 0;
                this._bottom = 0;
            }
            dockClass.prototype.init = function () {
                this._left = 0;
                this._top = 0;
                this._right = _super.prototype.width.call(this) - 1;
                this._bottom = _super.prototype.height.call(this) - 1;

                this._needInit = false;
            };

            dockClass.prototype.getBounds = function (itemWidth, itemHeight, dockType) {
                if (this._needInit) {
                    this.init();
                }

                var x = this._left;
                var y = this._top;

                if (dockType == "left") {
                    this._left += itemWidth;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "top") {
                    this._top += itemHeight;
                    itemWidth = this.makeSize(this._right - this._left);
                } else if (dockType == "right") {
                    x = this._right - itemWidth;
                    this._right = x;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "bottom") {
                    y = this._bottom - itemHeight;
                    this._bottom = y;
                    itemWidth = this.makeSize(this._right - this._left);
                } else {
                    itemWidth = this.makeSize(this._right - this._left);
                    itemHeight = this.makeSize(this._bottom - this._top);
                }
                ;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            dockClass.prototype.makeSize = function (value) {
                return Math.max(0, value);
            };
            return dockClass;
        })(vp.layouts.baseLayoutClass);
        layouts.dockClass = dockClass;

        function createDock() {
            return new dockClass();
        }
        layouts.createDock = createDock;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// grid.ts.  Copyright (c) 2012 Microsoft Corporation.
///           Part of the vuePlot library - lays out items in an X/Y grid.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see layouts.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a grid layout object that will layout items in a rectangular grid shape. */
        var gridClass = (function (_super) {
            __extends(gridClass, _super);
            function gridClass() {
                _super.call(this);
                //---- private state ----
                this._userRows = undefined;
                this._userColumns = undefined;
                this._rows = 1;
                this._columns = 1;
                this._layoutNeeded = true;
            }
            gridClass.prototype.getBoundsByIndex = function (index) {
                if (this._layoutNeeded) {
                    this.computeLayout();
                }

                var width = _super.prototype.width.call(this);
                var height = _super.prototype.height.call(this);

                if ((this._rows < 1) || (this._columns < 1) || (_super.prototype.count.call(this) <= 1)) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = width / this._columns;
                var itemHeight = height / this._rows;

                var row = Math.floor(index / this._columns);
                var col = index % this._columns;

                var x = col * itemWidth;
                var y = row * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            gridClass.prototype.markLayoutNeeded = function () {
                this._layoutNeeded = true;
            };

            //---- private: computeLayout() ----
            gridClass.prototype.computeLayout = function () {
                this._layoutNeeded = false;
                var count = _super.prototype.count.call(this);

                if (vp.isDefined(this._userRows)) {
                    this._rows = this._userRows;
                    this._columns = (this._userColumns === undefined) ? Math.ceil(this._count / this._rows) : this._userColumns;
                } else {
                    this._columns = (this._userColumns === undefined) ? Math.ceil(Math.sqrt(count)) : this._userColumns;
                    this._rows = Math.ceil(this._count / this._columns);
                }
            };

            gridClass.prototype.rowCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userRows;
                } else {
                    //--- SET value ----
                    this._userRows = value;
                    return this;
                }
            };

            gridClass.prototype.colCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userColumns;
                } else {
                    //--- SET value ----
                    this._userColumns = value;
                    return this;
                }
            };
            return gridClass;
        })(vp.layouts.baseLayoutClass);
        layouts.gridClass = gridClass;

        function createGrid() {
            return new gridClass();
        }
        layouts.createGrid = createGrid;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// horizontal.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the horizontal direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a horizontal object closure that will layout items from left to right. */
        var horizontalClass = (function (_super) {
            __extends(horizontalClass, _super);
            function horizontalClass() {
                _super.call(this);
            }
            horizontalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this) / _super.prototype.count.call(this);
                var itemHeight = _super.prototype.height.call(this);

                var x = index * itemWidth;
                var y = 0;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return horizontalClass;
        })(vp.layouts.baseLayoutClass);
        layouts.horizontalClass = horizontalClass;

        function createHorizontal() {
            return new horizontalClass();
        }
        layouts.createHorizontal = createHorizontal;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// path.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items along an SVG layeretry path.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a path layout object that will layout items along an SVG layeretry path. */
        var pathClass = (function (_super) {
            __extends(pathClass, _super);
            function pathClass() {
                _super.call(this);
                //---- private state ----
                this._path = null;
                this._itemWidth = 100;
                this._itemHeight = 100;
                this._atStart = true;
                this._atEnd = true;
            }
            pathClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                //---- NOTE: this is NOT supported on IE9 (but IE10 supports it) ----
                var bounds = null;

                if (this._path.getTotalLength) {
                    var total = this._path.getTotalLength();
                    var pcount = _super.prototype.count.call(this);
                    if (!this._atEnd) {
                        pcount++;
                    }

                    if (!this._atStart) {
                        index++;
                        pcount++;
                    }

                    var percent = index / (pcount - 1);

                    var pt = this._path.getPointAtLength(percent * total);

                    bounds = _super.prototype.makeBounds.call(this, pt.x, pt.y, this._itemWidth, this._itemHeight);
                } else {
                    //---- not yet implemented ----
                    bounds = _super.prototype.makeBounds.call(this, 0, 0, 100, 100);
                }

                return bounds;
            };

            pathClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            pathClass.prototype.path = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._path;
                } else {
                    //--- SET value ----
                    this._path = value;
                    return this;
                }
            };

            pathClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            pathClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };

            pathClass.prototype.atStart = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atStart;
                } else {
                    //--- SET value ----
                    this._atStart = value;
                    return this;
                }
            };

            pathClass.prototype.atEnd = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atEnd;
                } else {
                    //--- SET value ----
                    this._atEnd = value;
                    return this;
                }
            };
            return pathClass;
        })(vp.layouts.baseLayoutClass);
        layouts.pathClass = pathClass;

        function createPath() {
            return new pathClass();
        }
        layouts.createPath = createPath;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// random.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in random places.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a random layout object that will layout items in random (overlapping) places. */
        var randomClass = (function (_super) {
            __extends(randomClass, _super);
            function randomClass() {
                _super.call(this);
                //---- private state ----
                this._itemWidth = 100;
                this._itemHeight = 100;
            }
            randomClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var x = this.rand(0, _super.prototype.width.call(this) - this._itemWidth);
                var y = this.rand(0, _super.prototype.height.call(this) - this._itemHeight);

                return _super.prototype.makeBounds.call(this, x, y, this._itemWidth, this._itemHeight);
            };

            randomClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            randomClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            randomClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };
            return randomClass;
        })(vp.layouts.baseLayoutClass);
        layouts.randomClass = randomClass;

        function createRandom() {
            return new randomClass();
        }
        layouts.createRandom = createRandom;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vertical.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the vertical direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a vertical layout object that will layout items from top to bottom. */
        var verticalClass = (function (_super) {
            __extends(verticalClass, _super);
            function verticalClass() {
                _super.call(this);
            }
            verticalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this);
                var itemHeight = _super.prototype.height.call(this) / _super.prototype.count.call(this);

                var x = 0;
                var y = index * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return verticalClass;
        })(vp.layouts.baseLayoutClass);
        layouts.verticalClass = verticalClass;

        function createVertical() {
            return new verticalClass();
        }
        layouts.createVertical = createVertical;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// attribute.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an attribute object (hold constant value or mapping information) for an attribute like "x" or "color".
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var attributeClass = (function () {
            function attributeClass(attrName, scale) {
                //---- public field ----
                this.ctr = "vp.scales.attributeClass";
                this.layerDefaults = new vp.layers.attrDefaults();
                this.plotDefaults = new vp.layers.attrDefaults();
                //---- debugging support ----
                this._attrName = "";
                this._owner = null;
                //---- for drawing legend/axis ----
                this._breaks = undefined;
                this._labels = undefined;
                this._zeroAxis = undefined;
                this._domainMin = undefined;
                this._domainMax = undefined;
                this._isDiscrete = undefined;
                this._combineDups = undefined;
                this._numDecimalPlaces = undefined;
                this._useNiceNumbers = undefined;
                this._tickCount = undefined;
                this._intOnlyBreaks = undefined;
                this._addHeadRoom = undefined;
                this._expandSpace = undefined;
                this._title = undefined;
                this._flipInLegend = undefined;
                this._formatter = undefined;
                this._isLegendVisible = true;
                this._isScalingEnabled = true;
                this._calculatedTickCount = undefined;
                //---- TODO: add support for "_expand" property (adds space to X and Y axes beyond domainMin/domainMax) -----
                //---- for scaling /formatting of values ----
                //_dataMin: number = undefined;       // calculated from simple/stacking data
                //_dataMax: number = undefined;       // calculated from simple/stacking data
                this._value = undefined;
                this._colName = undefined;
                this._palette = undefined;
                this._colData = null;
                this._percentGap = undefined;
                this._dateFormat = undefined;
                this._afterPropName = null;
                this._scale = null;
                this._scaleNeedsSetup = true;
                this._attrName = attrName;
                this._scale = scale;
            }
            /** sets one or more attribute properties.  If 'value' is an array of strings, it sets
            the 'colName' property.  If 'value' is a scalar, it sets the 'value' property.
            Otherwise, if 'value' is an object with key/value pairs, it is used to set
            the names properties of the attribute.  */
            attributeClass.prototype.quickSet = function (value) {
                var isArray = vp.isArray(value);

                if (isArray && value.length && vp.isString(value[0])) {
                    this.colName(value);
                } else if ((value != null) && (!isArray) && (vp.isObject(value))) {
                    //---- a set of key/value pairs on the object ----
                    var keys = vp.keys(value);
                    for (var k = 0; k < keys.length; k++) {
                        var key = keys[k];
                        var val = value[key];

                        this[key](val); // call our setter function for this property
                    }
                } else {
                    //---- primitive value passed in ----
                    this._value = value;
                    ;
                    this._colName = undefined;
                }

                return (this._owner) ? this._owner : this;
            };

            attributeClass.prototype.getActualIsDiscrete = function () {
                var value = (this._isDiscrete !== undefined) ? this._isDiscrete : this.plotDefaults.isDiscrete;
                if (value === undefined) {
                    value = this.layerDefaults.isDiscrete;
                }

                return value;
            };

            attributeClass.prototype.getActualZeroAxis = function () {
                var value = (this._zeroAxis !== undefined) ? this._zeroAxis : this.layerDefaults.zeroAxis;
                return value;
            };

            attributeClass.prototype.getActualCombineDups = function () {
                var value = (this._combineDups !== undefined) ? this._combineDups : this.layerDefaults.combineDups;
                return value;
            };

            attributeClass.prototype.getActualIntOnlyBreaks = function () {
                var value = (this._intOnlyBreaks !== undefined) ? this._intOnlyBreaks : this.layerDefaults.intOnlyBreaks;
                return value;
            };

            attributeClass.prototype.getActualPercentGap = function () {
                var value = (this._percentGap !== undefined) ? this._percentGap : this.layerDefaults.percentGap;
                return value;
            };

            attributeClass.prototype.getActualTickCount = function () {
                //---- special case: here, we use "_calculatedTickCount" as override ----
                var value = (this._calculatedTickCount !== undefined) ? this._calculatedTickCount : this.layerDefaults.tickCount;
                return value;
            };

            attributeClass.prototype.getActualAddHeadroom = function () {
                var value = (this._addHeadRoom !== undefined) ? this._addHeadRoom : this.layerDefaults.addMaxHeadroom;
                return value;
            };

            attributeClass.prototype.getActualExpandSpace = function () {
                var value = this._expandSpace;
                return value;
            };

            attributeClass.prototype.getActualUseNiceNumbers = function () {
                var value = (this._useNiceNumbers !== undefined) ? this._useNiceNumbers : this.layerDefaults.useNiceNumbers;

                //var minSpecified = ((this._domainMin !== undefined) || (this.defaults.dataMin !== undefined));
                //var maxSpecified = ((this._domainMax !== undefined) || (this.defaults.dataMax !== undefined));
                //if (minSpecified || maxSpecified)
                //{
                //    value = false;
                //}
                return value;
            };

            attributeClass.prototype.getActualDateFormat = function () {
                var value = (this._dateFormat !== undefined) ? this._dateFormat : this.layerDefaults.dateFormat;
                return value;
            };

            //getActualData()
            //{
            //    var value;
            //    if (this._colData !== undefined)
            //    {
            //        value = this._colData;
            //    }
            //    else
            //    {
            //        value = this.systemDefaults.dataOverride;
            //    }
            //    return value;
            //}
            attributeClass.prototype.needsSetUp = function (value) {
                if (arguments.length === 0) {
                    return this._scaleNeedsSetup;
                }

                this._scaleNeedsSetup = value;
                return this;
            };

            /** the constant value of the attribute. */
            attributeClass.prototype.value = function (val) {
                if (arguments.length === 0) {
                    return this._value;
                }

                this._value = val;
                if (val !== undefined) {
                    this._colName = undefined;
                }

                return this;
            };

            attributeClass.prototype.dateFormat = function (value) {
                if (arguments.length === 0) {
                    return this._dateFormat;
                }

                this._dateFormat = value;

                return this;
            };

            attributeClass.prototype.combineDups = function (value) {
                if (arguments.length === 0) {
                    return this._combineDups;
                }

                this._combineDups = value;
                return this;
            };

            attributeClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }

                this._expandSpace = value;
                return this;
            };

            attributeClass.prototype.addHeadRoom = function (value) {
                if (arguments.length === 0) {
                    return this._addHeadRoom;
                }

                this._addHeadRoom = value;
                return this;
            };

            attributeClass.prototype.intOnlyBreaks = function (value) {
                if (arguments.length === 0) {
                    return this._intOnlyBreaks;
                }

                this._intOnlyBreaks = value;
                return this;
            };

            attributeClass.prototype.isLegendVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isLegendVisible;
                }

                this._isLegendVisible = value;
                return this;
            };

            attributeClass.prototype.isScalingEnabled = function (value) {
                if (arguments.length === 0) {
                    return this._isScalingEnabled;
                }

                this._isScalingEnabled = value;
                return this;
            };

            attributeClass.prototype.zeroAxis = function (value) {
                if (arguments.length === 0) {
                    return this._zeroAxis;
                }

                this._zeroAxis = value;
                return this;
            };

            attributeClass.prototype.useNiceNumbers = function (value) {
                if (arguments.length === 0) {
                    return this._useNiceNumbers;
                }

                this._useNiceNumbers = value;
                return this;
            };

            attributeClass.prototype.tickCount = function (value) {
                if (arguments.length === 0) {
                    return this._tickCount;
                }

                this._tickCount = value;
                return this;
            };

            attributeClass.prototype.domainMin = function (value) {
                if (arguments.length === 0) {
                    return this._domainMin;
                }

                this._domainMin = value;
                if (value !== undefined) {
                    this.zeroAxis(false);
                }
                return this;
            };

            attributeClass.prototype.domainMax = function (value) {
                if (arguments.length === 0) {
                    return this._domainMax;
                }

                this._domainMax = value;
                if (value !== undefined) {
                    this.zeroAxis(false);
                }
                return this;
            };

            attributeClass.prototype.percentGap = function (value) {
                if (arguments.length === 0) {
                    return this._percentGap;
                }

                this._percentGap = value;
                return this;
            };

            attributeClass.prototype.formatter = function (value) {
                if (arguments.length === 0) {
                    return this._formatter;
                }

                this._formatter = value;
                return this;
            };

            attributeClass.prototype.numDecimalPlaces = function (value) {
                if (arguments.length === 0) {
                    return this._numDecimalPlaces;
                }

                this._numDecimalPlaces = value;
                return this;
            };

            attributeClass.prototype.breaks = function (value) {
                if (arguments.length === 0) {
                    return this._breaks;
                }

                this._breaks = value;
                this.onBreaksChanged();

                return this;
            };

            attributeClass.prototype.onBreaksChanged = function () {
                var breaks = (this._breaks) ? this._breaks : this.layerDefaults.breaks;

                if (breaks && breaks.length) {
                    this.layerDefaults.dataMin = breaks.min();
                    this.layerDefaults.dataMax = breaks.max();
                    this.layerDefaults.isMinMaxSoft = false;

                    var isDiscrete = this.getActualIsDiscrete();
                    this.layerDefaults.tickCount = (isDiscrete) ? (1 + breaks.length) : breaks.length;
                    this.layerDefaults.useNiceNumbers = false;

                    this._scaleNeedsSetup = true;
                }
            };

            attributeClass.prototype.labels = function (value) {
                if (arguments.length === 0) {
                    return this._labels;
                }

                this._labels = value;
                return this;
            };

            /** gets the actual formatting function to be used to label values in the axis/legend for this attribute. */
            attributeClass.prototype.getActualFormatter = function () {
                var actual = this._formatter;
                if (!actual) {
                    var isDiscrete = this.getActualIsDiscrete();
                    var dateFormat = this.getActualDateFormat();

                    if (isDiscrete) {
                        actual = vp.formatters.string;
                    } else if (dateFormat) {
                        actual = eval("vp.formatters." + dateFormat);
                    } else {
                        actual = vp.formatters.comma;
                    }
                }

                return actual;
            };

            /** Running stats on our data can change our X and Y column mappings.  This function returns
            the new property name assoicated with this attribute. */
            attributeClass.prototype.getAfterStatsPropName = function (seriesIndex) {
                var propName = this._afterPropName;

                if (!propName) {
                    //----- use original colName ----
                    if (this._colName && this._colName.length) {
                        if (seriesIndex >= this._colName.length) {
                            seriesIndex = 0;
                        }

                        propName = this._colName[seriesIndex];
                    }
                }

                return propName;
            };

            /** gets the actual array of input data values used for the axis/legend breaks for this attribute.
            The user-specified set of breaks takes priority.
            Otherwise, for DISCRETE attributes WITH Dup merging, this is the set of unique key values with a NULL appended at the end;
            Otherwise, for DISCRETE attributes WITHOUT Dup merging, this is the 0-relative set of index values for each row with an
            "N" (the record count) appended at the end;
            For "_seriesIndex", this is the 0-relative set of index values for each series;
            Otherwise, (most popular case) it is the set of "tickCount" values between "min" and "max". */
            attributeClass.prototype.getActualBreaks = function () {
                var actual = (this._breaks !== undefined) ? this._breaks : this.layerDefaults.breaks;
                if (!actual) {
                    actual = [];

                    if (this._scale) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        var propName = this.getAfterStatsPropName(0);

                        var isDiscrete = this.getActualIsDiscrete();
                        if (isDiscrete) {
                            if (this._colData && this._colData.length) {
                                actual = this._colData;
                                var combineDups = this.getActualCombineDups();

                                if (combineDups) {
                                    actual = actual.distinct();
                                    actual.push(null); // for extra tick
                                } else if (actual && actual.length) {
                                    actual = vp.range(0, actual.length, 1); //  - 1, 1);
                                }
                            }
                        } else if (propName == "_seriesIndex") {
                            //actual = this._colData;
                            actual = vp.range(min, max, 1);
                        } else {
                            //---- generate breaks from min/max/tickCount scale ----
                            var tickCount = this.getActualTickCount();

                            var incr = (max - min) / (tickCount - 1);
                            actual = vp.range(min, max, incr);
                        }
                    }
                }

                return actual;
            };

            /** returns the actual labels for the associated axis/legend. */
            attributeClass.prototype.getActualLabels = function (breakData) {
                if (!breakData) {
                    breakData = this.getActualBreaks();
                }

                var actual = this._labels;
                if (!actual) {
                    actual = [];

                    if (this.isMapped()) {
                        var formatter = this.getActualFormatter();
                        var propName = this.getAfterStatsPropName(0);

                        var count = breakData.length;
                        if (this.getActualIsDiscrete()) {
                            count--;
                        }

                        actual = [];

                        //---- for comma formatter, look at the range of break values to determine the best numDecimals to use ----
                        var numDecimals = this._numDecimalPlaces;

                        if ((formatter == vp.formatters.comma) && (numDecimals == undefined)) {
                            var range = this._scale._domainMax - this._scale._domainMin;
                            if (range > 0) {
                                var singleTickInterval = range / this.getActualTickCount();
                                var log10Val = Math.log10(singleTickInterval);
                                if (log10Val < 0) {
                                    numDecimals = Math.ceil(-log10Val);
                                }
                            }
                        }

                        for (var i = 0; i < count; i++) {
                            var dataValue = breakData[i];

                            var isDiscrete = this.getActualIsDiscrete();
                            var combineDups = this.getActualCombineDups();

                            if (propName == "_seriesIndex") {
                                //---- data value is series index ----
                                dataValue = this._colData[dataValue];
                            } else if ((isDiscrete) && (!combineDups)) {
                                //---- data value is record index ----
                                dataValue = this._colData[dataValue];
                            }

                            var str = formatter(dataValue, numDecimals);
                            actual[i] = str;
                        }
                    } else {
                        //---- default for unmapped column is just the 1-relative record numbers (e.g., x for column plot) ----
                        actual = vp.range(1, breakData.length, 1);
                    }
                }

                return actual;
            };

            attributeClass.prototype.colName = function (value) {
                if (arguments.length === 0) {
                    return this._colName;
                }

                if (value === undefined) {
                    this._colName = value;
                } else {
                    if (vp.isArray(value)) {
                        this._colName = value;
                    } else {
                        this._colName = [value];
                    }

                    this._value = undefined;
                }

                this._scaleNeedsSetup = true;
                return this;
            };

            attributeClass.prototype.title = function (value) {
                if (arguments.length === 0) {
                    return this._title;
                }

                this._title = value;
                return this;
            };

            attributeClass.prototype.flipInLegend = function (value) {
                if (arguments.length === 0) {
                    return this._flipInLegend;
                }

                this._flipInLegend = value;
                return this;
            };

            attributeClass.prototype.isDiscrete = function (value) {
                if (arguments.length === 0) {
                    return this._isDiscrete;
                }

                this._isDiscrete = value;
                return this;
            };

            attributeClass.prototype.palette = function (value) {
                if (arguments.length === 0) {
                    return this._palette;
                }

                this._palette = value;
                return this;
            };

            /** the array of values associated with this mapped column.  Usually calculated in
            setUpScale(). */
            attributeClass.prototype.colData = function (value) {
                if (arguments.length === 0) {
                    return this._colData;
                }

                this._colData = value;
                return this;
            };

            ///** an array of values to use instead of the filteredData, when setting up the scale. */
            //dataOverride(value?: any[])
            //{
            //    if (arguments.length === 0)
            //    {
            //        return this._dataOverride;
            //    }
            //    this._dataOverride = value;
            //    return this;
            //}
            /** the object that owns this attribute. */
            attributeClass.prototype.owner = function (value) {
                if (arguments.length === 0) {
                    return this._owner;
                }

                this._owner = value;
                return this;
            };

            /** returns the layer that owns this attribute. */
            attributeClass.prototype.pop = function () {
                return this._owner;
            };

            /** returns true if user mapped this attribute to a column. */
            attributeClass.prototype.isUserMapped = function () {
                var colName = this._colName;

                var mapped = (colName && colName.length > 0);
                return mapped;
            };

            /** returns true if user or system mapped this attribute to a column. */
            attributeClass.prototype.isMapped = function () {
                var propName = this.getAfterStatsPropName(0);

                var mapped = ((propName) && (propName.length > 0));
                return mapped;
            };

            /** get the constant or mapped value of the attribute, for the specified item. */
            attributeClass.prototype.getItemValue = function (seriesIndex, itemIndex, filteredData, daForAttr, seriesNames, stackType) {
                //---- start with no value specified ----
                var value = null;
                var isMapped = this.isMapped();

                if (isMapped) {
                    var propName = this.getAfterStatsPropName(seriesIndex);
                    var seriesCount = (seriesNames && seriesNames.length) ? seriesNames.length : 1;
                    var hasData = (filteredData && filteredData.length);

                    if (hasData) {
                        var palette = this._palette;
                        if ((!palette) || (!palette.length)) {
                            palette = daForAttr;
                        }

                        value = this.getMappedValue(propName, filteredData, seriesCount, seriesIndex, itemIndex, palette, seriesNames, daForAttr, stackType);
                    }
                } else {
                    //---- no col mapping ----
                    value = this._value;
                }

                return value;
            };

            /** get the mapped value of the attribute, for the specified item. */
            attributeClass.prototype.getMappedValue = function (propName, filteredData, seriesCount, seriesIndex, itemIndex, palette, seriesNames, daForAttr, stackType) {
                var isDiscrete = this.getActualIsDiscrete();
                var propValue = null;

                if (propName == "_itemIndex") {
                    propValue = itemIndex;
                } else if (propName == "_seriesIndex") {
                    propValue = seriesIndex;
                } else {
                    propValue = filteredData[itemIndex][propName];

                    if (isDiscrete) {
                        var combineDups = this.getActualCombineDups();

                        if (!combineDups) {
                            //---- e.g., this enables mapping "coffee" to a valid discrete color ----
                            propValue = itemIndex;
                        }
                    } else if (this._scale) {
                        //---- prevent exceptions for bad data here ----
                        if (isNaN(+propValue)) {
                            propValue = this.callOnError("NaN", { msg: "scaling input value", value: propValue, rowIndex: itemIndex, colName: propName });
                        }
                    }
                }

                var scale = this._scale;
                var value = propValue;

                if (scale) {
                    if (this._isScalingEnabled) {
                        if (this._scaleNeedsSetup) {
                            //this.setupScaleForMapping(palette, propName, filteredData, seriesCount);
                            this.setupScale(filteredData, seriesNames, daForAttr, stackType, propName);
                        }

                        var value = scale.scale(propValue);
                    } else {
                        value = propValue;
                    }
                } else {
                    var formatter = this.getActualFormatter();
                    value = formatter(propValue);
                }

                return value;
            };

            attributeClass.prototype.scale = function (value) {
                if (arguments.length == 0) {
                    return this._scale;
                }

                this._scale = value;
                return this;
            };

            attributeClass.prototype.getDataForAttribute = function (propName, filteredData, seriesNames) {
                var data = [];

                //---- get data & call scale for each row, so that scale has needed info for building the legend ----
                if (propName == "_itemIndex") {
                    var count = filteredData.length;

                    data = vp.range(0, count - 1, 1);
                } else if (propName == "_seriesIndex") {
                    data = seriesNames;
                } else {
                    data = vp.dataSelect(filteredData, propName);
                    if ((!data) || (!data.length)) {
                        //---- could not find specified propname - just return 1-based index (for discrete mapping) ----
                        data = vp.range(1, filteredData.length); //filteredData;
                    }
                }

                return data;
            };

            attributeClass.prototype.getOnErrorFromPlot = function () {
                var onErr = null;

                var layer = this._owner;
                if (layer && layer._vvParent) {
                    var plot = layer._vvParent;
                    onErr = plot._onError;
                }

                return onErr;
            };

            attributeClass.prototype.callOnError = function (errType, info) {
                var result = undefined;

                var onErr = this.getOnErrorFromPlot();
                if (onErr) {
                    result = onErr(errType, info);
                }

                return result;
            };

            /** this is called to setUp the scale for this attribute before the legend is drawn.  The
            scale is then used by the legend drawing code. */
            attributeClass.prototype.setupScale = function (filteredData, seriesNames, daForAttr, stackType, afterPropName) {
                this._afterPropName = afterPropName;
                var propName = this.getAfterStatsPropName(0);

                var seriesCount = (seriesNames && seriesNames.length) ? seriesNames.length : 1;

                var data = this.layerDefaults.dataOverride;
                if (data === undefined) {
                    data = this.getDataForAttribute(propName, filteredData, seriesNames);
                }

                this._colData = data;

                //if (this._dateFormat !== undefined)
                //{
                //    this.breaks(data);
                //}
                if (this._scale) {
                    var isDiscrete = this.getActualIsDiscrete();
                    var combineDups = this.getActualCombineDups();
                    var mapType = vp.MapType.lerp;

                    if (isDiscrete) {
                        mapType = (combineDups) ? vp.MapType.categoryKey : vp.MapType.category;
                    }

                    //---- OK, we are now ready to setup the scale ----
                    var scale = this._scale.mapType(mapType);

                    var palette = this._palette;
                    if ((!palette) || (!palette.length)) {
                        if (vp.isArray(daForAttr)) {
                            palette = daForAttr;
                        }
                    }

                    if ((palette) && (palette.length)) {
                        scale.palette(palette);
                    }

                    var recordCount = 0;

                    if (isDiscrete) {
                        //---- CATEGORY data ----
                        if (combineDups) {
                            recordCount = data.distinct().length;
                        } else {
                            recordCount = data.length;
                        }

                        scale.domainMin(1).domainMax(recordCount);
                    } else if (propName == "_seriesIndex") {
                        //---- SERIES INDEX data ----
                        recordCount = seriesCount;

                        scale.domainMin(0).domainMax(recordCount - 1);
                    } else {
                        //---- NUMERIC data ----
                        recordCount = data.length;

                        var actualDataMin = 0;
                        var actualDataMax = 0;

                        //---- compute min/max using fast method ----
                        actualDataMin = data.min();
                        actualDataMax = data.max();

                        //---- handle data errors ----
                        if (isNaN(actualDataMin)) {
                            //---- need to call on onError to correct input value issues ----
                            var onErr = this.getOnErrorFromPlot();
                            if (onErr) {
                                while (isNaN(actualDataMin)) {
                                    for (var i = 0; i < data.length; i++) {
                                        if (isNaN(data[i])) {
                                            var result = this.callOnError("NaN", { msg: "computing scale min/max", value: data[i], rowIndex: i, colName: this._colName });

                                            if (isNaN(result)) {
                                                break;
                                            }

                                            data[i] = result;
                                        }
                                    }

                                    actualDataMin = data.min();
                                    actualDataMax = data.max();
                                }
                            }
                        }

                        //---- defaults.dataMin and defaults.dataMax (set by plot, using union of all layers) take precedense here ----
                        if (this.layerDefaults.dataMin !== undefined) {
                            actualDataMin = this.layerDefaults.dataMin;
                        }

                        if (this.layerDefaults.dataMax !== undefined) {
                            actualDataMax = this.layerDefaults.dataMax;
                        }

                        var useNiceNumbers = this.getActualUseNiceNumbers();
                        var isMinMaxSoft = this.layerDefaults.isMinMaxSoft;

                        var minOverride = this._domainMin;
                        var maxOverride = this._domainMax;

                        //if (isMinMaxSoft)
                        //{
                        //    if (this.defaults.dataMin !== undefined)
                        //    {
                        //        actualDataMin = this.defaults.dataMin;
                        //    }
                        //    if (this.defaults.dataMax !== undefined)
                        //    {
                        //        actualDataMax = this.defaults.dataMax;
                        //    }
                        //}
                        //else
                        //{
                        //    if ((minOverride === undefined) && (this.defaults.dataMin !== undefined))
                        //    {
                        //        minOverride = this.defaults.dataMin;
                        //    }
                        //    if ((maxOverride === undefined) && (this.defaults.dataMax !== undefined))
                        //    {
                        //        maxOverride = this.defaults.dataMax;
                        //    }
                        //}
                        var addHeadroom = this.getActualAddHeadroom();
                        var zeroAxis = this.getActualZeroAxis();
                        var intOnlyBreaks = this.getActualIntOnlyBreaks();

                        //---- special case ----
                        var tickOverride = (this._tickCount !== undefined) ? this._tickCount : this.layerDefaults.tickCount;

                        var minSpecified = (this._domainMin !== undefined);
                        var maxSpecified = (this._domainMax !== undefined);

                        var calcMinMax = ((!minSpecified) && (!maxSpecified) && (useNiceNumbers));
                        if (!calcMinMax) {
                            if (minOverride === undefined) {
                                minOverride = actualDataMin;
                            }

                            if (maxOverride === undefined) {
                                maxOverride = actualDataMax;
                            }
                        }

                        //---- manually apply "zeroAxis" to overrides ----
                        if ((zeroAxis) && (minOverride !== undefined) && (maxOverride !== undefined)) {
                            if (minOverride > 0) {
                                minOverride = 0;
                            } else if (maxOverride < 0) {
                                maxOverride = 0;
                            }
                        }

                        //---- adjust MIN/MAX and TICKCOUNT ----
                        var result = vp.scales.niceNumbers.calculate(actualDataMin, actualDataMax, zeroAxis, intOnlyBreaks, minOverride, maxOverride, tickOverride, addHeadroom);

                        scale.domainMin(result.min).domainMax(result.max);

                        this._calculatedTickCount = result.tickCount;
                    }

                    if (scale.scaleType == "space") {
                        var percentGap = this.getActualPercentGap();

                        scale.onSetUp(recordCount, seriesCount, stackType, percentGap);

                        scale.isPaletteDiscrete(true);
                    }

                    var expandSpace = this.getActualExpandSpace();
                    scale.expandSpace(expandSpace);
                }

                this._scaleNeedsSetup = false;
                return this;
            };
            return attributeClass;
        })();
        scales.attributeClass = attributeClass;

        function createAttribute(attrName, scale) {
            return new attributeClass(attrName, scale);
        }
        scales.createAttribute = createAttribute;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// barHelper.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a step layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** helps place ticks, labels, and shapes for category type plots.  Also supports multiple-series "clustered" layouts.  */
        var barHelperClass = (function () {
            /** recordCount should be set to the number of CATEGORY values in the domain.  */
            function barHelperClass(scale, recordCount, seriesCount, percentGap) {
                this._percentGap = .25;
                this._seriesCount = 0;
                this._recordCount = 0;
                this._areaSize = 0;
                this._multiBarSize = 0;
                this._gapSize = 0;
                this._rangeMin = 0;
                this._rangeMax = 0;
                this._scale = scale;
                this._recordCount = recordCount;
                this._seriesCount = seriesCount;

                if (percentGap !== undefined) {
                    this._percentGap = percentGap;
                }

                this.caclAll();
            }
            barHelperClass.prototype.caclAll = function () {
                var count = this._recordCount;

                this._areaSize = 0;
                this._gapSize = 0;
                this._multiBarSize = 0;

                var range = this._scale.palette();
                this._rangeMin = range[0];
                this._rangeMax = range[1];

                var totalWidth = Math.abs(this._rangeMax - this._rangeMin);

                if ((count > 0) && (totalWidth > 0)) {
                    this._areaSize = Math.max(0, totalWidth / count);
                    this._gapSize = this._areaSize * (this._percentGap / 2);
                    this._multiBarSize = Math.max(0, this._areaSize - (2 * this._gapSize));
                }
            };

            barHelperClass.prototype.percentGap = function (value) {
                if (arguments.length === 0) {
                    return this._percentGap;
                }

                this._percentGap = value;
                this.caclAll();

                return this;
            };

            /** return the offset along the axis where the specified tick should be drawn. */
            barHelperClass.prototype.getTickOffset = function (tickIndex) {
                return this._rangeMin + (tickIndex * this._areaSize);
            };

            /** return the offset along the axis where the center of the specified label should be drawn. */
            barHelperClass.prototype.getBarAreaCenter = function (rowIndex) {
                return this._rangeMin + ((rowIndex + .5) * this._areaSize);
            };

            /** return the size of the each bar area (includes gaps and multi-series bars). */
            barHelperClass.prototype.getBarAreaSize = function () {
                return this._areaSize;
            };

            /** the main scaling function for discrete scales.
            return the offset for the "left" property of the specified bar.
            this will scale rowIndex=0 to the "rangeMin" and rowIndex=recordCount to the "rangeMax".  */
            barHelperClass.prototype.getBarOffset = function (rowIndex, seriesIndex, supressGapSize) {
                var areaSize = (this._rangeMin > this._rangeMax) ? (-this._areaSize) : this._areaSize;
                var barOffset = this._rangeMin + (rowIndex * areaSize);

                if (!supressGapSize) {
                    barOffset += this._gapSize;
                }

                if ((this._seriesCount > 1) && (seriesIndex !== undefined) && (seriesIndex > -1)) {
                    var perBarWidth = this._multiBarSize / this._seriesCount;
                    barOffset += seriesIndex * perBarWidth;
                }

                return barOffset;
            };

            barHelperClass.prototype.getSeriesBarOffset = function (seriesIndex) {
                var offset = 0;
                if ((seriesIndex !== undefined) && (seriesIndex > -1)) {
                    var perBarWidth = this._multiBarSize / this._seriesCount;
                    offset += seriesIndex * perBarWidth;
                }

                return offset;
            };

            /** return the size of a single bar. */
            barHelperClass.prototype.getBarSize = function () {
                return (this._multiBarSize / this._seriesCount);
            };
            return barHelperClass;
        })();
        scales.barHelperClass = barHelperClass;

        function createBarHelper(scale, recordCount, seriesCount, percentGap) {
            return new barHelperClass(scale, recordCount, seriesCount, percentGap);
        }
        scales.createBarHelper = createBarHelper;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// baseScale.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - base class for scales.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    /** type of mapping used in scales to extract values from a range palette. */
    (function (MapType) {
        /** use itemIndex as index into palette. */
        MapType[MapType["category"] = 0] = "category";

        /** use a map to track unique values and use key index as index into palette. */
        MapType[MapType["categoryKey"] = 1] = "categoryKey";

        /** use normalized input value to interplate between palette entries. */
        MapType[MapType["lerp"] = 2] = "lerp";
    })(vp.MapType || (vp.MapType = {}));
    var MapType = vp.MapType;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (scales) {
        

        var baseScaleClass = (function () {
            function baseScaleClass() {
                this.ctr = "vp.scales.baseScaleClass";
                this.scaleType = "baseScale";
                this._mapType = vp.MapType.lerp;
                this._isWrappingEnabled = false;
                this._domainMin = 0;
                this._domainMax = 1;
                this._isPaletteDiscrete = undefined;
                this._mappingCallback = undefined;
                //---- other fields ----
                this._categoryKeys = {};
                this._nextKeyIndex = 0;
                this._domainDelta = 1;
                this._userSetCategoryKeys = false;
                this.onMapTypeChanged();
            }
            baseScaleClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }

                this._expandSpace = value;
                return this;
            };

            baseScaleClass.prototype.mappingCallback = function (value) {
                if (arguments.length === 0) {
                    return this._mappingCallback;
                }

                this._mappingCallback = value;
                return this;
            };

            baseScaleClass.prototype.isPaletteDiscrete = function (value) {
                if (arguments.length === 0) {
                    return this._isPaletteDiscrete;
                }

                this._isPaletteDiscrete = value;
                return this;
            };

            baseScaleClass.prototype.isWrappingEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isWrappingEnabled;
                }

                this._isWrappingEnabled = value;
                return this;
            };

            baseScaleClass.prototype.mapType = function (value) {
                if (arguments.length == 0) {
                    return this._mapType;
                }

                this._mapType = value;
                this.onMapTypeChanged();
                return this;
            };

            baseScaleClass.prototype.palette = function (value) {
                if (arguments.length == 0) {
                    return this._palette;
                }

                this._palette = (arguments.length == 1) ? value : vp.argumentsAsArray(arguments);
                this.onPaletteChanged();
                return this;
            };

            baseScaleClass.prototype.rangeMin = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }

                if (arguments.length == 0) {
                    return this._palette[0];
                }

                this._palette[0] = value;
                this.onRangeChanged();

                return this;
            };

            baseScaleClass.prototype.rangeMax = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }

                if (arguments.length == 0) {
                    return this._palette[1];
                }

                this._palette[1] = value;
                this.onRangeChanged();

                return this;
            };

            baseScaleClass.prototype.onRangeChanged = function () {
            };

            baseScaleClass.prototype.onPaletteChanged = function () {
            };

            baseScaleClass.prototype.stops = function (value) {
                if (arguments.length == 0) {
                    return this._stops;
                }

                this._stops = (arguments.length == 1) ? value : vp.argumentsAsArray(arguments);
                return this;
            };

            baseScaleClass.prototype.domainMin = function (value) {
                if (arguments.length == 0) {
                    return this._domainMin;
                }

                this._domainMin = value;
                this.onDomainChanged();
                return this;
            };

            baseScaleClass.prototype.domainMax = function (value) {
                if (arguments.length == 0) {
                    return this._domainMax;
                }

                this._domainMax = value;
                this.onDomainChanged();
                return this;
            };

            baseScaleClass.prototype.onDomainChanged = function () {
                this._domainDelta = this._domainMax - this._domainMin;
                if (this._domainDelta == 0) {
                    this._domainDelta = 1;
                }
            };

            baseScaleClass.prototype.resetKeys = function () {
                if (!this._userSetCategoryKeys) {
                    this._categoryKeys = {}; // reset the keys seen
                    this._nextKeyIndex = 0;
                }
            };

            baseScaleClass.prototype.setCategoryKeys = function (catKeys, nextKeyIndex) {
                this._categoryKeys = catKeys;
                this._nextKeyIndex = nextKeyIndex;
                this._userSetCategoryKeys = true;
            };

            baseScaleClass.prototype.onMapTypeChanged = function () {
                if (this._mapType == vp.MapType.category) {
                    this.scale = this.categoryScale;
                } else if (this._mapType == vp.MapType.categoryKey) {
                    this.scale = this.categoryKeyScale;
                } else if (this._mapType == vp.MapType.lerp) {
                    this.scale = this.lerpScale;
                }

                this.resetKeys();
            };

            /** this gets replace by one of the 3 scale routines internally. */
            baseScaleClass.prototype.scale = function (value) {
                return 0;
            };

            baseScaleClass.prototype.categoryScale = function (recordIndex) {
                var result = undefined;
                var palette = this._palette;

                if (palette && palette.length > 0) {
                    /// TODO: use _isPaletteDiscrete to switch between interpolation / enumeration
                    /// of the palette values.
                    //---- use "index" to get a value from palette ----
                    if ((recordIndex >= palette.length) && (this._isWrappingEnabled)) {
                        recordIndex = recordIndex % palette.length;
                    } else {
                        recordIndex = this.clip(recordIndex, 0, palette.length - 1);
                    }

                    result = palette[recordIndex];
                }

                return result;
            };

            baseScaleClass.prototype.getIndexOfKey = function (value) {
                var index = this._categoryKeys[value];

                if (index === undefined) {
                    index = this._nextKeyIndex++;
                    this._categoryKeys[value] = index;
                }

                return index;
            };

            baseScaleClass.prototype.categoryKeyScale = function (value) {
                var index = this.getIndexOfKey(value);

                //---- pass all original arguments (subclass may have extra params) ----
                arguments[0] = index; // update "value" param
                var result = this.categoryScale.apply(this, arguments);

                return result;
            };

            baseScaleClass.prototype.clip = function (value, min, max) {
                //---- it turns out we DON'T WANT clipping for our plots ----
                //if (value < min)
                //{
                //    value = min;
                //}
                //else if (value > max)
                //{
                //    value = max;
                //}
                return value;
            };

            baseScaleClass.prototype.calcPercent = function (value) {
                var t = (value - this._domainMin) / this._domainDelta;

                if ((t > 1) && (this._isWrappingEnabled)) {
                    t = t - Math.floor(t); // get fractional part of value
                } else {
                    t = this.clip(t, 0, 1);
                }

                return t;
            };

            baseScaleClass.prototype.lerpPalette = function (t, palette) {
                var result = null;
                var pcount = palette.length;
                var lastIndex = pcount - 1;

                //---- allow for t outside of bounds [0..1], but don't apply clipping ----
                if (t < 0) {
                    //---- always use first 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[0], palette[1], t);
                } else if (t > 1) {
                    //---- always use last 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[pcount - 2], palette[pcount - 1], t);
                } else if (t == 0) {
                    //---- take care of easy cases first ----
                    result = palette[0];
                } else if (t == 1) {
                    //---- take care of easy cases first ----
                    result = palette[lastIndex];
                } else {
                    var stops = this._stops;
                    if ((stops) && (stops.length != pcount)) {
                        stops = null;
                    }

                    var index = -1;

                    if (!stops) {
                        //---- common case, & faster path ----
                        var dindex = lastIndex * t;
                        var index = Math.min(lastIndex - 1, Math.floor(dindex));

                        //---- re-normalize t ----
                        t = dindex - index;
                    } else {
                        //---- walk stops[] to find pair of values "t" is between ----
                        var index = -1;

                        for (var i = 0; i < pcount; i++) {
                            if (stops[i] >= t) {
                                index = i;
                                break;
                            }
                        }

                        if (index == -1) {
                            //---- never found - use last entry ----
                            result = palette[lastIndex];
                        } else if (index == 0) {
                            //---- use first entry ----
                            result = palette[0];
                        } else {
                            index--; // start with our previous entry
                            var interval = stops[index + 1] - stops[index];

                            //---- re-normalize "t" ----
                            t = (interval == 0) ? 0 : ((t - stops[index]) / interval);
                        }
                    }

                    ////---- now we can apply the ease ----
                    //if (easeFunc != null)
                    //{
                    //    t = easeFunc(t);
                    //}
                    if (t == 0) {
                        result = palette[index];
                    } else if (t == 1) {
                        result = palette[index + 1];
                    } else {
                        result = this.interpolateValues(palette[index], palette[index + 1], t);
                    }
                }

                return result;
            };

            baseScaleClass.prototype.lerpScale = function (value, rangePalette) {
                var result = undefined;
                var palette = (rangePalette) ? rangePalette : this._palette;
                if ((this._expandSpace) && (palette.length == 2)) {
                    palette = [palette[0] + this._expandSpace, palette[1] - this._expandSpace];
                }

                value = +value;

                if (this._mappingCallback) {
                    var t = this.calcPercent(value);
                    result = this._mappingCallback(value, t);
                } else {
                    if ((palette && palette.length > 0) && (!isNaN(value))) {
                        if (palette.length == 1) {
                            //---- take care of odd case first ----
                            result = palette[0];
                        } else {
                            ///
                            /// Note: "t" wiil be [0..1] and will be used to find pair of entries in palette[])
                            ///
                            var t = this.calcPercent(value);
                            result = this.lerpPalette(t, palette);
                        }
                    }
                }

                return result;
            };

            baseScaleClass.prototype.lerp = function (num, num2, t) {
                var result = num + t * (num2 - num);
                return result;
            };

            baseScaleClass.prototype.interpolateValues = function (min, max, t) {
                var result = this.lerp(min, max, t);
                return result;
            };
            return baseScaleClass;
        })();
        scales.baseScaleClass = baseScaleClass;

        var baseScale = (function (_super) {
            __extends(baseScale, _super);
            function baseScale() {
                _super.apply(this, arguments);
            }
            return baseScale;
        })(baseScaleClass);
        scales.baseScale = baseScale;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// color.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - color scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var colorClass = (function (_super) {
            __extends(colorClass, _super);
            function colorClass() {
                _super.call(this);

                this.ctr = "vp.scales.colorClass";
                this.scaleType = "color";
            }
            //---- override base method: return a color string (not rgb array) ----
            colorClass.prototype.lerpScale = function (value) {
                var result = _super.prototype.lerpScale.call(this, value);
                if (!vp.isString(result)) {
                    result = vp.colorHelper.toColor(result);
                }

                return result;
            };

            //---- override base method ----
            colorClass.prototype.interpolateValues = function (min, max, t) {
                var red = this.lerp(min[0], max[0], t);
                var green = this.lerp(min[1], max[1], t);
                var blue = this.lerp(min[2], max[2], t);

                return [red, green, blue];
            };

            //---- override base method ----
            colorClass.prototype.onMapTypeChanged = function () {
                _super.prototype.onMapTypeChanged.call(this);
                this.onPaletteChanged();
            };

            //---- override base method ----
            colorClass.prototype.onPaletteChanged = function () {
                _super.prototype.onPaletteChanged.call(this);

                //---- ensure all palette entries are rgb arrays, if interpolating ----
                if (this._mapType == vp.MapType.lerp) {
                    var palette = this._palette;
                    if (palette) {
                        for (var i = 0; i < palette.length; i++) {
                            if (vp.isString(palette[i])) {
                                palette[i] = vp.colorHelper.getColorFromString(palette[i]);
                            }
                        }
                    }
                }
            };
            return colorClass;
        })(vp.scales.baseScaleClass);
        scales.colorClass = colorClass;

        function createColor() {
            return new colorClass;
        }
        scales.createColor = createColor;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// lineType.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - lineType scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var lineTypeClass = (function (_super) {
            __extends(lineTypeClass, _super);
            function lineTypeClass() {
                _super.call(this);

                this.ctr = "vp.scales.lineTypeClass";
                this.scaleType = "lineType";

                this._palette = [0, 6];
            }
            return lineTypeClass;
        })(vp.scales.baseScaleClass);
        scales.lineTypeClass = lineTypeClass;

        function createLineType() {
            return new lineTypeClass;
        }
        scales.createLineType = createLineType;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// niceNumbers.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - used to caculate nice numbers for an axis, for histograms, etc.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var niceNumbers = (function () {
            function niceNumbers() {
            }
            niceNumbers.calculate = function (dataMin, dataMax, extendDomainToZero, useOnlyIntBreaks, callerMin, callerMax, callerTickCount, addmaxHeadroom) {
                //---- designed for "measure" data (see seperate algorithm for date values) ----
                var min = dataMin;
                var max = dataMax;
                var adjustMin = true;
                var adjustMax = true;

                if (callerMin != undefined) {
                    min = callerMin;
                    adjustMin = false;
                }

                if (callerMax != undefined) {
                    max = callerMax;
                    adjustMax = false;
                }

                if (addmaxHeadroom === undefined) {
                    addmaxHeadroom = true;
                }

                var incr = 0;

                if ((adjustMin) || (adjustMax)) {
                    var minMax = this.calcMinMax(min, max, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks);

                    min = minMax.min;
                    max = minMax.max;
                    incr = minMax.incr;
                } else {
                    var result2 = this.calcIncr(min, max, useOnlyIntBreaks);
                    incr = result2.incr;
                }

                //---- calc TICKS ----
                var ticks = 0;

                if (callerTickCount === undefined) {
                    var incrCount = (max - min) / incr;
                    ticks = 1 + Math.floor(incrCount + .00001);
                } else {
                    ticks = callerTickCount;
                }

                //---- assign final values ----
                var result = { min: min, max: max, tickCount: ticks };
                return result;
            };

            niceNumbers.calcIncr = function (min, max, useOnlyIntBreaks) {
                var incr = 1;

                var range = max - min;
                if (range > 0) {
                    var exp = Math.floor(Math.log10(range));
                    var r = range / Math.pow(10, exp);

                    if (r > 9.523) {
                        range *= 1.05;

                        max = min + range;
                        exp = Math.floor(Math.log10(range));
                        r = range / Math.pow(10, exp);
                    }

                    if (r < 2) {
                        incr = .2;
                    } else if (r < 5) {
                        incr = .5;
                    }

                    incr = incr * Math.pow(10, exp);

                    if (useOnlyIntBreaks) {
                        incr = Math.max(1, Math.round(incr));
                    }
                }

                return { incr: incr, max: max };
            };

            niceNumbers.calcMinMax = function (dataMin, dataMax, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks) {
                var min = dataMin;
                var max = dataMax;

                if (extendDomainToZero) {
                    if ((min > 0) && (adjustMin)) {
                        min = 0;
                    }

                    if ((max < 0) && (adjustMax)) {
                        max = 0;
                    }
                }

                if ((dataMin == dataMax) && (adjustMax)) {
                    incr = (useOnlyIntBreaks) ? 1 : .1 * dataMin;
                    max = dataMin + incr;
                } else {
                    var range = max - min;
                    if (range > 0) {
                        if (useOnlyIntBreaks) {
                            min = Math.floor(min);
                            max = Math.ceil(max);
                        }

                        var result = niceNumbers.calcIncr(min, max, useOnlyIntBreaks);
                        var incr = result.incr;
                        max = result.max;

                        //---- set domainMin to max INCR increment that is < minValue (or <= if 0) ----
                        //---- set domainMax to min INCR increment that is > maxValue ----
                        if (min >= 0) {
                            min = incr * Math.floor(min / incr);
                        } else {
                            min = incr * Math.floor(min * 1.001 / incr);
                        }

                        if (addmaxHeadroom) {
                            if ((max / incr) == Math.round(max / incr)) {
                                //---- if max is a multiple of "incr", add one increment ----
                                max = max + incr;
                            } else {
                                //---- round UP to the next increment ----
                                //max = incr * Math.ceil(max / incr);
                                //---- try always adding one incr ----
                                max = incr * Math.round((max + incr) / incr);
                            }
                        } else {
                            //---- try always adding part of one incr ----
                            max = incr * Math.floor((max + .9 * incr) / incr);
                        }
                    }
                }

                return { min: min, max: max, incr: incr };
            };
            return niceNumbers;
        })();
        scales.niceNumbers = niceNumbers;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// opacity.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - scale for opacity values on shapes.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var opacityClass = (function (_super) {
            __extends(opacityClass, _super);
            function opacityClass() {
                _super.call(this);

                this.ctr = "vp.scales.opacityClass";
                this.scaleType = "opacity";

                this._palette = [.4, .5, .7, .8];
            }
            return opacityClass;
        })(vp.scales.baseScaleClass);
        scales.opacityClass = opacityClass;

        function createOpacity() {
            return new opacityClass;
        }
        scales.createOpacity = createOpacity;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// shape.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - shape scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var shapeClass = (function (_super) {
            __extends(shapeClass, _super);
            function shapeClass() {
                _super.call(this);

                this.ctr = "vp.scales.shapeClass";
                this.scaleType = "shape";

                this._palette = [0, 25]; // pre-defined shapes
            }
            return shapeClass;
        })(vp.scales.baseScaleClass);
        scales.shapeClass = shapeClass;

        function createShape() {
            return new shapeClass;
        }
        scales.createShape = createShape;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// size.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - size scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var sizeClass = (function (_super) {
            __extends(sizeClass, _super);
            function sizeClass() {
                _super.call(this);

                this.ctr = "vp.scales.sizeClass";
                this.scaleType = "size";

                this._palette = [5, 10, 15, 20, 25];
            }
            return sizeClass;
        })(vp.scales.baseScaleClass);
        scales.sizeClass = sizeClass;

        function createSize() {
            return new sizeClass;
        }
        scales.createSize = createSize;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// space.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - space scale class (used to scale numbers into X and Y dimensions).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var spaceClass = (function (_super) {
            __extends(spaceClass, _super);
            function spaceClass() {
                _super.call(this);
                this._autoRange = true;
                this._barHelper = null;

                this.ctr = "vp.scales.spaceClass";
                this.scaleType = "space";

                this._palette = [0, 100];
            }
            /** return the width (size) of a full item (1-N bars, without gap space) for associated axis. */
            spaceClass.prototype.itemWidth = function () {
                var value = (this._barHelper) ? this._barHelper.getBarSize() : 0;
                return value;
            };

            spaceClass.prototype.onRangeChanged = function () {
                //---- recalculate all since range changed ----
                if (this._barHelper) {
                    this._barHelper.caclAll();
                }
            };

            /** return the width (size) of a full item for associated axis. */
            spaceClass.prototype.seriesItemWidth = function () {
                var value = (this._barHelper) ? this._barHelper.getBarSize() : 0;
                return value;
            };

            spaceClass.prototype.onSetUp = function (dataCount, seriesCount, stackType, percentGap) {
                //---- don't treat as multiple series UNLESS we are using clustered layout ----
                if (stackType != "dodge") {
                    seriesCount = 1;
                }

                this._barHelper = vp.scales.createBarHelper(this, dataCount, seriesCount, percentGap);
            };

            /** scale the value (using LERP scaling), with an optional seriesIndex adjustment */
            spaceClass.prototype.scale = function (value, seriesIndex) {
                var newValue = _super.prototype.scale.call(this, value);

                if ((seriesIndex !== undefined) && (seriesIndex > -1) && (this._barHelper)) {
                    //---- add offset for this seriesIndex ----
                    newValue += this._barHelper.getSeriesBarOffset(seriesIndex);
                    ;
                }

                return newValue;
            };

            /** Overrides baseScale's implementation.  This uses barHelper to map the recordIndex
            to an offset in the palette min/max.  This REQUIRES that the palette contain [rangeMin, rangeMax].
            */
            spaceClass.prototype.categoryScale = function (recordIndex, seriesIndex, supressGapSize) {
                var result = undefined;
                var palette = this._palette;

                if (this._barHelper) {
                    result = this._barHelper.getBarOffset(recordIndex, seriesIndex, supressGapSize);
                }

                return result;
            };

            /** flip the palette before scaling; typically used to reverse the direction of the Y axis. */
            spaceClass.prototype.flipScale = function (value, seriesIndex) {
                //---- reverse the palette and do a normal scale ----
                var origPalette = this._palette;
                this._palette = [this._palette[1], this._palette[0]];
                this._expandSpace = -this._expandSpace;

                var newValue = null;

                try  {
                    newValue = this.scale(value, seriesIndex);
                } finally {
                    //---- restore the palette ----
                    this._palette = origPalette;
                    this._expandSpace = -this._expandSpace;
                }

                return newValue;
            };

            spaceClass.prototype.scaleSize = function (value) {
                //---- try to keep values in domain range so they scale correctly ----
                var sv = this.lerpScale(value + this._domainMin);
                var sz = this.lerpScale(this._domainMin);

                return sv - sz;
            };

            spaceClass.prototype.autoRange = function (value) {
                if (arguments.length === 0) {
                    return this._autoRange;
                }

                this._autoRange = value;
                return this;
            };
            return spaceClass;
        })(vp.scales.baseScaleClass);
        scales.spaceClass = spaceClass;

        function createSpace() {
            return new spaceClass();
        }
        scales.createSpace = createSpace;

        function createCategory() {
            return new spaceClass().mapType(vp.MapType.lerp);
        }
        scales.createCategory = createCategory;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// textSize.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - textSize scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var textSizeClass = (function (_super) {
            __extends(textSizeClass, _super);
            function textSizeClass() {
                _super.call(this);

                this.ctr = "vp.scales.textSizeClass";
                this.scaleType = "textSize";

                this._palette = [5, 10, 15, 20, 25, 32, 48];
            }
            return textSizeClass;
        })(vp.scales.baseScaleClass);
        scales.textSizeClass = textSizeClass;

        function createTextSize() {
            return new textSizeClass;
        }
        scales.createTextSize = createTextSize;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// createBins.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - groups numeric data into a set of "bins".
///     - "bins" are like buckets that group items according to a data range.
///-----------------------------------------------------------------------------------------------------------------
/// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
vp.createBins = function (origData, binCount, addIndexes, niceBuckets, addAssignments)
{
    /// formats a float number where num of decimal digits corresponds to binSize.
    var formatFloat = function(value, binSize)
    {
        var numDigts = 0;

        if (binSize > 0)
        {
            var logSize = Math.log(binSize) / Math.LOG10E;
            if (logSize < 1)
            {
                numDigts = Math.max(0, Math.ceil(-logSize) - 1);
            }
        }

        var str = vp.formatters.comma(value, numDigts);
        return str;
    }

    var bins = [];
    var assignments = [];

    if (binCount > 0)
    {
        var data = vp.cleanData(origData, 0);      // convert non-numbers to 0

        var dataMax = data.max();
        var dataMin = data.min();

        if (dataMin == dataMax)
        {
            binCount = 1;           // single value - force to just 1 data bucket
        }
        else if (niceBuckets)
        {
            //var linearScale = vp.scales.createSpace();    // linear();
            //var extendDomainToZero = false;

            //linearScale.calcNiceParams(dataMin, dataMax, extendDomainToZero, undefined, undefined,
            //    binCount, false);

            var result = vp.scales.niceNumbers.calculate(dataMin, dataMax, false, undefined, undefined, undefined,
                binCount, false);

            dataMin = result.min;
            dataMax = result.max;
            binCount = result.tickCount;
        }

        var dataRange = dataMax - dataMin;
        var binRange = dataRange / binCount;

        //---- build empty bins ----
        var binNum = 1;
       
        for (var i = 0; i < binCount; i++)
        {
            var min = dataMin + (i * binRange);
            var max = Math.min(dataMax, min + binRange);

            var space = (i == binCount - 1) ? "" : " ";

            var name = "[" + formatFloat(min, binRange) + ", " + formatFloat(max, binRange) + space + "]"
            var bin = { min: min, max: max, count: 0, name: name };

            if (addIndexes)
            {
                bin.indexes = [];
            }

            bins.push(bin);

            binNum++;
        }

        //---- fill bins ----
        for (var i = 0; i < data.length; i++)
        {
            var value = data[i];
            var fltIndex = (binRange === 0) ? 0 : ((value - dataMin) / binRange);
            var binIndex = Math.max(0, Math.floor(fltIndex - vp.epsilon));

            /// this shouldn't happen but still does in some instances.
            if (binIndex >= bins.length)
            {
                binIndex = bins.length - 1;
            }

            var bin = bins[binIndex];
            bin.count = bin.count + 1;

            if (addIndexes)
            {
                bin.indexes.push(i);
            }

            if (addAssignments)
            {
                assignments[i] = binIndex;
            }
        }

        //---- add "density" field ----   
        var itemCount = data.length;

        for (var i = 0; i < bins.length; i++)
        {
            var bin = bins[i];
            bin.density = bin.count / itemCount;
        }

        var maxCount = bins.max(function (data) { return data.count });
        var maxDensity = bins.max(function (data) { return data.density });

        for (var i = 0; i < bins.length; i++)
        {
            var bin = bins[i];

            //---- add "ncount" field (count scaled to maximum of 1) ----
            bin.ncount = bin.count / maxCount;

            //---- add "ndensity" field (density scaled to maximum of 1) ----
            bin.ndensity = bin.density / maxDensity;
        }
    }

    if (addAssignments)
    {
        bins.assignments = assignments;
    }

    return bins;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// createBoxPlotData.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - groups the ycol data by the xcol and then calcuates the quartile stats for a boxplot.
///-----------------------------------------------------------------------------------------------------------------
vp.createBoxPlotData = function (data, xCol, yCol)
{
    var totalCount = data.length;

    var groups = data.groupBy(xCol);

    var boxData = groups.selectWithFunc(function (group, index)
    {
        var ydata = group.values.selectWithFunc(function (data, index) { return data[yCol]; });

        var sdata = ydata.orderBy();
        var median = 0;
        var q1 = 0;
        var q3 = 0;

        var count = sdata.length;
        var index = Math.floor(count/2);

        if (count > 1)
        {
            //---- we are using "method 2" from this Quartile definition: http://en.wikipedia.org/wiki/Quartile ----
            if (count % 2)
            {
                //---- count is ODD - use middle value ----
                median = sdata[index];

                var lowIndex = Math.floor(index / 2);
                q1 = (sdata[lowIndex] + sdata[lowIndex + 1]) / 2;

                var highIndex = index + lowIndex;
                q3 = (sdata[highIndex] + sdata[highIndex + 1]) / 2;
            }
            else
            {
                //---- count is EVEN - must average 2 middle values ----
                var before = sdata[index - 1];
                var after = sdata[index];

                median = (before + after) / 2;

                var lowIndex = Math.floor(index / 2);
                q1 = sdata[lowIndex];
                q3 = sdata[index + lowIndex + 1];
            }
        }
        else
        {
            median = sdata[0];
            q1 = median;
            q3 = median;
        }

        var iqr = q3 - q1;
        var lowFence = q1 - 1.5*iqr;
        var highFence = q3 + 1.5*iqr;
        var outliers = [];

        vp.debug("vp.createBoxPlotData: sdata.length=" + sdata.length);

        //---- build list of outliers ----
        for (var s = 0; s < sdata.length; s++)
        {
            //if (s % 300 === 0)
            //{
            //    vp.debug("vp.createBoxPlotData: in loop with s=" + s);
            //}

            var value = sdata[s];
            if (value < lowFence)
            {
                outliers.push(value);
            }
            else if (value > highFence)
            {
                outliers.push(value);
            }
        }

        var result =
        {
            name: group.values[0][xCol], lower: q1, middle: median, upper: q3, yMin: sdata[0], yMax: sdata[count - 1],
            lowFence: lowFence, highFence: highFence, outliers: outliers
        };

        vp.debug("vp.createBoxPlotData: result.lower=" + result.lower);

        return result;
    });

    return boxData;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// createCategoryBins.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - return an array of counts/density for each unique value.
///-----------------------------------------------------------------------------------------------------------------
vp.createCategoryBins = function (vector, colName, addAssignments)
{
    var totalCount = vector.length;
    //var groups = vector.groupBy();
    var assignments = [];
    var keyMap = {};
    var groups = [];

    for (var i = 0; i < vector.length; i++)
    {
        var key = vector[i];
        var bucket = keyMap[key];

        if (!bucket)
        {
            bucket = { count: 0, key: key, name: key, bucketIndex: groups.length};
            keyMap[key] = bucket;

            groups.push(bucket);
        }

        bucket.count++;

        if (addAssignments)
        {
            assignments[i] = bucket.bucketIndex;
        }
    }

    var binData = groups.selectWithFunc(function (data, index)
    {
        var count = data.count;

        var retObj = { count: count, density: count / totalCount};
        retObj[colName] = data.key;

        return retObj;
    });

    if (addAssignments)
    {
        binData.assignments = assignments;
    }

    return binData;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// excelTheme.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines the Excel theme for vuePlot chars.
///-----------------------------------------------------------------------------------------------------------------

vp.themes = vp.themes || {};        // ensure namespace is defined

vp.themes.excel = function ()
{
    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.themes.excel";

    /// public: getInteractionColors()
    closure.getInteractionColors = function ()
    {
        var ic = {};

        ic.selectedColor = "yellow";
        ic.nonSelectedColor = "black";
        ic.highlightColor = "orange";

        return ic;
    };

    /// public: getDrawingAttributes()
    closure.getDrawingAttributes = function (part)
    {
        var ab = {};

        //---- get attribute defaults ----
        ab.color = "blue",
        ab.fill = "red";
        ab.shape = 19;              // solid colored circle
        ab.shapeSize = 8;           // pixels
        ab.lineSize = 1;            // pixels
        ab.textSize = 11;           // font-size in points
        ab.hAlign = .5;             // text is centered horizontally
        ab.vAlign = .5;             // text is centered vertically

        ab.textSize = "11pt";           // font-size in points
        ab.fontFamily = "arial";

        //---- get the part-specific attributes ----
        switch (part)
        {
            //---- GRAPH ----
            case "layerGraph.edge":
                ab.color = "black";
                break;

            case "layerGraph.text":
                ab.color = "black";
                break;

            case "layerGraph.node":
                ab.color = "black"
                ab.fill = "yellow";
                break;

            case "layerGraph.arrow":
                ab.color = "black"
                break;

            //---- POINT ----
            case "layerPoint":
                ab.fill = "blue";
                break;
        }

        return ab;
    };

    //---- init code ----
    return closure;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// grayTheme.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines the default theme for vuePlot charts: gray.
///-----------------------------------------------------------------------------------------------------------------

vp.themes = vp.themes || {};        // ensure namespace is defined
vp.themeCallback = null;

vp.themes.gray = function ()
{
    //---- private state ----
    var fillPalette = vp.colorPalettes.grays(8, .8, .2);
    var strokePalette = vp.colorPalettes.grays(8, .8, .1);

    var gridLineColor = "#ccc";
    var tickColor = "#777";          // "#e0e0e0" is too light for ticks against a gray background
    var skipTickColor = "#808080";

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.themes.gray";

    closure.setCallback = function (callback)
    {
        vp.themeCallback = callback;
    };

    closure.fillPalette = function ()
    {
        return fillPalette;
    };

    //---- public: getDrawingAttributes ----
    closure.getDrawingAttributes = function (part, seriesIndex)
    {
        seriesIndex = (seriesIndex === undefined) ? 0 : seriesIndex;     // default value if undefined
        var ab = {isThemeAttr: true};

        //---- DEFAULT values ----

        //---- SHAPE ----
        ab.shapeType = 1;           // circle
        ab.shapeSize = 8;           // pixels

        ab.fill = "gray";
        ab.stroke = "gray";
        ab.fillPalette = fillPalette;
        ab.strokePalette = strokePalette;

        //---- LINE ----
        ab.lineSize = 1;            // pixels
        ab.lineType = 1;            // solid

        //----- TEXT ----
        ab.hAlign = .5;             // text is centered horizontally
        ab.vAlign = .5;             // text is centered vertically
        ab.fontFamily = "tahoma";
        ab.textSize = "11pt";           // font-size in points
        ab.textFill = "black";
        
        //---- margins around element (currently supported for only a few parts) ----
        ab.left = 0;
        ab.top = 0;
        ab.right = 0;
        ab.bottom = 0;

        //---- get the part-specific attributes (these override the defaults) ----
        switch (part)
        {
            //---- SELECTION ----
            case "selected":
                ab = {};        // zap defaults
                ab.stroke = "purple";
                ab.fill = "purple";
               // ab.lineSize = 1;
                break;

            case "unselected":
                ab = {};        // zap defaults
                break;

            case "hover":
                ab = {};        // zap defaults
                ab.stroke = "red";
                ab.fill = "cyan";
                ab.lineSize = 1;
                break;

            //---- DRAG RECT ----
            case "dragRect":
                ab.fill = "transparent";        // "gray";
                ab.stroke = "#303030";
                ab.lineSize = 2;
                ab.lineType = "dashed";
                //ab.opacity = .3;
                break;

            //---- CHART FRAME ----
            case "chartFrame.title":
                ab.fill = "#777";
                ab.textSize = "12pt";
                //ab.fontWeight = "bold";
                ab.top = 0;    
                ab.bottom = 4;
                break;

                //---- to give 1px margins all around, use: "1, 0, 0, 3" ----
                //---- above verified on rfernand8, 6/20/2013, IE10, 100% zoom. ----
            case "chartFrame.margins":
                ab.left = 11;
                ab.top = 10;
                ab.right = 10;
                ab.bottom = 13;
                break;

            case "fastDataGrid.hdrRow":
                ab.font = "bold 10pt Consolas";
                ab.background = "#f0f0f0";
                ab.fill = "#111";
                break;

            case "fastDataGrid.dataRow":
                ab.font = "10pt Consolas";
                ab.boldFont = "bold 10pt Consolas";
                ab.background = "#f0f0f0";
                ab.fill = "#555";
                break;

            case "fastDataGrid.altRow":
                ab.font = "10pt Consolas";
                ab.background = "#e0e0e0";
                ab.fill = "#555";
                break;

            case "fastDataGrid.divider":
                ab.stroke = "#cccccc";
                break;

            case "chartFrame.plotBg":
                ab.fill = "white";
                ab.lineSize = 1;
                ab.stroke = "red";  //gridLineColor;
                break;

            case "chartFrame.gridLines":
                ab.stroke = gridLineColor;
                ab.lineSize = 1;
                break;

                //---- XAXIS ----
            case "xaxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = 1;
                ab.length = 5;
                ab.spaceToLabel = 5;
                break;

            case "xaxis.skipTick":              // tick for a skipped label
                ab.stroke = skipTickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;             // hide these
                break;

            case "xaxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "xaxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                break;

            case "xaxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                ab.top = 10;
                ab.bottom = 6;
                break;

                //---- YAXIS ----
            case "yaxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                break;

            case "yaxis.skipTick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;     // hide these
                break;

            case "yaxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "yaxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                break;

            case "yaxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                ab.left = 4;
                break;

            //---- LEGEND ----
            case "legend.title":
                ab.textSize = "10pt";
                ab.fill = "#444";
                ab.bottom = -5;
                break;

            case "legend.key":
                ab.shapeWidth = 20;
                ab.shapeHeight = 20;
                ab.fill = "gray";
                ab.stroke = "white";
                ab.lineSize = 0;
                break;

            case "legend.keyText":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "legend.box":
                ab.fill = "transparent";
                ab.stroke = "darkgray";
                ab.lineSize = 0;
                ab.right = 26;              // why so much needed?
                break;

            case "legend.tick":
                ab.stroke = "gray";
                ab.lineSize = 1;
                break;

            //---- LEGEND AXIS ----
            case "legendAxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                break;

            case "legendAxis.skipTick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;     // hide these
                break;

            case "legendAxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "legendAxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "0";
                break;

            case "legendAxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            //---- GRAPH ----
            case "layerGraph.edge":
                ab.stroke = "#aaa";
                break;

            case "layerGraph.text":
                ab.fill = "#777";
                break;

            case "layerGraph.node":
                ab.stroke = "#444"
                ab.fill = "#eee";
                ab.shapeSize = undefined;   // let user define explictly when needed to override node sizing
                break;

            case "layerGraph.arrow":
                ab.stroke = "transparent"
                ab.fill = "#777";
                break;

            //---- POINT ----
            case "layerPoint":
                //---- some shapes only draw with stroke - give user full responsiblity/control -----
                //ab.stroke = "transparent";    
                break;

            //---- AREA ----
            case "layerArea":
                ab.stroke = "transparent";
                break;

            //---- PIE ----
            case "layerPieSlice":
                ab.stroke = "#ccc";
                ab.lineSize = 1;
                break;

            //---- STREAM GRAPH ----
            case "layerStreamGraph":
                ab.stroke = "transparent";
                break;

            //---- LINE ----
            case "layerLine":
                ab.lineSize = 1;
                break;

            //---- CROSSBAR ----
            case "layerCrossBar":
                ab.fill = "transparent";
                break;

            //---- CANDLESTICK ----
            case "layerCandlestick.upDayBar":
                ab.fill = "#333";
                break;

            case "layerCandlestick.downDayBar":
                ab.fill = "white";
                break;

            //---- BOX PLOT ----
            case "layerBoxPlot.lines":
                ab.stroke = "#777";
                break;

            case "layerBoxPlot.box":
                ab.fill = "white";
                ab.stroke = "#777"; 
                break;

            case "layerBoxPlot.outliers":
                ab.fill = "transparent";
                ab.stroke = "#777";
                break;

                //---- HISTOGRAM ----
            case "layerHistogram":
                ab.stroke = "#333";
                ab.lineSize = .5;
                break;

                //---- HISTOGRAM 2D ----
            case "layerHistogram2d":
                ab.stroke = "green";
                ab.lineSize = 0;
                break;

                //---- TREEEMAP ----
            case "layerTreemap":
                ab.fill = "lightgray";
                ab.stroke = "gray";
                ab.lineSize = 0;
                ab.textSize = "11pt";           // font-size in points
                ab.fontFamily = "tahoma";
                ab.textFill = "#444";
                break;
        }

        if (vp.themeCallback)
        {
            vp.themeCallback(part,  seriesIndex, ab);
        }

        return ab;
    };

    //---- init code ----
    return closure;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// themeMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - manages the themes for the plot subsystem.
///-----------------------------------------------------------------------------------------------------------------
/// themes are a simplified stying system, designed for use by the parts of a plot:
///     - axes, title, legend, plotPanel, and the various layers
///
/// themes are designed to be quick and cross-platform (easy to implement in javascript,
///     c#, c++).  when a theme is changed, it only affects any new plots built, or plots that are rebuilt.
///-----------------------------------------------------------------------------------------------------------------
vp.themeMgrClass = function ()
{
    //---- private state ----
    var theme = null;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.themeMgrClass";

    //---- property: theme ----
    closure.theme = function (value)
    {
        if (arguments.length == 0)
        {
            if (!theme)
            {
                //---- create on first demand to avoid init dependency issues ----
                theme = vp.themes.gray();   // the default
            }
            return theme;
        }

        theme = value; 
        return closure;
    };

    //---- init code ----
    return closure;
};

/// this is the global instance of the themeMgr that vuePlot client code should reference.
vp.themeMgr = vp.themeMgrClass();

vp.currentTheme = function ()
{
    return vp.themeMgr.theme();
};


///<reference path="../scripts/allfiles.ts" />
var System;
(function (System) {
    var InvalidOperationException = (function () {
        function InvalidOperationException(s) {
        }
        return InvalidOperationException;
    })();
    System.InvalidOperationException = InvalidOperationException;

    var ArgumentOutOfRangeException = (function () {
        function ArgumentOutOfRangeException(a, v, s) {
        }
        return ArgumentOutOfRangeException;
    })();
    System.ArgumentOutOfRangeException = ArgumentOutOfRangeException;

    var AssertionException = (function () {
        function AssertionException(e) {
        }
        return AssertionException;
    })();
    System.AssertionException = AssertionException;
})(System || (System = {}));

var System;
(function (System) {
    (function (Diagnostics) {
        var Debug = (function () {
            function Debug() {
            }
            Debug.Assert = function (e) {
                if (typeof (e) == "boolean") {
                    if (!e)
                        throw new System.AssertionException(e);
                } else if (typeof (e) == "string") {
                    if (e == null || e == "")
                        throw new System.AssertionException(e);
                } else {
                    if (e == null)
                        throw new System.AssertionException(e);
                }
            };

            Debug.AssertNotEmpty = function (s) {
                Debug.Assert(s);
            };
            return Debug;
        })();
        Diagnostics.Debug = Debug;
    })(System.Diagnostics || (System.Diagnostics = {}));
    var Diagnostics = System.Diagnostics;
})(System || (System = {}));
///<reference path="../scripts/allfiles.ts" />

var MAX_VALUE = 9007199254740992;

var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (Generator) {
            (function (EmptySpaceLocation) {
                EmptySpaceLocation[EmptySpaceLocation["DeterminedByLayoutAlgorithm"] = 0] = "DeterminedByLayoutAlgorithm";
                EmptySpaceLocation[EmptySpaceLocation["Top"] = 1] = "Top";
            })(Generator.EmptySpaceLocation || (Generator.EmptySpaceLocation = {}));
            var EmptySpaceLocation = Generator.EmptySpaceLocation;

            (function (LayoutAlgorithm) {
                LayoutAlgorithm[LayoutAlgorithm["BottomWeightedSquarified"] = 0] = "BottomWeightedSquarified";
                LayoutAlgorithm[LayoutAlgorithm["TopWeightedSquarified"] = 1] = "TopWeightedSquarified";
            })(Generator.LayoutAlgorithm || (Generator.LayoutAlgorithm = {}));
            var LayoutAlgorithm = Generator.LayoutAlgorithm;

            (function (NodeLevelsWithText) {
                NodeLevelsWithText[NodeLevelsWithText["All"] = 0] = "All";
                NodeLevelsWithText[NodeLevelsWithText["Leaves"] = 1] = "Leaves";
                NodeLevelsWithText[NodeLevelsWithText["None"] = 2] = "None";
                NodeLevelsWithText[NodeLevelsWithText["Range"] = 3] = "Range";
            })(Generator.NodeLevelsWithText || (Generator.NodeLevelsWithText = {}));
            var NodeLevelsWithText = Generator.NodeLevelsWithText;

            (function (ContentLocation) {
                ContentLocation[ContentLocation["CenteredText"] = 0] = "CenteredText";
                ContentLocation[ContentLocation["TopText"] = 1] = "TopText";
                ContentLocation[ContentLocation["OwnerDraw"] = 2] = "OwnerDraw";
            })(Generator.ContentLocation || (Generator.ContentLocation = {}));
            var ContentLocation = Generator.ContentLocation;

            //*****************************************************************************
            //    Class: EmptySpace
            //
            /// <summary>
            ///    Represents the empty space within a parent rectangle.
            /// </summary>
            ///
            /// <remarks>
            ///    The <see cref="Node.Nodes" /> collection owned by each <see cref="Node" />
            ///    object has an <see cref="Nodes.EmptySpace" /> property.  EmptySpace has a
            ///    <see cref="SizeMetric" /> property that determines how much empty space
            ///    appears in the the parent rectangle corresponding to the <see
            /// cref="Node" />.
            ///
            ///    <para>
            ///    The location of the empty space is determined by the <see
            /// cref="ITreemapComponent.EmptySpaceLocation" /> property.
            ///    </para>
            ///
            ///    <para>
            ///    See <see cref="Node.SizeMetric" /> for details on how the size of each
            /// node rectangle is computed and how EmptySpace is involved in the
            ///    computations.
            ///    </para>
            ///
            ///    </remarks>
            ///
            ///    <seealso cref="Node.SizeMetric" />
            ///    <seealso cref="ITreemapComponent.EmptySpaceLocation" />
            //*****************************************************************************
            var EmptySpace = (function () {
                //*************************************************************************
                //    Constructor: EmptySpace()
                //
                /// <summary>
                ///    Initializes a new instance of the EmptySpace class.
                /// </summary>
                //*************************************************************************
                function EmptySpace() {
                    this.m_fSizeMetric = 0;
                    this.m_oTreemapGenerator = null;
                }
                Object.defineProperty(EmptySpace.prototype, "SizeMetric", {
                    //*************************************************************************
                    //    Property: SizeMetric
                    //
                    /// <summary>
                    ///    Gets or sets the size of the empty space in the parent rectangle.
                    /// </summary>
                    ///
                    /// <value>
                    ///    A metric that determines the size of the empty space in the parent
                    /// rectangle.  Must be greater than or equal to zero.  The default value
                    /// is zero, which causes the child rectangles to completely fill the
                    /// parent rectangle.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_fSizeMetric);
                    },
                    set: function (value) {
                        // Validate the parameter.
                        Microsoft.Treemap.Generator.Node.ValidateSizeMetric(value, "EmptySpace.SizeMetric");

                        if (this.m_fSizeMetric != value) {
                            this.m_fSizeMetric = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(EmptySpace.prototype, "TreemapGenerator", {
                    //*************************************************************************
                    //  Property: TreemapGenerator
                    //
                    /// <summary>
                    /// Sets the object that owns this object.
                    /// </summary>
                    ///
                    /// <value>
                    /// The TreemapGenerator object that owns this object.
                    /// </value>
                    ///
                    /// <remarks>
                    /// This method must be called after this object is added to the
                    ///TreemapGenerator.
                    /// </remarks>
                    //*************************************************************************
                    set: function (value) {
                        // Don't do this.  Here is one scenario in which
                        // m_oTreemapGenerator is not null:
                        //
                        // 1. The user double-clicks a node.
                        //
                        // 2. The double-click handler zooms into the double-clicked node
                        //    by clearing all nodes from the treemap, then adding back the
                        //    double-clicked node.
                        //
                        // Debug.Assert(m_oTreemapGenerator == null);
                        this.m_oTreemapGenerator = value;

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //    Method: FireRedrawRequired()
                //
                /// <summary>
                ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                /// </summary>
                ///
                /// <remarks>
                /// This should be called when something occurs that affects the treemap's
                /// appearance.
                /// </remarks>
                //*************************************************************************
                EmptySpace.prototype.FireRedrawRequired = function () {
                    if (this.m_oTreemapGenerator != null)
                        this.m_oTreemapGenerator.FireRedrawRequired();
                };

                //*************************************************************************
                //    Method: AssertValid()
                //
                /// <summary>
                ///    Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                EmptySpace.prototype.AssertValid = function () {
                    Microsoft.Treemap.Generator.Node.ValidateSizeMetric(this.m_fSizeMetric, "EmptySpace.m_fSizeMetric");
                };
                return EmptySpace;
            })();
            Generator.EmptySpace = EmptySpace;
        })(Treemap.Generator || (Treemap.Generator = {}));
        var Generator = Treemap.Generator;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
///<reference path="../scripts/allfiles.ts" />
var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (Generator) {
            var Diag = System.Diagnostics;

            //*****************************************************************************
            //	Class: TreemapGenerator
            //
            /// <summary>
            /// Treemap drawing engine.
            /// </summary>
            ///
            /// <remarks>
            ///	TreemapGenerator is one of two components that render a hierarchical data
            /// set as a treemap, which is a set of nested rectangles.  The size of each
            ///	rectangle is determined by a property of each item in the data set, and the
            ///	rectangle's fill color is determined by another property.
            ///
            /// <para>
            ///	The following table summarizes the two treemap components.
            /// </para>
            ///
            ///	<list type="table">
            ///
            ///	<listheader>
            /// <term>Component</term>
            /// <term>For Use In</term>
            /// <term>Required Assemblies</term>
            ///	</listheader>
            ///
            ///	<item>
            ///	<term>TreemapGenerator</term>
            ///	<term>
            ///	Any application that wants to draw a treemap onto a <see cref="Bitmap" />
            /// or <see cref="Graphics" /> object, or do custom drawing
            ///	</term>
            ///	<term>
            ///	TreemapGenerator.dll
            ///	</term>
            ///	</item>
            ///
            ///	<item>
            ///	<term>TreemapControl</term>
            ///	<term>
            ///	Windows Forms applications
            ///	</term>
            ///	<term>
            ///	TreemapControl.dll, TreemapGenerator.dll
            ///	</term>
            ///	</item>
            ///
            ///	</list>
            ///
            ///	<para>
            /// TreemapGenerator is a drawing engine without its own user interface.  It
            ///	draws on a <see cref="Bitmap" /> object provided by the caller.
            ///	This allows it to be used in a variety of environments, including Web
            ///	applications that generate images on the server for downloading to client
            ///	browsers.
            ///	</para>
            ///
            ///	<para>
            ///	Using the TreemapGenerator in an application involves three steps:
            /// <list type="bullet">
            /// <item>
            /// <description>Populate the <see cref="Nodes" /> collection
            ///	</description>
            /// </item>
            /// <item>
            /// <description>
            ///	Set properties that determine how the treemap is drawn
            ///	</description>
            /// </item>
            /// <item>
            /// <description>
            ///	Draw the treemap using one of the <see cref="Draw(Bitmap, Boolean)" />
            /// methods
            ///	</description>
            /// </item>
            /// </list>
            ///	</para>
            ///
            ///	<para>
            ///	The <see cref="Nodes" /> property on TreemapGenerator
            ///	returns a collection of top-level <see cref="Node" /> objects.  Each
            ///	<see cref="Node" /> object in turn has a <see cref="Node.Nodes" /> property
            ///	that returns a collection of child <see cref="Node" /> objects.  These
            ///	nested collections are directly analogous to the Nodes collections in the
            ///	standard .NET TreeView control.
            ///	</para>
            ///
            ///	<para>
            ///	Each <see cref="Node" /> object has a <see cref="Node.SizeMetric" />
            ///	property that determines the size of the node's rectangle relative to other
            ///	nodes in the collection, <see cref="Node.ColorMetric" /> and <see
            /// cref="Node.AbsoluteColor" /> properties that determine the rectangle's fill
            /// color, and a <see cref="Node.Text" /> property that determines the text
            /// that is drawn within the rectangle.  The text's location within the
            /// rectangle is determined by the <see cref="TextLocation" /> property.
            ///	</para>
            ///
            ///	<para>
            /// Several overloaded <see cref="Draw(Bitmap, Boolean)" /> methods are
            /// provided.  You can draw onto an entire <see cref="Bitmap" />, part of a
            /// <see cref="Bitmap" />, or a <see cref="Graphics" /> object.  You can
            /// also implement your own drawing code by calling <see
            /// cref="Draw(Rectangle)" /> and handling the <see cref="DrawItem" />
            /// event.
            ///	</para>
            ///
            ///	<para>
            /// To improve performance, call <see cref="BeginUpdate" /> before populating
            /// the treemap with nodes.  This prevents the treemap from being immediately
            /// updated.  Call <see cref="EndUpdate" /> when you are done.
            ///	</para>
            ///
            /// </remarks>
            ///
            ///	<example>
            ///	Here is sample C# code that populates a TreemapGenerator
            ///	with two top-level nodes, each of which has two child nodes.  A few
            ///	properties that determine how the treemap is drawn are set, and the treemap
            ///	is drawn onto a bitmap object.
            ///
            /// <code>
            ///
            /// protected void
            /// MakeTreemapBitmap()
            /// {
            ///     // Create a TreemapGenerator object.
            ///
            ///     TreemapGenerator oTreemapGenerator = new TreemapGenerator();
            ///
            ///     // Improve performance by turning off updating while the treemap is
            ///     // being populated.
            ///
            ///     oTreemapGenerator.BeginUpdate();
            ///     PopulateTreemap(oTreemapGenerator);
            ///     oTreemapGenerator.EndUpdate();
            ///
            ///     // Set some properties on the treemap and draw it onto a bitmap.
            ///
            ///     SetTreemapProperties(oTreemapGenerator);
            ///     DrawTreemap(oTreemapGenerator);
            /// }
            ///
            /// protected void
            /// PopulateTreemap(TreemapGenerator oTreemapGenerator)
            /// {
            ///     Nodes oNodes;
            ///     Node oNode;
            ///     Nodes oChildNodes;
            ///     Node oChildNode;
            ///
            ///     // Get the collection of top-level nodes.
            ///
            ///     oNodes = oTreemapGenerator.Nodes;
            ///
            ///     // Add a top-level node to the collection.
            ///
            ///     oNode = oNodes.Add("Top Level 1", 25F, 100F);
            ///
            ///     // Add child nodes to the top-level node.
            ///
            ///     oChildNodes = oNode.Nodes;
            ///     oChildNode = oChildNodes.Add("Child 1-1", 90F, 2.5F);
            ///     oChildNode = oChildNodes.Add("Child 1-2", 10F, -34.5F);
            ///
            ///     // Add another top-level node.
            ///
            ///     oNode = oNodes.Add("Top Level 2", 50F, -40.1F);
            ///
            ///     // Add child nodes to the second top-level node.
            ///
            ///     oChildNodes = oNode.Nodes;
            ///     oChildNode = oChildNodes.Add("Child 2-1", 61F, 0F);
            ///     oChildNode = oChildNodes.Add("Child 2-2", 100F, 200F);
            ///
            ///     // (As an alternative to making multiple calls to the Nodes.Add
            ///     // method, the component can be populated via an XML string
            ///     // passed to the TreemapGenerator.NodesXml property.)
            /// }
            ///
            /// protected void
            /// SetTreemapProperties(TreemapGenerator oTreemapGenerator)
            /// {
            ///     // All TreemapGenerator properties have default values that yield
            ///     // reasonable results in many cases.  We want to change the
            ///     // range of colors for this example.
            ///
            ///     // Make Node.ColorMetric values of -200 to 200 map to a color
            ///     // range between blue and yellow.
            ///
            ///     oTreemapGenerator.MinColorMetric = -200F;
            ///     oTreemapGenerator.MaxColorMetric = 200F;
            ///
            ///     oTreemapGenerator.MinColor = Color.Blue;
            ///     oTreemapGenerator.MaxColor = Color.Yellow;
            ///
            ///     // (If desired, set other properties that determine border widths,
            ///     // spacing between rectangles, fonts, etc.)
            /// }
            ///
            /// protected void
            /// DrawTreemap(TreemapGenerator oTreemapGenerator)
            /// {
            ///     // Create a bitmap.
            ///
            ///     Bitmap oBitmap = new Bitmap(200, 200);
            ///
            ///     // Draw the treemap onto the bitmap.
            ///
            ///     oTreemapGenerator.Draw(oBitmap, false);
            ///
            ///     // (Do something with the bitmap...)
            /// }
            ///
            /// </code>
            ///
            ///	</example>
            //*****************************************************************************
            var TreemapGenerator = (function () {
                /// Minimum value allowed for the <see cref="DiscreteNegativeColors" />
                /// and <see cref="DiscretePositiveColors" /> properties.
                /// </summary>
                //*************************************************************************
                //	Constructor: TreemapGenerator()
                //
                /// <summary>
                /// Initializes a new instance of the TreemapGenerator class.
                /// </summary>
                //*************************************************************************
                function TreemapGenerator(displayRoot) {
                    this.m_displayRoot = displayRoot;
                    this.m_oNodes = new Microsoft.Treemap.Generator.Nodes(null);
                    this.m_oNodes.TreemapGenerator = this;

                    this.m_iPaddingPx = 5;
                    this.m_iPaddingDecrementPerLevelPx = 1;
                    this.m_iPenWidthPx = 3;
                    this.m_iPenWidthDecrementPerLevelPx = 1;

                    this.m_oBackColor = System.Drawing.SystemColors.Window;
                    this.m_oBorderColor = System.Drawing.SystemColors.WindowFrame;

                    this.m_sFontFamily = "Arial";
                    this.m_fFontNormSizePt = 8;
                    this.m_fFontMinSizePt = 4;
                    this.m_fFontMaxSizePt = 48;
                    this.m_fFontIncrementPt = 2;

                    this.m_oFontSolidColor = System.Drawing.SystemColors.WindowText;
                    this.m_iFontMinAlpha = 105;
                    this.m_iFontMaxAlpha = 255;
                    this.m_iFontAlphaIncrementPerLevel = 50;

                    this.m_fAnimDuration = 400; // default animation duration
                    this.m_bIsAnimationEnabled = true;

                    this.m_oSelectedFontColor = System.Drawing.SystemColors.HighlightText;
                    this.m_oSelectedBackColor = System.Drawing.SystemColors.Highlight;

                    this.m_iNodeLevelsWithText = 0 /* All */;
                    this.m_iMinNodeLevelWithText = 0;
                    this.m_iMaxNodeLevelWithText = 999;

                    this.m_eContentLocation = 1 /* TopText */;
                    this.m_ownerDraw = null;
                    this.m_eEmptySpaceLocation = 0 /* DeterminedByLayoutAlgorithm */;
                    this.m_oSelectedNode = null;

                    this.m_bInBeginUpdate = false;

                    this.m_eLayoutAlgorithm = 0 /* BottomWeightedSquarified */;
                }
                Object.defineProperty(TreemapGenerator.prototype, "Nodes", {
                    //*************************************************************************
                    //	Property: Nodes
                    //
                    /// <summary>
                    ///	Gets the collection of top-level <see cref="Node" /> objects.
                    /// </summary>
                    ///
                    /// <value>
                    ///	A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.Nodes" />
                    ///	collection of top-level <see cref="Node" /> objects.
                    /// </value>
                    ///
                    /// <remarks>
                    ///	Items in the collection can be accessed by a zero-based index.  They
                    /// can also be enumerated.
                    /// </remarks>
                    ///
                    ///	<seealso cref="Microsoft.Research.CommunityTechnologies.Treemap.Nodes"
                    ///	/>
                    ///	<seealso cref="Microsoft.Research.CommunityTechnologies.Treemap.Node" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oNodes);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TreemapGenerator.prototype, "LayoutAlgorithm", {
                    //*************************************************************************
                    //	Property: LayoutAlgorithm
                    //
                    /// <summary>
                    ///	Gets or sets the algorithm used to lay out the treemap's rectangles.
                    /// </summary>
                    ///
                    /// <value>
                    /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                    /// LayoutAlgorithm" /> enumeration that indicates how the treemap's
                    /// rectangles are laid out.  The default value is
                    /// LayoutAlgorithm.BottomWeightedSquarified.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_eLayoutAlgorithm);
                    },
                    set: function (value) {
                        if (this.m_eLayoutAlgorithm != value) {
                            this.m_eLayoutAlgorithm = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "PaddingPx", {
                    //*************************************************************************
                    //	Property: PaddingPx
                    //
                    /// <summary>
                    /// Gets or sets the padding that is added to the rectangles for top-level
                    ///	nodes.
                    /// </summary>
                    ///
                    /// <value>
                    /// The padding that is added to the rectangles for top-level nodes, in
                    ///	pixels.  The value must be between
                    ///	<see cref="TreemapGenerator.MinPaddingPx" /> and
                    /// <see cref="TreemapGenerator.MaxPaddingPx" />.  The default value is 5.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The rectangle of a top-level node is drawn using a pen of width <see
                    /// cref="PenWidthPx" /> along the node's interior.  The rectangle formed
                    /// by the interior edges of that rectangle is then shrunk by <see
                    /// cref="PaddingPx" />, and the node's children are drawn within that
                    /// shrunken rectangle.
                    ///
                    /// <para>
                    ///	If the <see cref="PaddingDecrementPerLevelPx" /> property is 0,
                    ///	PaddingPx is the padding that is added to all node rectangles.
                    ///	Otherwise, <see cref="PaddingDecrementPerLevelPx" /> is subtracted from
                    ///	the padding at each node level.  Decreasing the padding at lower levels
                    ///	can improve the general appearance of the treemap.
                    /// </para>
                    ///
                    /// </remarks>
                    ///
                    ///	<seealso cref="PaddingDecrementPerLevelPx" />
                    ///	<seealso cref="MinPaddingPx" />
                    ///	<seealso cref="MaxPaddingPx" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_iPaddingPx);
                    },
                    set: function (value) {
                        if (value < TreemapGenerator.MinPaddingPx || value > TreemapGenerator.MaxPaddingPx) {
                            throw new System.ArgumentOutOfRangeException("PaddingPx", value, "TreemapGenerator.PaddingPx: Must be between " + TreemapGenerator.MinPaddingPx + " and " + TreemapGenerator.MaxPaddingPx + ".");
                        }

                        if (this.m_iPaddingPx != value) {
                            this.m_iPaddingPx = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "PaddingDecrementPerLevelPx", {
                    //*************************************************************************
                    //	Property: PaddingDecrementPerLevelPx
                    //
                    /// <summary>
                    /// Gets or sets the number of pixels that is subtracted from the padding
                    ///	at each node level.
                    /// </summary>
                    ///
                    /// <value>
                    /// The number of pixels that is subtracted from the rectangle padding
                    ///	at each node level.  The value must be between
                    ///	<see cref="TreemapGenerator.MinPaddingDecrementPerLevelPx" /> and
                    ///	<see cref="TreemapGenerator.MaxPaddingDecrementPerLevelPx" />.  The
                    ///	default value is 1.
                    /// </value>
                    ///
                    /// <remarks>
                    ///	The rectangles for top-level nodes are drawn with a padding of
                    ///	<see cref="PaddingPx" />.  Set PaddingDecrementPerLevelPx to a positive
                    ///	value to force the padding to decrease at each level.  This can improve
                    /// the general appearance of the treemap.  A value of 0 causes all
                    /// nodes to use <see cref="PaddingPx" />.
                    ///
                    ///	<para>
                    /// If <see cref="PaddingPx" /> is 5 and PaddingDecrementPerLevelPx is 1,
                    ///	for example, the padding for the top-level, child, and grandchild nodes
                    ///	will be 5, 4, and 3 pixels, respectively.  Padding is never less than
                    ///	<see cref="MinPaddingPx" /> pixels.
                    ///	</para>
                    ///
                    /// </remarks>
                    ///
                    ///	<seealso cref="PaddingPx" />
                    ///	<seealso cref="MinPaddingDecrementPerLevelPx" />
                    ///	<seealso cref="MaxPaddingDecrementPerLevelPx" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_iPaddingDecrementPerLevelPx);
                    },
                    set: function (value) {
                        if (value < TreemapGenerator.MinPaddingDecrementPerLevelPx || value > TreemapGenerator.MaxPaddingDecrementPerLevelPx) {
                            throw new System.ArgumentOutOfRangeException("PaddingDecrementPerLevelPx", value, "TreemapGenerator.PaddingDecrementPerLevelPx: Must be" + " between " + TreemapGenerator.MinPaddingDecrementPerLevelPx + " and " + TreemapGenerator.MaxPaddingDecrementPerLevelPx + ".");
                        }

                        if (this.m_iPaddingDecrementPerLevelPx != value) {
                            this.m_iPaddingDecrementPerLevelPx = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "PenWidthPx", {
                    //*************************************************************************
                    //	Property: PenWidthPx
                    //
                    /// <summary>
                    /// Gets or sets the pen width that is used to draw the rectangles for the
                    ///	top-level nodes.
                    /// </summary>
                    ///
                    /// <value>
                    /// The pen width that is used to draw the rectangles for the top-level
                    ///	nodes, in pixels.  The value must be between
                    ///	<see cref="TreemapGenerator.MinPenWidthPx" /> and
                    ///	<see cref="TreemapGenerator.MaxPenWidthPx" />.  The default value is 3.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The rectangle of a top-level node is drawn using a pen of width <see
                    /// cref="PenWidthPx" /> along the node's interior.  The rectangle formed
                    /// by the interior edges of that rectangle is then shrunk by <see
                    /// cref="PaddingPx" />, and the node's children are drawn within that
                    /// shrunken rectangle.
                    ///
                    /// <para>
                    ///	If the <see cref="PenWidthDecrementPerLevelPx" /> property is 0, all
                    /// rectangles are drawn with a pen width of PenWidthPx pixels.  Otherwise,
                    ///	<see cref="PenWidthDecrementPerLevelPx" /> is subtracted from
                    ///	the pen width at each node level.  Decreasing the pen width at lower
                    ///	levels can improve the general appearance of the treemap.
                    /// </para>
                    ///
                    /// </remarks>
                    ///
                    ///	<seealso cref="PenWidthDecrementPerLevelPx" />
                    ///	<seealso cref="MinPenWidthPx" />
                    ///	<seealso cref="MaxPenWidthPx" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_iPenWidthPx);
                    },
                    set: function (value) {
                        if (value < TreemapGenerator.MinPenWidthPx || value > TreemapGenerator.MaxPenWidthPx) {
                            throw new System.ArgumentOutOfRangeException("PenWidthPx", value, "TreemapGenerator.PenWidthPx: Must be between " + TreemapGenerator.MinPenWidthPx + " and " + TreemapGenerator.MaxPenWidthPx + ".");
                        }

                        if (this.m_iPenWidthPx != value) {
                            this.m_iPenWidthPx = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "PenWidthDecrementPerLevelPx", {
                    //*************************************************************************
                    //	Property: PenWidthDecrementPerLevelPx
                    //
                    /// <summary>
                    /// Gets or sets the number of pixels that is subtracted from the pen
                    ///	width at each node level.
                    /// </summary>
                    ///
                    /// <value>
                    /// The number of pixels that is subtracted from the pen width at each
                    ///	node level.  The value must be between
                    ///	<see cref="TreemapGenerator.MinPenWidthDecrementPerLevelPx" />
                    ///	and <see cref="TreemapGenerator.MaxPenWidthDecrementPerLevelPx" />.
                    ///	The default value is 1.
                    /// </value>
                    ///
                    /// <remarks>
                    ///
                    ///	The rectangles for top-level nodes are drawn with a pen width of
                    ///	<see cref="PenWidthPx" /> pixels.  Set PenWidthDecrementPerLevelPx to
                    ///	a positive value to force the pen width to decrease at each level.
                    /// This can improve the general appearance of the treemap.  A value of 0
                    ///	causes all nodes to use <see cref="PenWidthPx" />.
                    ///
                    ///	<para>
                    /// If <see cref="PenWidthPx" /> is 4 and PenWidthDecrementPerLevelPx is
                    ///	1, for example, the pen width for the top-level nodes will be 4, the
                    ///	width for the child nodes will be 3, the width for the grandchildren
                    ///	will be 2, and so on.  The pen width is never less than <see
                    /// cref="MinPenWidthPx" />.
                    ///	</para>
                    ///
                    /// </remarks>
                    ///
                    ///	<seealso cref="PenWidthPx" />
                    ///	<seealso cref="MinPenWidthDecrementPerLevelPx" />
                    ///	<seealso cref="MaxPenWidthDecrementPerLevelPx" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_iPenWidthDecrementPerLevelPx);
                    },
                    set: function (value) {
                        if (value < TreemapGenerator.MinPaddingDecrementPerLevelPx || value > TreemapGenerator.MaxPaddingDecrementPerLevelPx) {
                            throw new System.ArgumentOutOfRangeException("PenWidthDecrementPerLevelPx", value, "TreemapGenerator.PenWidthDecrementPerLevelPx: Must be" + " between " + TreemapGenerator.MinPaddingDecrementPerLevelPx + " and " + TreemapGenerator.MaxPaddingDecrementPerLevelPx + ".");
                        }

                        if (this.m_iPenWidthDecrementPerLevelPx != value) {
                            this.m_iPenWidthDecrementPerLevelPx = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "BackColor", {
                    //*************************************************************************
                    //	Property: BackColor
                    //
                    /// <summary>
                    /// Gets or sets the treemap's background color.
                    /// </summary>
                    ///
                    /// <value>
                    /// The treemap's background color, as a <see cref="Color" />.  The default
                    /// value is <see cref="SystemColors.Window" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The background color is used to paint the padding between the treemap
                    /// rectangle and the top-level nodes, as well as any empty space in the
                    /// top-level <see cref="Nodes" /> collection.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oBackColor);
                    },
                    set: function (value) {
                        if (this.m_oBackColor != value) {
                            this.m_oBackColor = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "BorderColor", {
                    //*************************************************************************
                    //	Property: BorderColor
                    //
                    /// <summary>
                    /// Gets or sets the color of rectangle borders.
                    /// </summary>
                    ///
                    /// <value>
                    ///	The color of the rectangle borders, as a <see cref="Color" />.  The
                    /// default value is <see cref="SystemColors.WindowFrame" />.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oBorderColor);
                    },
                    set: function (value) {
                        if (this.m_oBorderColor != value) {
                            this.m_oBorderColor = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "FontFamily", {
                    //*************************************************************************
                    //	Property: FontFamily
                    //
                    /// <summary>
                    ///	Gets or sets the font family to use for node text.
                    /// </summary>
                    ///
                    /// <value>
                    ///	The name of the font family to use for node text.  The default value is
                    /// Arial.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_sFontFamily);
                    },
                    set: function (value) {
                        // Make sure the font exists.
                        var oFont = new System.Drawing.Font(value, 8);
                        var sActualFamilyName = oFont.FontFamily.Name;

                        if (sActualFamilyName.toLowerCase() != value.toLowerCase()) {
                            throw new System.ArgumentOutOfRangeException("FontFamily", value, "TreemapGenerator.FontFamily: No such font.");
                        }

                        if (this.m_sFontFamily != value) {
                            this.m_sFontFamily = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "FontSolidColor", {
                    //*************************************************************************
                    //	Property: FontSolidColor
                    //
                    /// <summary>
                    ///	Gets or sets the color to use for unselected node text.
                    /// </summary>
                    ///
                    /// <value>
                    ///	The color to use for the text of unselected nodes, as a <see
                    /// cref="Color" />.  The default value is <see
                    /// cref="SystemColors.WindowText" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// This must be a solid color, which means its alpha component must be
                    ///	255.  Text can be drawn using transparent colors; see
                    ///	<see cref="SetFontAlphaRange" /> for details.
                    ///
                    /// <para>
                    /// The control's color usage varies with the value of the <see
                    /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                    /// details.
                    /// </para>
                    ///
                    ///	</remarks>
                    ///
                    ///	<seealso cref="SetFontAlphaRange" />
                    ///	<seealso cref="SelectedFontColor" />
                    ///	<seealso cref="SelectedBackColor" />
                    ///	<seealso cref="TextLocation" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oFontSolidColor);
                    },
                    set: function (value) {
                        if (value.A != 255) {
                            throw new System.ArgumentOutOfRangeException("FontSolidColor", value, "TreemapGenerator.FontSolidColor: Must not be" + " transparent.");
                        }

                        if (this.m_oFontSolidColor != value) {
                            this.m_oFontSolidColor = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "FontNormSizePt", {
                    //*************************************************************************
                    //	Property: FontSolidColor
                    //
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return this.m_fFontNormSizePt;
                    },
                    set: function (value) {
                        if (this.m_fFontNormSizePt != value) {
                            this.m_fFontNormSizePt = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "AnimationDuration", {
                    //*************************************************************************
                    //	Property: AnimationDuration
                    //
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_bIsAnimationEnabled) ? this.m_fAnimDuration : 0;
                    },
                    set: function (value) {
                        this.m_fAnimDuration = value;
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "IsAnimationEnabled", {
                    //*************************************************************************
                    //	Property: IsAnimationEnabled
                    //
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return this.m_bIsAnimationEnabled;
                    },
                    set: function (value) {
                        this.m_bIsAnimationEnabled = value;
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "SelectedFontColor", {
                    //*************************************************************************
                    //	Property: SelectedFontColor
                    //
                    /// <summary>
                    ///	Gets or sets the color to use for selected node text.
                    /// </summary>
                    ///
                    /// <value>
                    ///	The color to use for the text of the selected node, as a <see
                    /// cref="Color" />.  The default value is <see
                    /// cref="SystemColors.HighlightText" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The control's color usage varies with the value of the <see
                    /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                    /// details.
                    /// </remarks>
                    ///
                    ///	<seealso cref="FontSolidColor" />
                    ///	<seealso cref="SelectedBackColor" />
                    ///	<seealso cref="TextLocation" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oSelectedFontColor);
                    },
                    set: function (value) {
                        if (this.m_oSelectedFontColor != value) {
                            this.m_oSelectedFontColor = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "SelectedBackColor", {
                    //*************************************************************************
                    //	Property: SelectedBackColor
                    //
                    /// <summary>
                    ///	Gets or sets the color to use to highlight the selected node.
                    /// </summary>
                    ///
                    /// <value>
                    /// The color to use to highlight the selected node, as a <see
                    /// cref="Color" />.  The default value is <see
                    /// cref="SystemColors.Highlight" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The control's color usage varies with the value of the <see
                    /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                    /// details.
                    /// </remarks>
                    ///
                    ///	<seealso cref="FontSolidColor" />
                    ///	<seealso cref="SelectedFontColor" />
                    ///	<seealso cref="TextLocation" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oSelectedBackColor);
                    },
                    set: function (value) {
                        if (this.m_oSelectedBackColor != value) {
                            this.m_oSelectedBackColor = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "NodeLevelsWithText", {
                    //*************************************************************************
                    //	Property: NodeLevelsWithText
                    //
                    /// <summary>
                    ///	Gets or sets the node levels to show text for.
                    /// </summary>
                    ///
                    /// <value>
                    /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                    /// NodeLevelsWithText" /> enumeration that indicates which node levels
                    /// should include text.  The default value is All.
                    /// </value>
                    ///
                    ///	<seealso cref="TreemapGenerator.SetNodeLevelsWithTextRange" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_iNodeLevelsWithText);
                    },
                    set: function (value) {
                        if (this.m_iNodeLevelsWithText != value) {
                            this.m_iNodeLevelsWithText = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "ContentLocation", {
                    //*************************************************************************
                    //	Property: ContentLocation
                    //
                    /// <summary>
                    ///	Gets or sets the location within a node's rectangle where the node's
                    /// text is shown.
                    /// </summary>
                    ///
                    /// <value>
                    /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                    /// ContentLocation" /> enumeration that indicates the location of a node's
                    /// text within the node's rectangle.  The default value is <see
                    /// cref="Microsoft.Research.CommunityTechnologies.Treemap.ContentLocation.
                    /// Top" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// The effects of this property are detailed in the following table.
                    ///
                    ///	<list type="table">
                    ///
                    ///	<listheader>
                    /// <term></term>
                    /// <term>Top</term>
                    /// <term>CenterCenter</term>
                    ///	</listheader>
                    ///
                    ///	<item>
                    ///	<term>Text Location</term>
                    ///	<term>
                    /// The text is displayed at the top of the node's rectangle.  For non-leaf
                    /// nodes, the text is centered and limited to a single line.  For leaf
                    /// nodes, the text is left-justified and can wrap to fill the entire
                    /// rectangle.
                    ///	</term>
                    ///	<term>
                    /// The text is centered both vertically and horizontally within the node's
                    /// rectangle and is limited to a single line.
                    ///	</term>
                    ///	</item>
                    ///
                    ///	<item>
                    ///	<term>Text Size</term>
                    ///	<term>
                    /// All node text is drawn using the font size specified by the minSizePt
                    /// parameter passed to the <see cref="SetFontSizeRange" /> method.  The
                    /// maxSizePt and incrementPt parameters are ignored in this case.
                    ///	</term>
                    ///	<term>
                    /// The size of the font used to draw node text varies from node to node.
                    /// The range of font sizes is specified by the minSizePt, maxSizePt, and
                    /// incrementPt parameters passed to the <see cref="SetFontSizeRange" />
                    /// method.
                    ///	</term>
                    ///	</item>
                    ///
                    ///	<item>
                    ///	<term>Text Transparency</term>
                    ///	<term>
                    /// All node text is opaque and the parameters passed to <see
                    /// cref="SetFontAlphaRange" /> are ignored.
                    ///	</term>
                    ///	<term>
                    /// The transparency of node text can be varied using <see
                    /// cref="SetFontAlphaRange" />.
                    ///	</term>
                    ///	</item>
                    ///
                    ///	<item>
                    ///	<term>Colors</term>
                    ///	<term>
                    /// For non-selected nodes, node text is drawn using <see
                    /// cref="FontSolidColor" /> and is always opaque.  The text's background
                    /// is the color of the node itself.
                    ///
                    /// <para>
                    /// For the selected node, the text is drawn using <see
                    /// cref="SelectedFontColor" /> and is always opaque.  <see
                    /// cref="SelectedBackColor" /> is used for both the text's background and
                    /// for a highlight rectangle drawn around the node's rectangle.
                    /// </para>
                    ///	</term>
                    ///	<term>
                    /// For non-selected nodes, node text is drawn using <see
                    /// cref="FontSolidColor" />, and the transparency of the text can be
                    /// varied using <see cref="SetFontAlphaRange" />.
                    ///
                    /// <para>
                    /// For the selected node, the text is drawn using <see
                    /// cref="SelectedFontColor" /> and is always opaque.  <see
                    /// cref="SelectedBackColor" /> is used for a highlight rectangle drawn
                    /// around the node's rectangle.
                    /// </para>
                    ///
                    /// <para>
                    /// The text's background is always the color of the node itself,
                    /// regardless of whether the node is selected.
                    /// </para>
                    ///	</term>
                    ///	</item>
                    ///
                    ///	</list>
                    ///
                    /// </remarks>
                    ///
                    ///	<seealso cref="SetFontSizeRange" />
                    ///	<seealso cref="SetFontAlphaRange" />
                    ///	<seealso cref="FontSolidColor" />
                    ///	<seealso cref="SelectedFontColor" />
                    ///	<seealso cref="SelectedBackColor" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_eContentLocation);
                    },
                    set: function (value) {
                        if (this.m_eContentLocation != value) {
                            this.m_eContentLocation = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "ContentDrawer", {
                    // get owner draw callback; null if none.
                    get: function () {
                        this.AssertValid();

                        return this.m_ownerDraw;
                    },
                    // set owner draw callback; changes content location to owner draw;
                    // immediately calls SetDrawingContent with the current font and colors
                    set: function (value) {
                        if (this.m_ownerDraw != value) {
                            this.BeginUpdate();
                            this.m_ownerDraw = value;
                            if (value == null)
                                this.m_eContentLocation = 1 /* TopText */;
                            else
                                this.m_eContentLocation = 2 /* OwnerDraw */;

                            // TODO: call this again if any of them change
                            this.m_ownerDraw.SetDrawingContext(this.m_sFontFamily, this.m_fFontNormSizePt, this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor);

                            this.EndUpdate();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "EmptySpaceLocation", {
                    //*************************************************************************
                    //	Property: EmptySpaceLocation
                    //
                    /// <summary>
                    ///	Gets or sets the location within a node's rectangle where the node's
                    /// empty space is shown.
                    /// </summary>
                    ///
                    /// <value>
                    /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                    /// EmptySpaceLocation" /> enumeration that indicates the location of a
                    /// node's empty space within the node's rectangle.  The default value is
                    /// <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                    /// EmptySpaceLocation.DeterminedByLayoutAlgorithm" />.
                    /// </value>
                    ///
                    /// <remarks>
                    /// You can force empty space to appear in a node's rectangle by setting
                    /// the Node.Nodes.EmptySpace.<see
                    /// cref="Microsoft.Research.CommunityTechnologies.Treemap.EmptySpace.
                    /// SizeMetric" /> property to a positive value.  The location of the empty
                    /// space is determined by the <see cref="EmptySpaceLocation" /> property.
                    ///
                    /// <para>
                    ///	See <see cref="Node.SizeMetric" /> for details on how the size of each
                    /// node rectangle is computed and how EmptySpace is involved in the
                    ///	computations.
                    /// </para>
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_eEmptySpaceLocation);
                    },
                    set: function (value) {
                        if (this.m_eEmptySpaceLocation != value) {
                            this.m_eEmptySpaceLocation = value;
                            this.FireRedrawRequired();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(TreemapGenerator.prototype, "SelectedNode", {
                    //*************************************************************************
                    //	Property: SelectedNode
                    //
                    /// <summary>
                    ///	Gets the selected <see cref="Node" />, if there is one.
                    /// </summary>
                    ///
                    /// <value>
                    /// The selected <see cref="Node" />, or null if there is none.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oSelectedNode);
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //	Method: GetNodeLevelsWithTextRange()
                //
                /// <summary>
                ///	Gets the range of node levels for which text is shown.
                /// </summary>
                ///
                /// <param name="minLevel">
                /// Minimum node level.  Level 0 is the top level.
                /// </param>
                ///
                /// <param name="maxLevel">
                /// Maximum node level.  Level 0 is the top level.
                /// </param>
                ///
                /// <remarks>
                /// The range returned by this method is used only if <see
                /// cref="NodeLevelsWithText" /> is set to Range.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.GetNodeLevelsWithTextRange = function (minLevel, maxLevel) {
                    // TODO: need to return both values
                };

                //*************************************************************************
                //	Method: SetNodeLevelsWithTextRange()
                //
                /// <summary>
                ///	Sets the range of node levels for which text is shown.
                /// </summary>
                ///
                /// <param name="minLevel">
                /// Minimum node level.  Level 0 is the top level.  Must be greater than or
                /// equal to 0.
                /// </param>
                ///
                /// <param name="maxLevel">
                /// Maximum node level.  Level 0 is the top level.  Must be greater than or
                /// equal to zero and greater than or equal to <paramref name="minLevel" />.
                /// </param>
                ///
                /// <remarks>
                /// The range specified in this method is used only if <see
                /// cref="NodeLevelsWithText" /> is set to Range.  The default minimum and
                /// maximum values are 0 and 999.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.SetNodeLevelsWithTextRange = function (minLevel, maxLevel) {
                    // Validate the arguments.
                    if (minLevel < 0) {
                        throw new System.ArgumentOutOfRangeException("minLevel", minLevel, "TreemapGenerator.SetNodeLevelsWithTextRange: Must be >= 0.");
                    }

                    if (maxLevel < 0) {
                        throw new System.ArgumentOutOfRangeException("maxLevel", maxLevel, "TreemapGenerator.SetNodeLevelsWithTextRange: Must be >= 0.");
                    }

                    if (maxLevel < minLevel) {
                        throw new System.ArgumentOutOfRangeException("maxLevel", maxLevel, "TreemapGenerator.SetNodeLevelsWithTextRange:" + " Must be >= minLevel.");
                    }

                    this.m_iMinNodeLevelWithText = minLevel;
                    this.m_iMaxNodeLevelWithText = maxLevel;

                    this.FireRedrawRequired();

                    this.AssertValid();
                };

                //*************************************************************************
                //	Method: GetFontSizeRange()
                //
                /// <summary>
                ///	Gets the range of font sizes used for node text.
                /// </summary>
                ///
                /// <param name="minSizePt">
                /// Minimum font size, in points.
                /// </param>
                ///
                /// <param name="maxSizePt">
                /// Maximum font size, in points.
                /// </param>
                ///
                /// <param name="incrementPt">
                /// Increment between font sizes, in points.
                /// </param>
                ///
                /// <remarks>
                ///	See <see cref="SetFontSizeRange" /> for details on how font sizes are
                /// specified for node text.
                /// </remarks>
                ///
                ///	<seealso cref="SetFontSizeRange" />
                //*************************************************************************
                TreemapGenerator.prototype.GetFontSizeRange = function (minSizePt, maxSizePt, incrementPt) {
                    // TODO: need to return all three values
                };

                //*************************************************************************
                //	Method: SetFontSizeRange()
                //
                /// <summary>
                ///	Sets the range of font sizes used for node text.
                /// </summary>
                ///
                /// <param name="minSizePt">
                /// Minimum font size, in points.
                /// </param>
                ///
                /// <param name="maxSizePt">
                /// Maximum font size, in points.
                /// </param>
                ///
                /// <param name="incrementPt">
                /// Increment between font sizes, in points.
                /// </param>
                ///
                /// <remarks>
                /// When <see cref="TextLocation" /> is set to <see
                /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                /// Top" />, all node text is drawn using the font size specified by
                /// the <paramref name="minSizePt" /> parameter.  The <paramref
                /// name="maxSizePt" /> and <paramref name="incrementPt" /> parameters are
                /// ignored in this case.
                ///
                /// <para>
                /// When <see cref="TextLocation" /> is set to <see
                /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                /// CenterCenter" />, the size of the font used to draw node text varies
                /// from node to node.  For each node, the largest font in the range
                /// specified by <paramref name="minSizePt" />, <paramref
                /// name="maxSizePt" />, and <paramref name="incrementPt" /> that won't
                /// exceed the bounds of the node's rectangle is used.
                /// </para>
                ///
                ///	<para>
                ///	By default, the <see cref="TreemapGenerator" /> uses
                ///	<paramref name="minSizePt" />=8, <paramref name="maxSizePt" />=100,
                ///	and <paramref name="incrementPt" />=2.
                ///	</para>
                ///
                /// </remarks>
                ///
                ///	<example>
                /// If <see cref="TextLocation" /> is set to <see
                /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                /// Top" />, <paramref name="minSizePt" /> is 8.0, <paramref
                /// name="maxSizePt" /> is 10.0, and <paramref name="incrementPt" /> is
                /// 2.0, all node text is drawn using a font size of 8.0.  (<paramref
                /// name="maxSizePt" /> and <paramref name="incrementPt" /> are ignored in
                /// this case.)
                ///
                /// <para>
                /// If <see cref="TextLocation" /> is set to <see
                /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                /// CenterCenter" />, <paramref name="minSizePt" /> is 2.0, <paramref
                /// name="maxSizePt" /> is 10.0, and <paramref name="incrementPt" /> is
                /// 2.0, node text is drawn using one of the following font sizes: 2.0,
                /// 4.0, 6.0, 8.0, 10.0.
                /// </para>
                ///
                ///	</example>
                //*************************************************************************
                TreemapGenerator.prototype.SetFontSizeRange = function (minSizePt, normSizePt, maxSizePt, incrementPt) {
                    // Validate the arguments.
                    Microsoft.Treemap.Util.MaximizingFontMapper.ValidateSizeRange(minSizePt, maxSizePt, incrementPt, "TreemapGenerator.SetFontSizeRange()");

                    this.m_fFontNormSizePt = normSizePt;
                    this.m_fFontMinSizePt = minSizePt;
                    this.m_fFontMaxSizePt = maxSizePt;
                    this.m_fFontIncrementPt = incrementPt;

                    this.FireRedrawRequired();

                    this.AssertValid();
                };

                //*************************************************************************
                //	Method: GetFontAlphaRange()
                //
                /// <summary>
                ///	Gets the range of transparency used for node text.
                /// </summary>
                ///
                /// <param name="minAlpha">
                /// Alpha value used for the level with maximum transparency.
                /// </param>
                ///
                /// <param name="maxAlpha">
                /// Alpha value used for the level with minimum transparency.
                /// </param>
                ///
                /// <param name="incrementPerLevel">
                /// Amount that alpha is incremented from level to level.
                /// </param>
                ///
                /// <remarks>
                ///	See <see cref="SetFontAlphaRange" /> for details on how transparency is
                /// specified for node text.
                ///	</remarks>
                ///
                ///	<seealso cref="SetFontAlphaRange" />
                //*************************************************************************
                TreemapGenerator.prototype.GetFontAlphaRange = function (minAlpha, maxAlpha, incrementPerLevel) {
                    // TODO: need to return all three values
                };

                //*************************************************************************
                //	Method: SetFontAlphaRange()
                //
                /// <summary>
                ///	Sets the range of transparency used for node text.
                /// </summary>
                ///
                /// <param name="minAlpha">
                /// Alpha value to use for the level with maximum transparency.  Must be
                ///	between 0 and 255.
                /// </param>
                ///
                /// <param name="maxAlpha">
                /// Alpha value to use for the level with minimum transparency.  Must be
                ///	between 0 and 255 and >= <paramref name="minAlpha" />.
                /// </param>
                ///
                /// <param name="incrementPerLevel">
                /// Amount that alpha should be incremented from level to level.  Must
                ///	be > 0.
                /// </param>
                ///
                /// <remarks>
                ///	When <see cref="TextLocation" /> is set to <see cref="Microsoft.
                /// Research.CommunityTechnologies.Treemap.TextLocation.Top" />, all
                /// node text is drawn opaque and the values passed to this method are
                /// ignored.
                ///
                /// <para>
                ///	To improve text legibility when <see cref="TextLocation" /> is set to
                /// <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                /// TextLocation.CenterCenter" />, the <see cref="TreemapGenerator" />
                /// varies the transparency of node text.  The text for higher-level nodes
                /// is more transparent than the text for lower-level nodes, so the
                /// lower-level text shows through the higher-level text.
                /// </para>
                ///
                ///	<para>
                ///	Alpha values range from 0 (transparent) to 255 (opaque).
                ///	</para>
                ///
                ///	<para>
                ///	By default, the <see cref="TreemapGenerator" /> uses
                ///	<paramref name="minAlpha" />=105, <paramref name="maxAlpha" />=255,
                ///	and <paramref name="incrementPerLevel" />=50.
                ///	</para>
                ///
                /// </remarks>
                ///
                ///	<example>
                ///	If <see cref="TextLocation" /> is set to <see cref="Microsoft.Research.
                /// CommunityTechnologies.Treemap.TextLocation.CenterCenter" />, <paramref
                /// name="minAlpha" /> is 55, <paramref name="maxAlpha" /> is 255, and
                /// <paramref name="incrementPerLevel" /> is 100, then the text for level-0
                /// (top-level) nodes will be drawn with alpha=55, the text for level-1
                /// nodes will be drawn with alpha=155, and the text for level-2 nodes and
                /// below will be drawn with alpha=255.
                ///	</example>
                ///
                ///	<seealso cref="GetFontAlphaRange" />
                //*************************************************************************
                TreemapGenerator.prototype.SetFontAlphaRange = function (minAlpha, maxAlpha, incrementPerLevel) {
                    // Validate the arguments.
                    Microsoft.Treemap.GraphicsLib.TransparentBrushMapper.ValidateAlphaRange(minAlpha, maxAlpha, incrementPerLevel, "TreemapGenerator.SetFontAlphaRange");

                    this.m_iFontMinAlpha = minAlpha;
                    this.m_iFontMaxAlpha = maxAlpha;
                    this.m_iFontAlphaIncrementPerLevel = incrementPerLevel;

                    this.FireRedrawRequired();

                    this.AssertValid();
                };

                //*************************************************************************
                //	Method: BeginUpdate()
                //
                /// <summary>
                /// Disables any redrawing of the treemap.
                /// </summary>
                ///
                /// <remarks>
                /// To improve performance, call BeginUpdate before adding <see
                /// cref="Node" /> objects to the treemap.  Call <see cref="EndUpdate" />
                /// when you are done.
                /// </remarks>
                ///
                ///	<seealso cref="EndUpdate" />
                //*************************************************************************
                TreemapGenerator.prototype.BeginUpdate = function () {
                    this.AssertValid();

                    this.m_bInBeginUpdate = true;
                };

                //*************************************************************************
                //	Method: EndUpdate()
                //
                /// <summary>
                /// Enables the redrawing of the treemap.
                /// </summary>
                ///
                /// <remarks>
                /// To improve performance, call <see cref="BeginUpdate" /> before
                /// adding <see cref="Node" /> objects to the treemap.  Call EndUpdate when
                /// you are done.
                /// </remarks>
                ///
                ///	<seealso cref="BeginUpdate" />
                //*************************************************************************
                TreemapGenerator.prototype.EndUpdate = function () {
                    this.AssertValid();

                    this.m_bInBeginUpdate = false;

                    // Assume the caller made changes between the BeginUpdate() and
                    // EndUpdate() calls that require a redraw.
                    this.FireRedrawRequired();
                };

                //*************************************************************************
                //	Method: Clear()
                //
                /// <summary>
                ///	Removes all nodes from the treemap.
                /// </summary>
                //*************************************************************************
                TreemapGenerator.prototype.Clear = function () {
                    // Cancel any selection.
                    this.CancelSelectedNode();

                    // Remove all top-level nodes.
                    this.m_oNodes.Clear();

                    // TODO: remove notes from display
                    // The treemap needs to be redrawn.
                    this.FireRedrawRequired();

                    this.AssertValid();
                };

                //*************************************************************************
                //	Method: Draw()
                //
                /// <summary>
                /// Draws the treemap onto a <see cref="Graphics" /> object.
                /// </summary>
                ///
                /// <remarks>
                ///	The selection is not drawn.
                ///
                /// <para>
                /// This method can be used to print the treemap.  To draw the treemap onto
                /// a <see cref="Bitmap" /> instead, use <see
                /// cref="Draw(Bitmap, Boolean)" />.
                /// </para>
                ///
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.Draw = function () {
                    var treemapRectangle = new System.Drawing.Rectangle(0, 0, this.m_displayRoot.width(), this.m_displayRoot.height());

                    Diag.Debug.Assert(!treemapRectangle.IsEmpty);
                    this.AssertValid();

                    // Compute and draw all the nodes' rectangles.
                    this.CalculateAndDrawRectangles(treemapRectangle, this.m_oNodes, null);

                    if (this.m_iNodeLevelsWithText != 2 /* None */) {
                        // Draw all the text.
                        // Create the object that knows how to draw node text, then tell it to
                        // draw the text for all the nodes in the treemap.
                        var oTextDrawer = this.CreateTextDrawer();

                        oTextDrawer.DrawTextForAllNodes(this.m_displayRoot, this.m_iPaddingPx, this.m_iPaddingDecrementPerLevelPx, this.m_oNodes);
                    }
                };

                //*************************************************************************
                //	Method: GetNodeFromPoint()
                //
                /// <overloads>
                /// Gets the <see cref="Node" /> object containing a specified point.
                /// </overloads>
                ///
                /// <summary>
                /// Gets the <see cref="Node" /> object containing a specified PointF.
                /// </summary>
                ///
                /// <param name="pointF">
                /// Point to get a <see cref="Node" /> object for.
                /// </param>
                ///
                /// <param name="node">
                /// Where the <see cref="Node" /> object gets stored.
                /// </param>
                ///
                /// <returns>
                ///	true if a <see cref="Node" /> object was found, false if not.
                /// </returns>
                ///
                /// <remarks>
                ///	This method looks for the innermost node whose rectangle contains the
                /// specified point.  If found, the <see cref="Node" /> object is stored in
                ///	<paramref name="node" /> and true is returned.  false is returned
                ///	otherwise.
                ///
                ///	<para>
                ///	<see cref="Draw(Bitmap, Boolean)" /> should be called before this
                /// method is used.  If it hasn't been called yet, false is returned.
                ///	</para>
                ///
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.GetNodeFromPoint = function (pointF) {
                    // Let the m_oNodes collection do the work.
                    return this.m_oNodes.GetNodeFromPoint(pointF);
                };

                //*************************************************************************
                //	Method: SelectNode()
                //
                /// <summary>
                ///	Selects a node.
                /// </summary>
                ///
                /// <param name="node">
                /// The <see cref="Node" /> to select.  Specify null to remove the
                ///	selection.
                /// </param>
                ///
                /// <param name="bitmap">
                /// If <see cref="Draw(Bitmap, Boolean)" /> has already been called, this
                /// should be the same Bitmap that was passed to <see
                /// cref="Draw(Bitmap, Boolean)" />.  Otherwise, specify null.  <paramref
                /// name="node" /> will then be drawn as selected the first time <see
                /// cref="Draw(Bitmap, Boolean)" /> is called.
                /// </param>
                ///
                /// <remarks>
                ///	This redraws the specified node's rectangle and text to show it as
                ///	selected.  If another node was already selected, it gets redrawn as
                ///	unselected.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.SelectNode = function (node) {
                    // Make the documentation tools happy without having to use camel
                    // casing throughout this method.
                    var oNode = node;

                    if (oNode != null) {
                        oNode.AssertValid();

                        // If the node is already selected, do nothing.
                        if (oNode == this.m_oSelectedNode)
                            return;
                    }

                    this.CancelSelectedNode();

                    if (oNode != null) {
                        // Draw oNode as selected.
                        this.DrawNodeAsSelected(oNode);
                    }

                    this.m_oSelectedNode = oNode;
                };

                //*************************************************************************
                //	Method: CalculateAndDrawRectangles()
                //
                /// <summary>
                /// Calculates and draws the rectangles for a collection of Node objects
                /// and all their descendents.
                /// </summary>
                ///
                /// <param name="oTreemapRectangle">
                /// Outer rectangle for the entire treemap.
                /// </param>
                ///
                /// <param name="oNodes">
                /// Collection of Node objects.
                /// </param>
                ///
                /// <param name="oParentNode">
                /// Parent of oNodes, or null if oNodes are top-level.
                /// </param>
                //*************************************************************************
                TreemapGenerator.prototype.CalculateAndDrawRectangles = function (oTreemapRectangle, oNodes, oParentNode) {
                    Diag.Debug.Assert(oNodes != null);
                    this.AssertValid();

                    // Paint the background.
                    var oBackgroundBrush = this.m_oBackColor;

                    // TODO: overall background        displayRoot.FillRectangle(oBackgroundBrush, oTreemapRectangle);
                    // Create an object that knows how to lay out a treemap.
                    var oLayoutEngine = this.CreateLayoutEngine();

                    // Calculate the rectangles for all the nodes.
                    this.CalculateRectangles(oNodes, oTreemapRectangle, oParentNode, this.GetTopLevelTopPaddingPx(), this.m_iPaddingPx, this.m_iPenWidthPx, oLayoutEngine);

                    // Create an object that creates and caches pens.
                    // var oPenCache = new Microsoft.Treemap.GraphicsLib.PenCache();
                    // oPenCache.Initialize(this.m_oBorderColor);
                    // Draw all the rectangles.
                    this.DrawRectangles(oNodes, 0, this.m_oBorderColor);
                };

                //*************************************************************************
                //	Method: CalculateRectangles()
                //
                /// <summary>
                /// Calculates the rectangles for a collection of Node objects.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of Node objects.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle that will contain the node rectangles.
                /// </param>
                ///
                /// <param name="oParentNode">
                /// Parent of <paramref name="oNodes" />, or null if <paramref
                /// name="oNodes" /> are top-level.
                /// </param>
                ///
                /// <param name="iTopPaddingPx">
                /// Padding to add to the top of the parent rectangle, in pixels.
                /// </param>
                ///
                /// <param name="iLeftRightBottomPaddingPx">
                /// Padding to add to the left, right, and bottom of the parent rectangle,
                /// in pixels.
                /// </param>
                ///
                /// <param name="iPenWidthPx">
                /// Width of the pen used to draw the node rectangles.
                /// </param>
                ///
                /// <param name="oLayoutEngine">
                /// Object that knows how to lay out a treemap.
                /// </param>
                ///
                /// <remarks>
                ///	This method sets the Rectangle and PenWidthPx properties on each Node
                ///	object in the oNodes collection so that the rectangles fit into
                ///	oParentRectangle with no overlap and have appropriate padding.  It then
                /// recurses through all the descendent Node objects and does the same to
                /// them.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.CalculateRectangles = function (oNodes, oParentRectangle, oParentNode, iTopPaddingPx, iLeftRightBottomPaddingPx, iPenWidthPx, oLayoutEngine) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(iTopPaddingPx > 0);
                    Diag.Debug.Assert(iLeftRightBottomPaddingPx > 0);
                    Diag.Debug.Assert(iPenWidthPx >= 0); // roland > 0);
                    Diag.Debug.Assert(oLayoutEngine != null);
                    this.AssertValid();

                    var iSavedTopPaddingPx = iTopPaddingPx;

                    if (oParentNode == null) {
                        // oParentRectangle is the outer rectangle for the entire treemap.
                        // The outer rectangle should always have uniform padding.
                        iTopPaddingPx = iLeftRightBottomPaddingPx;
                    }

                    // Attempt to add padding to the parent rectangle.
                    oParentRectangle = this.AddPaddingToParentRectangle(oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx);

                    if (oParentRectangle == null) {
                        // The rectangle is too small to add padding.  Set all node
                        // rectangles to empty so they won't be drawn.
                        oLayoutEngine.SetNodesRectanglesToEmpty(oNodes, true);

                        return;
                    }

                    if (oParentNode == null) {
                        // Restore the specified top padding for use at lower levels.
                        iTopPaddingPx = iSavedTopPaddingPx;
                    }

                    // Calculate rectangles for the nodes in oNodes.
                    oLayoutEngine.CalculateNodeRectangles(oNodes, oParentRectangle, oParentNode, this.m_eEmptySpaceLocation);

                    // Calculate the left/right/bottom padding and pen width that will be
                    // used for the children of each node in oNodes.
                    var iDecrementedLeftRightBottomPaddingPx = this.DecrementPadding(iLeftRightBottomPaddingPx);

                    var iDecrementedPenWidthPx = this.DecrementPenWidth(iPenWidthPx);

                    // The top padding depends on the text location.
                    var iDecrementedTopPaddingPx = 0;

                    switch (this.m_eContentLocation) {
                        case 0 /* CenteredText */:
                            // The top padding should be the same as the left/right/bottom
                            // padding in this case.
                            iDecrementedTopPaddingPx = iDecrementedLeftRightBottomPaddingPx;

                            break;

                        case 1 /* TopText */:
                            // The top padding, which is where the node text is displayed
                            // in this case, should not change.
                            iDecrementedTopPaddingPx = iTopPaddingPx;

                            break;

                        case 2 /* OwnerDraw */:
                            // if iTopPadding is 0, make like CenteredText
                            // otherwise use that top padding like TopText
                            if (iTopPaddingPx == 0)
                                iDecrementedTopPaddingPx = iDecrementedLeftRightBottomPaddingPx;
                            else
                                iDecrementedTopPaddingPx = iTopPaddingPx;
                            break;

                        default:
                            Diag.Debug.Assert(false);
                            break;
                    }

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);

                        // Skip over empty rectangles.
                        if (oNode.Rectangle.IsEmpty)
                            continue;

                        // Add padding to those sides of the node's rectangle that aren't
                        // next to an edge of the parent.
                        var oPaddedChildRectangle = this.AddPaddingToChildRectangle2(oNode.Rectangle, oParentRectangle, iLeftRightBottomPaddingPx);

                        if (oPaddedChildRectangle == null) {
                            // The rectangle is too small to add padding to.  Fix the
                            // rectangle in some sensible way.
                            oNode.Rectangle = this.FixSmallRectangle(oNode.Rectangle);
                            oNode.PenWidthPx = 1;

                            // Set all descendant node rectangles to empty so they won't be
                            // drawn.
                            oLayoutEngine.SetNodesRectanglesToEmpty(oNode.Nodes, true);

                            continue;
                        }

                        // Save the padded node rectangle and pen width.
                        oNode.Rectangle = oPaddedChildRectangle;

                        //---- why are we try to override the user's pen width property?? ----
                        oNode.PenWidthPx = iPenWidthPx;

                        // Subtract the pen width from the node's rectangle before using it
                        // to calculate rectangles for the node's children.
                        var oPaddedAndPennedNodeRectangle = System.Drawing.Rectangle.Inflate(oPaddedChildRectangle, -iPenWidthPx, -iPenWidthPx);

                        // Calculate rectangles for this node's children.
                        this.CalculateRectangles(oNode.Nodes, oPaddedAndPennedNodeRectangle, oNode, iDecrementedTopPaddingPx, iDecrementedLeftRightBottomPaddingPx, iDecrementedPenWidthPx, oLayoutEngine);
                    }
                };

                //*************************************************************************
                //	Method: DrawRectangles()
                //
                /// <summary>
                /// Draws the rectangles for a collection of Node objects and all their
                /// descendents.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of Node objects.
                /// </param>
                ///
                /// <param name="iNodeLevel">
                /// Level of the nodes in oNodes.  Top-level nodes are level 0.
                /// </param>
                ///
                /// <param name="oPenCache">
                /// Object that creates and caches pens.
                /// </param>
                ///
                /// <remarks>
                ///	It's assumed that the Rectangle and PenWidthPx properties have already
                /// been set on each Node object.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.DrawRectangles = function (oNodes, iNodeLevel, oPenColor) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        var oNodeRectangle = oNode.Rectangle;

                        // Skip over empty rectangles.  An empty rectangle indicates that
                        // a node's calculated rectangle is too small to display.
                        if (oNodeRectangle.IsEmpty)
                            continue;

                        // Get a pen to use for the rectangle's border.
                        //            var oNonDisposablePen = oPenCache.GetPen(oNode.PenWidthPx);
                        var oBrush = oNode.AbsoluteColor;

                        // The node's AbsoluteColor value should determine the
                        // fill color.
                        //
                        // This is not as efficient as using ColorGradientMapper
                        // objects to cache brushes in the UseColorMetric case, but
                        // since each node can have a unique color, caching brushes
                        // isn't practical in the UseAbsoluteColor case.  On a
                        // 1.80 GHz Pentium M, it takes about 0.004 ms to create
                        // and dispose a SolidBrush, so the overhead involved in
                        // creating per-node brushes isn't too great in most cases.
                        // Fill the rectangle's interior and draw its border.
                        var animDuration = (this.m_bIsAnimationEnabled) ? this.m_fAnimDuration : 0;

                        oNode.DisplayRectangle(this.m_displayRoot, oNode.PenWidthPx, oPenColor, oBrush, iNodeLevel, animDuration);

                        // Repeat for this node's child nodes.
                        this.DrawRectangles(oNode.Nodes, iNodeLevel + 1, oPenColor);
                    }
                };

                //*************************************************************************
                //	Method: DrawNodeAsSelected()
                //
                /// <summary>
                ///	Redraws a node's rectangle and text to show it as selected.
                /// </summary>
                ///
                /// <param name="oNode">
                /// The node to draw as selected.
                /// </param>
                ///
                /// <param name="oTreemapRectangle">
                /// Outer rectangle for the entire treemap.
                /// </param>
                //*************************************************************************
                TreemapGenerator.prototype.DrawNodeAsSelected = function (oNode) {
                    Diag.Debug.Assert(oNode != null);
                    oNode.AssertValid();

                    // Adjust the pen width of the node to something that will make the
                    // selection obvious.
                    oNode.SetRectangleFill(this.m_oSelectedBackColor);

                    // Create the object that knows how to draw node text, then tell it to
                    // draw the text for the selected node.
                    var oTextDrawer = this.CreateTextDrawer();

                    oTextDrawer.DrawTextForSelectedNode(oNode);
                };

                //*************************************************************************
                //	Method: FireRedrawRequired()
                //
                /// <summary>
                ///	Fires the RedrawRequired event if appropriate.
                /// </summary>
                ///
                /// <remarks>
                /// This should be called when something occurs that affects the treemap's
                /// appearance.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.FireRedrawRequired = function () {
                    ;
                };

                //*************************************************************************
                //	Method: CancelSelectedNode()
                //
                /// <summary>
                ///	Cancels the selected node.
                /// </summary>
                ///
                /// <remarks>
                ///	The treemap is not redrawn.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.CancelSelectedNode = function () {
                    if (this.m_oSelectedNode) {
                        this.m_oSelectedNode.SetRectangleFill(this.m_oSelectedNode.AbsoluteColor);
                        this.m_oSelectedNode.SetTextColor(this.m_oFontSolidColor); // TODO: use transparent brush mapper for those cases

                        // TODO: ContentLocation.OwnerDraw
                        this.m_oSelectedNode = null;
                    }
                };

                //*************************************************************************
                //	Method: CreateLayoutEngine()
                //
                /// <summary>
                /// Creates an object that knows how to lay out the rectangles in a
                /// treemap.
                /// </summary>
                ///
                /// <returns>
                ///	New object that implements <see cref="ILayoutEngine" />.
                /// </returns>
                //*************************************************************************
                TreemapGenerator.prototype.CreateLayoutEngine = function () {
                    switch (this.m_eLayoutAlgorithm) {
                        case 0 /* BottomWeightedSquarified */:
                            return (new Microsoft.Treemap.Util.BottomWeightedSquarifiedLayoutEngine());

                        case 1 /* TopWeightedSquarified */:
                            return (new Microsoft.Treemap.Util.TopWeightedSquarifiedLayoutEngine());

                        default:
                            Diag.Debug.Assert(false);
                            return (null);
                    }
                };

                //*************************************************************************
                //	Method: CreateTextDrawer()
                //
                /// <summary>
                /// Creates an object that knows how to draw the text for the nodes in a
                /// treemap.
                /// </summary>
                ///
                /// <returns>
                ///	New object that implements <see cref="ITextDrawer" />.
                /// </returns>
                //*************************************************************************
                TreemapGenerator.prototype.CreateTextDrawer = function () {
                    this.AssertValid();

                    switch (this.m_eContentLocation) {
                        case 0 /* CenteredText */:
                            return (new Microsoft.Treemap.Util.CenterCenterTextDrawer(this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_fFontMinSizePt, this.m_fFontMaxSizePt, this.m_fFontIncrementPt, this.m_oFontSolidColor, this.m_iFontMinAlpha, this.m_iFontMaxAlpha, this.m_iFontAlphaIncrementPerLevel, this.m_oSelectedFontColor, this.AnimationDuration));

                        case 1 /* TopText */:
                            return (new Microsoft.Treemap.Util.TopTextDrawer(this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_fFontMinSizePt, this.GetTopMinimumTextHeight(), this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor, this.AnimationDuration));

                        case 2 /* OwnerDraw */:
                            return new Microsoft.Treemap.Util.OwnerDrawDrawer(this.m_ownerDraw, this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor, this.AnimationDuration);

                        default:
                            Diag.Debug.Assert(false);
                            return (null);
                    }
                };

                //*************************************************************************
                //	Method: AddPaddingToParentRectangle()
                //
                /// <summary>
                /// Adds padding to a parent rectangle.
                /// </summary>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle to add padding to.  Gets modified if true is returned.
                /// </param>
                ///
                /// <param name="iTopPaddingPx">
                /// Padding to add to the top of <paramref name="oParentRectangle" />, in
                /// pixels.  May get modified if true is returned.
                /// </param>
                ///
                /// <param name="iLeftRightBottomPaddingPx">
                /// Padding to add to the left, right, and bottom of <paramref
                /// name="oParentRectangle" />, in pixels.  May get modified if true is
                /// returned.
                /// </param>
                ///
                /// <returns>
                /// true if padding was successfully added, false if not.
                /// </returns>
                ///
                /// <remarks>
                /// This method attempts to add padding to <paramref
                /// name="oParentRectangle" />.  If the resulting padded rectangle is
                /// larger than the minimum rectangle size, the padded rectangle is stored
                /// at <paramref name="oParentRectangle" /> and true is returned.
                /// Otherwise, an attempt is made using a minimum padding value.  If both
                /// attempts fail, false is returned.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.AddPaddingToParentRectangle = function (oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx) {
                    Diag.Debug.Assert(iTopPaddingPx >= 0);
                    Diag.Debug.Assert(iLeftRightBottomPaddingPx >= 0);

                    // Try the specified padding.
                    var oPaddedParentRectangle = this.AddPaddingToRectangle(oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx);

                    // Is the deflated rectangle smaller than the minimum size?
                    if (this.RectangleIsSmallerThanMin(oPaddedParentRectangle)) {
                        // Yes.
                        return null;
                    }

                    return oPaddedParentRectangle;
                };

                //*************************************************************************
                //	Method: AddPaddingToRectangle()
                //
                /// <summary>
                /// Adds padding to a rectangle.
                /// </summary>
                ///
                /// <param name="oRectangle">
                /// Rectangle to add padding to.
                /// </param>
                ///
                /// <param name="iTopPaddingPx">
                /// Padding to add to the top of <paramref name="oRectangle" />, in pixels.
                /// </param>
                ///
                /// <param name="iLeftRightBottomPaddingPx">
                /// Padding to add to the left, right, and bottom of <paramref
                /// name="oRectangle" />, in pixels.
                /// </param>
                ///
                /// <returns>
                /// Padded rectangle.
                /// </returns>
                //*************************************************************************
                TreemapGenerator.prototype.AddPaddingToRectangle = function (oRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx) {
                    Diag.Debug.Assert(iTopPaddingPx >= 0);
                    Diag.Debug.Assert(iLeftRightBottomPaddingPx >= 0);

                    return (System.Drawing.Rectangle.FromLTRB(oRectangle.Left + iLeftRightBottomPaddingPx, oRectangle.Top + iTopPaddingPx, oRectangle.Right - iLeftRightBottomPaddingPx, oRectangle.Bottom - iLeftRightBottomPaddingPx));
                };

                //*************************************************************************
                //	Method: AddPaddingToChildRectangle()
                //
                /// <summary>
                /// Adds padding to a child node rectangle.
                /// </summary>
                ///
                /// <param name="oChildRectangle">
                /// Child rectangle to add padding to.  Gets updated if true is returned.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent of <paramref name="oChildRectangle" />.
                /// </param>
                ///
                /// <param name="iPaddingPx">
                /// Padding to add to those sides of <paramref name="oChildRectangle" />
                /// that are not next to the side of the parent rectangle, in pixels.
                /// </param>
                ///
                /// <returns>
                /// true if padding was successfully added, false if not.
                /// </returns>
                ///
                /// <remarks>
                ///	This method attempts to add padding to those sides of a child node's
                /// rectangle that are not next to the side of the parent rectangle.  (If a
                /// side of the child rectangle is next to the side of the parent, the
                /// parent provides the padding for that side.  Only sides that are not
                /// next to the side of the parent rectangle need their own padding.)  If
                /// the attempt succeeds, the results are stored at <paramref
                /// name="oChildRectangle" /> and true is returned.  false is returned
                /// otherwise.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.AddPaddingToChildRectangle2 = function (oChildRectangle, oParentRectangle, iPaddingPx) {
                    // Add the specified padding to those sides of the node's rectangle
                    // that aren't next to an edge of the parent.
                    var oPaddedChildRectangle = this.AddPaddingToChildRectangle(oChildRectangle, oParentRectangle, iPaddingPx);

                    // Is the resulting rectangle too small?
                    if (this.RectangleIsSmallerThanMin(oPaddedChildRectangle)) {
                        // Yes.  Try using the minimum padding.
                        if (iPaddingPx > TreemapGenerator.MinPaddingPx) {
                            oPaddedChildRectangle = this.AddPaddingToChildRectangle(oChildRectangle, oParentRectangle, TreemapGenerator.MinPaddingPx);
                        }

                        if (this.RectangleIsSmallerThanMin(oPaddedChildRectangle)) {
                            // It's still too small.
                            return null;
                        }
                    }

                    return oPaddedChildRectangle;
                };

                //*************************************************************************
                //	Method: AddPaddingToChildRectangle()
                //
                /// <summary>
                /// Adds padding to a child node rectangle.
                /// </summary>
                ///
                /// <param name="oChildRectangle">
                /// Child rectangle to add padding to.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle.
                /// </param>
                ///
                /// <param name="iPaddingPx">
                /// Padding to add to <paramref name="oChildRectangle" />, in pixels.
                /// </param>
                ///
                /// <returns>
                /// Modified copy of <paramref name="oChildRectangle" /> with added padding.
                /// </returns>
                ///
                /// <remarks>
                ///	This method adds padding to those sides of a child node's rectangle
                /// that are not next to the side of the parent rectangle.  (If a side of
                /// the child rectangle is next to the side of the parent, the parent
                /// provides the padding for that side.  Only sides that are not next to
                /// the side of the parent rectangle need their own padding.)
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.AddPaddingToChildRectangle = function (oChildRectangle, oParentRectangle, iPaddingPx) {
                    var fLeft = oChildRectangle.Left;
                    var fTop = oChildRectangle.Top;
                    var fRight = oChildRectangle.Right;
                    var fBottom = oChildRectangle.Bottom;

                    // Add only half the padding.  The rectangle next to this one will add
                    // the other half.
                    var fHalfPaddingPx = (iPaddingPx + 1) / 2;

                    if (Math.round(oChildRectangle.Left) != Math.round(oParentRectangle.Left)) {
                        fLeft += fHalfPaddingPx;
                    }

                    if (Math.round(oChildRectangle.Top) != Math.round(oParentRectangle.Top)) {
                        fTop += fHalfPaddingPx;
                    }

                    if (Math.round(oChildRectangle.Right) != Math.round(oParentRectangle.Right)) {
                        fRight -= fHalfPaddingPx;
                    }

                    if (Math.round(oChildRectangle.Bottom) != Math.round(oParentRectangle.Bottom)) {
                        fBottom -= fHalfPaddingPx;
                    }

                    return (System.Drawing.Rectangle.FromLTRB(fLeft, fTop, fRight, fBottom));
                };

                //*************************************************************************
                //	Method: GetTopLevelTopPaddingPx()
                //
                /// <summary>
                /// Gets the padding to use at the top of top-level node rectangles.
                /// </summary>
                ///
                /// <param name="oGraphics">
                /// Object to draw onto.
                /// </param>
                ///
                /// <returns>
                /// The padding to use at the top of the rectangles for the top-level
                /// nodes, in pixels.
                /// </returns>
                //*************************************************************************
                TreemapGenerator.prototype.GetTopLevelTopPaddingPx = function () {
                    this.AssertValid();

                    var iTopLevelTopPaddingPx;

                    switch (this.m_eContentLocation) {
                        case 0 /* CenteredText */:
                            // The top padding should be the value specified in the
                            // PaddingPx property.
                            iTopLevelTopPaddingPx = this.m_iPaddingPx;
                            break;

                        case 1 /* TopText */:
                            // The top padding is set by the object that draws text for
                            // this case.
                            iTopLevelTopPaddingPx = Microsoft.Treemap.Util.TopTextDrawer.GetTextHeight(this.m_displayRoot, this.m_sFontFamily, this.m_fFontNormSizePt, this.GetTopMinimumTextHeight()) + 2;

                            break;

                        case 2 /* OwnerDraw */:
                            iTopLevelTopPaddingPx = this.m_ownerDraw.GetTopHeight(this.m_displayRoot);

                            break;

                        default:
                            Diag.Debug.Assert(false);
                            iTopLevelTopPaddingPx = -1;

                            break;
                    }

                    return (iTopLevelTopPaddingPx);
                };

                //*************************************************************************
                //	Method: GetTopMinimumTextHeight()
                //
                /// <summary>
                /// Gets the minimum allowed height of the text when <see
                /// cref="TextLocation" /> is set to Top.
                /// </summary>
                //*************************************************************************
                TreemapGenerator.prototype.GetTopMinimumTextHeight = function () {
                    this.AssertValid();

                    // The text must be at least as large as the padding added to the
                    // inside of top-level nodes.
                    return (this.DecrementPadding(this.m_iPaddingPx));
                };

                //*************************************************************************
                //	Method: DecrementPadding()
                //
                /// <summary>
                ///	Decrements the padding that gets added to the rectangles for the Node
                /// objects in a Nodes collection.
                /// </summary>
                ///
                /// <param name="iPaddingPx">
                /// Padding to decrement, in pixels.
                /// </param>
                ///
                /// <returns>
                /// Decremented padding, in pixels.
                /// </returns>
                ///
                /// <remarks>
                ///	The padding can be made to decrease at each node level by setting <see
                /// cref="PaddingDecrementPerLevelPx" /> to a positive value.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.DecrementPadding = function (iPaddingPx) {
                    return (Math.max(iPaddingPx - this.m_iPaddingDecrementPerLevelPx, TreemapGenerator.MinPaddingPx));
                };

                //*************************************************************************
                //	Method: DecrementPenWidth()
                //
                /// <summary>
                ///	Decrements the pen width that is used to draw the rectangles for the
                /// Node objects in a Nodes collection.
                /// </summary>
                ///
                /// <param name="iPenWidthPx">
                /// Pen width to decrement, in pixels.
                /// </param>
                ///
                /// <returns>
                /// Decremented pen width, in pixels.
                /// </returns>
                ///
                /// <remarks>
                ///	The pen width can be made to decrease at each node level by setting
                ///	<see cref="PenWidthDecrementPerLevelPx" /> to a positive value.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.DecrementPenWidth = function (iPenWidthPx) {
                    return (Math.max(iPenWidthPx - this.m_iPenWidthDecrementPerLevelPx, 1));
                };

                //*************************************************************************
                //	Method: RectangleIsSmallerThanMin()
                //
                /// <summary>
                ///	Determines whether a rectangle's height or width is smaller than an
                /// allowed size.
                /// </summary>
                ///
                /// <param name="oRectangle">
                /// Rectangle to test.
                /// </param>
                ///
                /// <returns>
                /// true if <paramref name="oRectangle" /> is smaller than the minimum.
                /// </returns>
                //*************************************************************************
                TreemapGenerator.prototype.RectangleIsSmallerThanMin = function (oRectangle) {
                    return (oRectangle.Width < TreemapGenerator.MinRectangleWidthOrHeightPx || oRectangle.Height < TreemapGenerator.MinRectangleWidthOrHeightPx);
                };

                //*************************************************************************
                //	Method: FixSmallRectangle()
                //
                /// <summary>
                /// Deals with a rectangle that is smaller than an allowed size.
                /// </summary>
                ///
                /// <param name="oUnpaddedNodeRectangle">
                /// RectangleF.  Node's rectangle, without padding.
                /// </param>
                ///
                /// <returns>
                ///	Modified copy of oUnpaddedNodeRectangle.
                /// </returns>
                ///
                /// <remarks>
                ///	This method is called when it's determined that a node's rectangle with
                ///	padding is too small to display as a rectangle.  It returns a modified
                ///	rectangle to use for the node.
                /// </remarks>
                //*************************************************************************
                TreemapGenerator.prototype.FixSmallRectangle = function (oUnpaddedNodeRectangle) {
                    var fLeft = oUnpaddedNodeRectangle.Left;
                    var fTop = oUnpaddedNodeRectangle.Top;
                    var fRight = oUnpaddedNodeRectangle.Right;
                    var fBottom = oUnpaddedNodeRectangle.Bottom;
                    var fWidth = oUnpaddedNodeRectangle.Width;
                    var fHeight = oUnpaddedNodeRectangle.Height;
                    var fHalfMin = TreemapGenerator.MinRectangleWidthOrHeightPx / 2;

                    if (fHeight < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                        // Make the rectangle the minimum height, properly centered.
                        fTop = (fTop + fBottom) / 2.0 - fHalfMin;
                        fBottom = fTop + TreemapGenerator.MinRectangleWidthOrHeightPx;
                    }

                    if (fWidth < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                        // Make the rectangle the minimum width, properly centered.
                        fLeft = (fLeft + fRight) / 2 - fHalfMin;
                        fRight = fLeft + TreemapGenerator.MinRectangleWidthOrHeightPx;
                    }

                    var oFixedRectangle = System.Drawing.Rectangle.FromLTRB(fLeft, fTop, fRight, fBottom);

                    if (fHeight < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                        Diag.Debug.Assert(Math.round(oFixedRectangle.Height) == TreemapGenerator.MinRectangleWidthOrHeightPx);
                    }

                    if (fWidth < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                        Diag.Debug.Assert(Math.round(oFixedRectangle.Width) == TreemapGenerator.MinRectangleWidthOrHeightPx);
                    }

                    return (oFixedRectangle);
                };

                //*************************************************************************
                //	Method: AssertValid()
                //
                /// <summary>
                ///	Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                TreemapGenerator.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_oNodes != null);
                    this.m_oNodes.AssertValid();

                    Diag.Debug.Assert(this.m_iPaddingPx >= TreemapGenerator.MinPaddingPx);
                    Diag.Debug.Assert(this.m_iPaddingPx <= TreemapGenerator.MaxPaddingPx);

                    Diag.Debug.Assert(this.m_iPaddingDecrementPerLevelPx >= TreemapGenerator.MinPaddingDecrementPerLevelPx);

                    Diag.Debug.Assert(this.m_iPaddingDecrementPerLevelPx <= TreemapGenerator.MaxPaddingDecrementPerLevelPx);

                    Diag.Debug.Assert(this.m_iPenWidthPx >= TreemapGenerator.MinPenWidthPx);
                    Diag.Debug.Assert(this.m_iPenWidthPx <= TreemapGenerator.MaxPenWidthPx);

                    Diag.Debug.Assert(this.m_iPenWidthDecrementPerLevelPx >= TreemapGenerator.MinPenWidthDecrementPerLevelPx);

                    Diag.Debug.Assert(this.m_iPenWidthDecrementPerLevelPx <= TreemapGenerator.MaxPenWidthDecrementPerLevelPx);

                    // m_oBackColor
                    // m_oBorderColor
                    Diag.Debug.AssertNotEmpty(this.m_sFontFamily);

                    Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMaxSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMaxSizePt >= this.m_fFontMinSizePt);
                    Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                    Diag.Debug.Assert(this.m_fFontNormSizePt <= this.m_fFontMaxSizePt);
                    Diag.Debug.Assert(this.m_fFontIncrementPt > 0);

                    Diag.Debug.Assert(this.m_oFontSolidColor.A == 255);
                    Diag.Debug.Assert(this.m_iFontMinAlpha >= 0 && this.m_iFontMinAlpha <= 255);
                    Diag.Debug.Assert(this.m_iFontMaxAlpha >= 0 && this.m_iFontMaxAlpha <= 255);
                    Diag.Debug.Assert(this.m_iFontMaxAlpha >= this.m_iFontMinAlpha);
                    Diag.Debug.Assert(this.m_iFontAlphaIncrementPerLevel > 0);

                    // m_oSelectedFontColor
                    // m_oSelectedBackColor
                    // Diag.Debug.Assert( Enum.IsDefined(typeof(NodeLevelsWithText), this.m_iNodeLevelsWithText) );
                    Diag.Debug.Assert(this.m_iMinNodeLevelWithText >= 0);
                    Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= 0);
                    Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= this.m_iMinNodeLevelWithText);

                    // Diag.Debug.Assert( Enum.IsDefined(typeof(ContentLocation), this.m_eContentLocation) );
                    // Diag.Debug.Assert( Enum.IsDefined(typeof(EmptySpaceLocation), this.m_eEmptySpaceLocation) );
                    if (this.m_oSelectedNode != null)
                        this.m_oSelectedNode.AssertValid();

                    // m_bInBeginUpdate
                    // Diag.Debug.Assert( Enum.IsDefined(typeof(LayoutAlgorithm), this.m_eLayoutAlgorithm) );
                    if (this.m_ownerDraw) {
                        Diag.Debug.Assert(this.m_eContentLocation == 2 /* OwnerDraw */);
                    } else {
                        Diag.Debug.Assert(this.m_eContentLocation != 2 /* OwnerDraw */);
                    }
                };
                TreemapGenerator.MinPaddingPx = 1;

                TreemapGenerator.MaxPaddingPx = 100;

                TreemapGenerator.MinPaddingDecrementPerLevelPx = 0;

                TreemapGenerator.MaxPaddingDecrementPerLevelPx = 99;

                TreemapGenerator.MinPenWidthPx = 0;

                TreemapGenerator.MaxPenWidthPx = 100;

                TreemapGenerator.MinPenWidthDecrementPerLevelPx = 0;

                TreemapGenerator.MaxPenWidthDecrementPerLevelPx = 99;

                TreemapGenerator.MinRectangleWidthOrHeightPx = 1;
                return TreemapGenerator;
            })();
            Generator.TreemapGenerator = TreemapGenerator;
        })(Treemap.Generator || (Treemap.Generator = {}));
        var Generator = Treemap.Generator;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
///<reference path="../scripts/allfiles.ts" />
var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (GraphicsLib) {
            var Diag = System.Diagnostics;

            var GraphicsUtil = (function () {
                function GraphicsUtil() {
                }
                //*************************************************************************
                //  Method: RectangleFToRectangle()
                //
                /// <summary>
                /// Converts a RectangleF to a Rectangle.
                /// </summary>
                ///
                /// <param name="oRectangle">
                /// Rectangle to convert.
                /// </param>
                ///
                /// <param name="iPenWidthPx">
                /// Width of the pen that will be used to draw the rectangle.
                /// </param>
                ///
                /// <returns>
                /// Converted rectangle.
                /// </returns>
                ///
                /// <remarks>
                /// This method converts a floating-point RectangleF to an integer
                /// Rectangle, compensating for some GDI oddities in the process.
                ///
                /// <para>
                /// If precise rectangle drawing is required, the caller should convert
                /// all RectangleF objects to Rectangles using this method, then use the
                /// Graphics.DrawRectangle(Pen, Rectangle) method to draw them.  The
                /// floating-point version of Graphics.DrawRectangle() should not be used.
                /// </para>
                ///
                /// </remarks>
                //*************************************************************************
                GraphicsUtil.RectangleFToRectangle = function (oRectangle, iPenWidthPx) {
                    /*
                    GDI draws floating-point rectangles in an odd manner.  Consider the
                    following code:
                    
                    RectangleF oRectangle =
                    RectangleF.FromLTRB(fLeft, fTop, fRight, fBottom);
                    
                    Pen oPen = new Pen(Color.Black, iPenWidthPx);
                    oPen.Alignment = PenAlignment.Inset;
                    
                    displayRoot.DrawRectangle(oPen, oRectangle.X, oRectangle.Y,
                    oRectangle.Width, oRectangle.Height);
                    
                    If iPenWidthPx is 1, then GDI rounds all the rectangle's coordinates
                    before drawing the rectangle.  For example, fLeft values between
                    0 and 0.50, inclusive, cause the left edge to be drawn at X=0.  fLeft
                    values between 0.51 and 1.50 result in a left edge at X=1.  Similarly,
                    fBottom values between 4.51 and 5.50 result in a bottom edge at Y=5,
                    and fBottom values between 5.51 and 6.50 result in a bottom edge at Y=6.
                    fRight and fTop are treated the same way.  This all seems like sensible
                    behavior.
                    
                    If iPenWidthPx is greater than 1, however, the behavior changes.  The
                    fLeft and fTop values are rounded up, while the fRight and fBottom
                    values are rounded down.  For example, fLeft values between 0.1 and 1.0
                    cause the left edge to be drawn at X=1, and fLeft values between 1.1
                    and 2.0 result in a left edge at X=2.  fBottom values between
                    4.1 and 5.0 cause the bottom edge to be drawn at Y=4, and fBottom
                    values between 5.1 and 6.0 cause the bottom edge to be drawn at Y=5.
                    
                    The odd behavior for pen widths greater than 1 causes unexpected and
                    inconsistent rectangle spacing.  To fix this problem, the following
                    code rounds all values.  If the rectangle is going to be drawn with a
                    pen width greater than 1, the code then adds 1 to the right and bottom
                    values to compensate for GDI's inconsistency.
                    
                    This also fixes an oddity where GDI sometimes leaves off corner pixels
                    when drawing rectangles using floating-point coordinates.
                    */
                    var iLeft = Math.round(oRectangle.Left);
                    var iRight = Math.round(oRectangle.Right);
                    var iTop = Math.round(oRectangle.Top);
                    var iBottom = Math.round(oRectangle.Bottom);

                    /*
                    if (iPenWidthPx > 1)
                    {
                    iRight++;
                    iBottom++;
                    }
                    */
                    return (System.Drawing.Rectangle.FromLTRB(iLeft, iTop, iRight, iBottom));
                };
                return GraphicsUtil;
            })();
            GraphicsLib.GraphicsUtil = GraphicsUtil;

            /*
            //*****************************************************************************
            //    Class: PenCache
            //
            /// <summary>
            ///    Creates a Pen object on request and caches it for future requests.
            /// </summary>
            ///
            /// <remarks>
            ///    Call the Initialize() method to specify the color of all the pens that
            ///    will be requested.  You can then call GetPen() to get a Pen object of a
            ///    particular width.  If you call GetPen() again with the same width, the
            ///    cached pen will be returned instead of being created from scratch.
            ///
            /// <para>
            ///    Call Dispose() when you are done using the object.
            /// </para>
            ///
            ///    </remarks>
            //*****************************************************************************
            
            export class PenCache
            {
            constructor ()
            {
            this.m_oPens = {};
            }
            
            //*************************************************************************
            //    Method: Initialize()
            //
            /// <summary>
            /// Initialize method.
            /// </summary>
            ///
            /// <param name="oPenColor">
            /// Color.  Color of all the pens that will be created.
            /// </param>
            ///
            /// <remarks>
            ///    This must be called before any other methods or properties are used.
            /// </remarks>
            //*************************************************************************
            
            public Initialize(oPenColor : System.Drawing.Color)
            {
            this.m_oPenColor = oPenColor;
            }
            
            //*************************************************************************
            //    Method: GetPen()
            //
            /// <summary>
            /// GetPen method.
            /// </summary>
            ///
            /// <param name="iWidthPx">
            /// Int32.  Width of the pen, in pixels.
            /// </param>
            ///
            /// <returns>
            ///    Pen of the specified width.
            /// </returns>
            ///
            /// <remarks>
            ///    Returns a pen of the specified width.  If the pen already exists in the
            ///    internal cache, the cached pen is returned.
            /// </remarks>
            //*************************************************************************
            
            public GetPen(iWidthPx : number) : System.Drawing.Pen
            {
            if (iWidthPx <= 0)
            {
            throw new System.ArgumentOutOfRangeException("iWidthPx", iWidthPx,
            "PenCache.GetPen(): iWidthPx must be > 0.");
            }
            
            // If the pen isn't in the cache, create and cache it.
            
            var oPen = <System.Drawing.Pen>this.m_oPens[iWidthPx];
            
            if (oPen == null)
            {
            oPen = new System.Drawing.Pen(this.m_oPenColor, iWidthPx);
            //            oPen.Alignment = System.Drawing.Drawing2D.PenAlignment.Inset;
            this.m_oPens[iWidthPx] = oPen;
            }
            
            return (oPen);
            }
            
            //*************************************************************************
            //    Method: AssertValid()
            //
            /// <summary>
            /// AssertValid method.
            /// </summary>
            ///
            /// <remarks>
            ///    Asserts if the object is in an invalid state.  Debug-only.
            /// </remarks>
            //*************************************************************************
            
            AssertValid()
            {
            Diag.Debug.Assert(this.m_oPens != null);
            }
            
            //*************************************************************************
            //    Protected member data
            //*************************************************************************
            
            // Dictionary of pens, keyed by pen width in pixels.
            
            m_oPens: { };
            
            // Color of all the pens.
            
            m_oPenColor : System.Drawing.Color;
            }
            
            */
            //*****************************************************************************
            //	Class: TransparentBrushMapper
            //
            /// <summary>
            ///	Provides a solid brush that uses a transparent color.
            /// </summary>
            ///
            /// <remarks>
            ///	This object creates a set of transparent brushes, with a transparency that
            ///	varies from a maximum to a minimum in equal steps.  Each brush has a
            ///	"level" that varies from 0 to the number of brushes minus 1.  The lowest-
            ///	level brush has the maximum transparency and the highest-level has the
            ///	minimum transparency.
            ///
            /// <para>
            ///	Call the Initialize() method to specify a brush color and the transparency
            ///	levels to use.  Initialize() creates all the brushes at once and saves them
            ///	in an internal array.  You can then call LevelToBrush() to get a Brush
            ///	object for a specified level.  If the specified level is greater than the
            ///	level of the highest-level (minimum transparency) brush, the highest-level
            ///	brush is returned.
            /// </para>
            ///
            /// <para>
            ///	Call Dispose() when you are done using the object.
            /// </para>
            ///
            ///	</remarks>
            //*****************************************************************************
            var TransparentBrushMapper = (function () {
                //*************************************************************************
                //	Constructor: TransparentBrushMapper()
                //
                /// <summary>
                /// TransparentBrushMapper constructor.
                /// </summary>
                //*************************************************************************
                function TransparentBrushMapper() {
                    this.m_oTransparentBrushes = null;
                    this.m_iTransparentBrushes = 0;
                }
                //*************************************************************************
                //	Method: Initialize()
                //
                /// <summary>
                /// Initialize method.
                /// </summary>
                ///
                /// <param name="oSolidColor">
                /// Color.  Color to use for all brushes.  Must have alpha set to 255.
                /// </param>
                ///
                /// <param name="iMinAlpha">
                /// Int32.  Alpha value to use for the level with maximum transparency.
                /// Must be between 0 and 255.
                /// </param>
                ///
                /// <param name="iMaxAlpha">
                /// Int32.  Alpha value to use for the level with minimum transparency.
                /// Must be between 0 and 255.  Must be >= iMinAlpha.
                /// </param>
                ///
                /// <param name="iAlphaIncrementPerLevel">
                /// Int32.  Amount that alpha should be incremented from level to level.
                /// Must be > 0.
                /// </param>
                ///
                /// <remarks>
                ///	This must be called before any other methods or properties are used.
                /// </remarks>
                //*************************************************************************
                TransparentBrushMapper.prototype.Initialize = function (oSolidColor, iMinAlpha, iMaxAlpha, iAlphaIncrementPerLevel) {
                    var sMethodName = "TransparentBrushMapper.Initialize()";

                    if (oSolidColor.A != 255) {
                        throw new System.ArgumentOutOfRangeException("oSolidColor", oSolidColor, sMethodName + ": oSolidColor must not be transparent.");
                    }

                    TransparentBrushMapper.ValidateAlphaRange(iMinAlpha, iMaxAlpha, iAlphaIncrementPerLevel, sMethodName);

                    // Create an empty array.
                    this.m_oTransparentBrushes = new Array();

                    for (var iAlpha = iMinAlpha; iAlpha <= iMaxAlpha; iAlpha += iAlphaIncrementPerLevel) {
                        // Create and save a transparent brush.
                        var oTransparentColor = System.Drawing.Color.FromArgb3(iAlpha, oSolidColor);
                        var oTransparentBrush = oTransparentColor;
                        this.m_oTransparentBrushes.push(oTransparentBrush);
                    }

                    this.m_iTransparentBrushes = this.m_oTransparentBrushes.length;

                    this.AssertValid();
                };

                //*************************************************************************
                //	Method: LevelToTransparentBrush()
                //
                /// <summary>
                /// LevelToTransparentBrush method.
                /// </summary>
                ///
                /// <param name="iLevel">
                /// Int32.  Level of transparency.  Must be >= 0.  If this is greater than
                ///	the level of the highest-level (minimum transparency) brush, the
                ///	highest-level brush is returned.
                /// </param>
                ///
                /// <returns>
                ///	Brush with the specified level of transparency.
                /// </returns>
                ///
                /// <remarks>
                ///	Returns a Brush object with a specified level of transparency.
                /// </remarks>
                //*************************************************************************
                TransparentBrushMapper.prototype.LevelToTransparentBrush = function (iLevel) {
                    this.AssertValid();

                    if (iLevel < 0) {
                        throw new System.ArgumentOutOfRangeException("iLevel", iLevel, "TransparentBrushMapper.LevelToTransparentBrush: iLevel must" + " be >= 0.");
                    }

                    // A level greater than the level of the highest-level brush should be
                    // mapped to the highest-level brush.
                    if (iLevel >= this.m_iTransparentBrushes)
                        iLevel = this.m_iTransparentBrushes - 1;

                    return this.m_oTransparentBrushes[iLevel];
                };

                //*************************************************************************
                //	Method: ValidateAlphaRange()
                //
                /// <summary>
                /// ValidateAlphaRange method.
                /// </summary>
                ///
                /// <param name="iMinAlpha">
                /// Int32.  Alpha value to use for the level with maximum transparency.
                /// Must be between 0 and 255.
                /// </param>
                ///
                /// <param name="iMaxAlpha">
                /// Int32.  Alpha value to use for the level with minimum transparency.
                /// Must be between 0 and 255.  Must be >= iMinAlpha.
                /// </param>
                ///
                /// <param name="iIncrementPerLevel">
                /// Int32.  Amount that alpha should be incremented from level to level.
                /// Must be > 0.
                /// </param>
                ///
                /// <param name="sCaller">
                /// String.  Name of the caller.  Used in exception messages.  Sample:
                ///	"TransparentBrushMapper.Initialize()".
                /// </param>
                ///
                /// <remarks>
                ///	Throws an exception if one of the parameters is invalid.
                /// </remarks>
                //*************************************************************************
                TransparentBrushMapper.ValidateAlphaRange = function (iMinAlpha, iMaxAlpha, iIncrementPerLevel, sCaller) {
                    if (iMinAlpha < 0 || iMinAlpha > 255) {
                        throw new System.ArgumentOutOfRangeException("iMinAlpha", iMinAlpha, sCaller + ": iMinAlpha must be between 0 and 255.");
                    }

                    if (iMaxAlpha < 0 || iMaxAlpha > 255) {
                        throw new System.ArgumentOutOfRangeException("iMaxAlpha", iMaxAlpha, sCaller + ": iMaxAlpha must be between 0 and 255.");
                    }

                    if (iMaxAlpha < iMinAlpha) {
                        throw new System.ArgumentOutOfRangeException("iMaxAlpha", iMaxAlpha, sCaller + ": iMaxAlpha must be >= iMinAlpha.");
                    }

                    if (iIncrementPerLevel <= 0) {
                        throw new System.ArgumentOutOfRangeException("iIncrementPerLevel", iIncrementPerLevel, sCaller + ": iIncrementPerLevel must be > 0.");
                    }
                };

                //*************************************************************************
                //	Method: AssertValid()
                //
                /// <summary>
                /// AssertValid method.
                /// </summary>
                ///
                /// <remarks>
                ///	Asserts if the object is in an invalid state.  Debug-only.
                /// </remarks>
                //*************************************************************************
                TransparentBrushMapper.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_oTransparentBrushes != null);
                    Diag.Debug.Assert(this.m_iTransparentBrushes != 0);
                };
                return TransparentBrushMapper;
            })();
            GraphicsLib.TransparentBrushMapper = TransparentBrushMapper;
        })(Treemap.GraphicsLib || (Treemap.GraphicsLib = {}));
        var GraphicsLib = Treemap.GraphicsLib;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
///<reference path="../scripts/allfiles.ts" />
var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (Generator) {
            var Diag = System.Diagnostics;

            //*****************************************************************************
            //    Class: Node
            //
            /// <summary>
            /// Represents one rectangle within a treemap.
            /// </summary>
            ///
            /// <remarks>
            /// <see cref="Node" /> objects are arranged in a hierarchy.  The
            ///    <see cref="ITreemapComponent.Nodes" /> property on <see
            /// cref="ITreemapComponent" /> returns a <see
            /// cref="Microsoft.Treemap.Generator.Nodes" />
            ///    collection containing the top-level <see cref="Node" /> objects.  Each <see
            /// cref="Node" /> object has a <see
            /// cref="Microsoft.Treemap.Generator.Nodes" />
            ///    collection containing its child <see cref="Node" /> objects.  A leaf <see
            /// cref="Node" /> object has an empty <see
            /// cref="Microsoft.Treemap.Generator.Nodes" />
            /// collection.
            ///
            /// <para>
            ///    To add a <see cref="Node" /> to the hierarchy, you can use one of the
            /// Nodes.<see cref="Microsoft.Treemap.Generator.Nodes.
            /// Add(String, Single, Single)" /> methods.  This will create the <see
            /// cref="Node" /> and add it to the Nodes collection in one step.  You can
            /// also explicitly create a new <see cref="Node" /> object and add it to the
            /// hierarchy using the Nodes.<see
            /// cref="Microsoft.Treemap.Generator.Nodes.Add(Node)" />
            /// method that takes a <see cref="Node" /> object.
            /// </para>
            ///
            /// <para>
            /// The size of the Node's rectangle is determined by the <see
            /// cref="SizeMetric" /> property.  The fill color of the rectangle is
            /// determined by either the <see cref="ColorMetric" /> or <see
            /// cref="AbsoluteColor" /> property, depending on how <see
            /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set.
            /// </para>
            ///
            /// <para>
            /// To conserve memory, the Node's <see cref="ColorMetric" /> and <see
            /// cref="AbsoluteColor" /> properties are stored in the same internal field,
            /// meaning that a <see cref="Node" /> can store either a color metric or an
            /// absolute color, but not both.  See <see cref="Microsoft.Research.
            /// CommunityTechnologies.Treemap.TreemapGenerator.NodeColorAlgorithm" /> for
            /// more details.
            /// </para>
            ///
            /// <para>
            /// The Node's <see cref="Text" /> gets displayed within the Node's rectangle.
            /// A <see cref="Node" /> has an optional <see cref="Tag" /> and <see
            /// cref="ToolTip" />.
            /// </para>
            ///
            /// </remarks>
            //*****************************************************************************
            var Node = (function () {
                //*************************************************************************
                //    Constructor: Node()
                //
                /// <summary>
                /// Initializes a new instance of the Node class with the specified text,
                /// size metric, color metric, tag, and tooltip.
                /// </summary>
                ///
                /// <param name="text">
                /// Text to display within the Node's rectangle.  Can be null or empty.
                /// </param>
                ///
                /// <param name="sizeMetric">
                /// Determines the size of the Node's rectangle.  See
                ///    <see cref="SizeMetric" />.
                /// </param>
                ///
                /// <param name="colorMetric">
                /// Determines the fill color of the Node's rectangle.  See
                /// <see cref="ColorMetric" />.
                /// </param>
                ///
                /// <param name="tag">
                /// Arbitrary object to associate with the Node.  Can be null.
                /// </param>
                ///
                /// <param name="toolTip">
                /// Tooltip to show for the Node.  Can be null or empty.  Used by
                /// TreemapControl, not used by <see cref="TreemapGenerator" />.
                /// </param>
                ///
                /// <param name="textColor">
                /// The color of the text in the node.  Can be null or empty.
                /// </param>
                ///
                ///    <seealso cref="SizeMetric" />
                ///    <seealso cref="ColorMetric" />
                //*************************************************************************
                function Node(text, sizeMetric, absoluteColor, tag, toolTip, textColor) {
                    this.InitializeWithValidation(text, sizeMetric, absoluteColor);

                    this.m_oTag = tag;
                    this.m_sToolTip = toolTip;
                    this.m_oTextColor = textColor;

                    this.AssertValid();
                }
                Object.defineProperty(Node.prototype, "Text", {
                    //*************************************************************************
                    //    Property: Text
                    //
                    /// <summary>
                    /// Gets or sets the Node's text.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The text that gets displayed within the Node's rectangle.  Can be null
                    /// or empty.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_sText);
                    },
                    set: function (value) {
                        if (this.m_sText != value) {
                            this.m_sText = value;
                            this.FireRedrawRequired();
                        }

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Node.prototype, "SizeMetric", {
                    //*************************************************************************
                    //    Property: SizeMetric
                    //
                    /// <summary>
                    ///    Gets or sets the metric that determines the size of the Node's
                    ///    rectangle.
                    /// </summary>
                    ///
                    /// <value>
                    /// The metric that determines the size of the Node's rectangle within the
                    ///    parent rectangle.  Must be greater than or equal to zero.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    To compute the rectangle sizes for the nodes in a
                    ///    <see cref="Microsoft.Treemap.Generator.Nodes" />
                    ///    collection, the drawing engine adds up the SizeMetric value for the
                    ///    <see cref="Node" /> objects, adds the <see cref="Microsoft.Research.
                    /// CommunityTechnologies.Treemap.EmptySpace.SizeMetric" /> value from the
                    /// <see cref="EmptySpace" /> object owned by the <see
                    /// cref="Microsoft.Treemap.Generator.Nodes" />
                    ///    collection, and divides the size of the parent rectangle by the
                    /// resulting sum.  This "area per SizeMetric" factor is multiplied by each
                    /// Node's SizeMetric value to obtain the size of the Node's rectangle.
                    ///
                    ///    <para>
                    ///    Thus, the size of the Node's rectangle depends on the following:
                    ///
                    /// <list type="bullet">
                    ///
                    /// <item>
                    /// <description>The Node's SizeMetric value</description>
                    /// </item>
                    ///
                    /// <item>
                    /// <description>The SizeMetric values of the Node's siblings</description>
                    /// </item>
                    ///
                    /// <item>
                    /// <description>The SizeMetric value of the Nodes.EmptySpace object
                    ///    </description>
                    /// </item>
                    ///
                    /// <item>
                    /// <description>The size of the parent rectangle</description>
                    /// </item>
                    ///
                    /// </list>
                    ///
                    ///    </para>
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_fSizeMetric);
                    },
                    set: function (value) {
                        // Validate the parameter.
                        Node.ValidateSizeMetric(value, "Node.SizeMetric");

                        if (this.m_fSizeMetric != value) {
                            this.m_fSizeMetric = value;
                            this.FireRedrawRequired();
                        }

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "AbsoluteColor", {
                    //*************************************************************************
                    //    Property: AbsoluteColor
                    //
                    /// <summary>
                    ///    Gets or sets the fill color of the Node's rectangle when <see
                    /// cref="ITreemapComponent.NodeColorAlgorithm" /> is
                    /// set to <see cref="NodeColorAlgorithm.UseAbsoluteColor" />.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The fill color of the Node's rectangle.
                    /// </value>
                    ///
                    /// <remarks>
                    /// Use this property only when <see
                    /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set to <see
                    /// cref="NodeColorAlgorithm.UseAbsoluteColor" />.  If you set this
                    /// property when <see cref="ITreemapComponent.NodeColorAlgorithm" /> is
                    /// set to <see cref="NodeColorAlgorithm.UseColorMetric" />, the node will
                    /// have an unexpected color.
                    ///
                    /// <para>
                    /// (To conserve memory, the Node's <see cref="ColorMetric" /> and <see
                    /// cref="AbsoluteColor" /> properties are stored in the same internal
                    /// field, meaning that a <see cref="Node" /> can store either a color
                    /// metric or an absolute color, but not both.  See <see
                    /// cref="Microsoft.Treemap.Generator.
                    /// TreemapGenerator.NodeColorAlgorithm" /> for more details.)
                    /// </para>
                    ///
                    /// </remarks>
                    ///
                    ///    <seealso cref="Microsoft.Treemap.Generator.
                    /// TreemapGenerator.NodeColorAlgorithm" />
                    ///
                    ///    <seealso cref="ColorMetric" />.
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oNodeColor);
                    },
                    set: function (value) {
                        if (this.m_oNodeColor != value) {
                            this.m_oNodeColor = value;
                            this.FireRedrawRequired();
                        }

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Node.prototype, "Tag", {
                    //*************************************************************************
                    //    Property: Tag
                    //
                    /// <summary>
                    ///    Gets or sets the arbitrary object associated with the Node.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The arbitrary object associated with the Node, as an
                    ///    <see cref="Object" />.  The default value is null.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    This property exists only for the caller's convenience.  It is not used
                    ///    by the treemap components.
                    ///
                    /// <para>
                    /// By default, this property is serialized as a String in the XML returned
                    /// by <see cref="ITreemapComponent.NodesXml" />.  See <see
                    /// cref="ITreemapComponent.NodesXml" /> for more details.
                    /// </para>
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oTag);
                    },
                    set: function (value) {
                        this.m_oTag = value;

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Node.prototype, "ToolTip", {
                    //*************************************************************************
                    //    Property: ToolTip
                    //
                    /// <summary>
                    ///    Gets or sets the Node's tooltip.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The tooltip to display for the Node.  Use "\n" or "\r\n" to separate
                    /// multiple lines.  Can be null.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    The tooltip is used by the TreemapControl.  It is not used by the <see
                    /// cref="TreemapGenerator" />.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_sToolTip);
                    },
                    set: function (value) {
                        this.m_sToolTip = value;

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Node.prototype, "Bounds", {
                    //*************************************************************************
                    //    Property: Bounds
                    //
                    /// <summary>
                    ///    Gets the node's rectangle.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The rectangle the node is drawn within.
                    /// </value>
                    ///
                    /// <remarks>
                    /// If the treemap hasn't been drawn yet or the the node's rectangle is too
                    /// small to draw, Rectangle.<see cref="System.Drawing.Rectangle.Empty" />
                    /// is returned.
                    /// </remarks>
                    //
                    //  This is a public version of RectangleToDraw.  The details of Rectangle
                    //  vs. RectangleToDraw are too complicated to make public.
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        if (!this.m_bRectangleSet) {
                            return (System.Drawing.Rectangle.Empty);
                        }

                        return (this.RectangleToDraw);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "Nodes", {
                    //*************************************************************************
                    //    Property: Nodes
                    //
                    /// <summary>
                    ///    Gets the collection of child <see cref="Node" /> objects.
                    /// </summary>
                    ///
                    /// <value>
                    ///    A <see cref="Microsoft.Treemap.Generator.Nodes" />
                    ///    collection of child <see cref="Node" /> objects.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oNodes);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "Parent", {
                    //*************************************************************************
                    //    Property: Parent
                    //
                    /// <summary>
                    ///    Gets the parent <see cref="Node" /> object.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The parent <see cref="Node" /> object, or null if this Node belongs to
                    /// the top-level <see cref="Nodes" /> collection or the Node hasn't been
                    /// added to a collection.
                    /// </value>
                    //
                    //  This is called Parent instead of ParentNode to make it consistent with
                    //  the .NET TreeNode.Parent property.
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oParentNode);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "Level", {
                    //*************************************************************************
                    //    Property: Level
                    //
                    /// <summary>
                    ///    Gets the Node's level.
                    /// </summary>
                    ///
                    /// <value>
                    ///    The Node's level.  Top-level nodes are at level 0.
                    /// </value>
                    ///
                    /// <remarks>
                    /// 0 is returned if the Node hasn't been added to a collection.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        var oParentNode = this.Parent;
                        var iLevel = 0;

                        while (oParentNode != null) {
                            oParentNode = oParentNode.Parent;
                            iLevel++;
                        }

                        return (iLevel);
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //    Method: PrivateSetParent()
                //
                /// <summary>
                ///    Do not call this method.
                /// </summary>
                ///
                /// <param name="oParentNode">
                ///    Do not call this method.  It is for use only by other treemap
                ///    components.
                /// </param>
                //*************************************************************************
                Node.prototype.PrivateSetParent = function (oParentNode) {
                    // This gets called by TreemapControl.
                    this.SetParent(oParentNode);

                    this.AssertValid();
                };

                Object.defineProperty(Node.prototype, "HasBeenDrawn", {
                    //*************************************************************************
                    //    Property: HasBeenDrawn
                    //
                    /// <summary>
                    /// Gets a flag indicating whether the rectangle has been drawn.
                    /// </summary>
                    ///
                    /// <value>
                    /// true if the rectangle has been drawn.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        // The TreemapGenerator sets the node's rectangle right before
                        // drawing it.  If the rectangle is empty, it means that either the
                        // TreemapGenerator hasn't drawn the treemap yet, or it has but
                        // this node has a rectangle that's too small to draw.
                        if (this.m_oRectangle && !this.m_oRectangle.IsEmpty) {
                            Diag.Debug.Assert(this.m_bRectangleSet);

                            return (true);
                        }

                        return (false);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "Rectangle", {
                    //*************************************************************************
                    //    Property: Rectangle
                    //
                    /// <summary>
                    /// Gets or sets the node's rectangle.
                    /// </summary>
                    ///
                    /// <value>
                    /// The node's rectangle.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    This property provides the floating-point rectangle that should be
                    ///    used in all rectangle calculations.  To draw the rectangle, use the
                    ///    RectangleToDraw property instead.
                    ///
                    /// <para>
                    ///    Do not get this property without setting it first.
                    /// </para>
                    ///
                    ///    <seealso cref="Node.RectangleToDraw" />
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        // No one should ask for the rectangle if it hasn't been set yet.
                        Diag.Debug.Assert(this.m_bRectangleSet);

                        return (this.m_oRectangle);
                    },
                    set: function (value) {
                        this.m_oRectangle = value;

                        this.m_bRectangleSet = true; // !value.IsEmpty;

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Node.prototype, "RectangleToDraw", {
                    //*************************************************************************
                    //    Property: RectangleToDraw
                    //
                    /// <summary>
                    /// Gets the integer rectangle to draw.  Read-only.
                    /// </summary>
                    ///
                    /// <value>
                    /// The integer rectangle to draw.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    This property provides the integer rectangle that should be used for
                    ///    drawing the node's rectangle.  All rectangle calculations should use
                    ///    the floating-point Rectangle property instead.
                    ///
                    /// <para>
                    ///    Do not get this property without setting Rectangle first.
                    /// </para>
                    ///
                    ///    <seealso cref="Node.Rectangle" />
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        // Convert to an integer Rectangle and compensate for some GDI
                        // oddities in the process.
                        return (Microsoft.Treemap.GraphicsLib.GraphicsUtil.RectangleFToRectangle(this.Rectangle, this.PenWidthPx));
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "AspectRatio", {
                    //*************************************************************************
                    //    Property: AspectRatio
                    //
                    /// <summary>
                    /// Gets the aspect ratio of the node's rectangle.  Read-only.
                    /// </summary>
                    ///
                    /// <value>
                    /// Aspect ratio of the node's rectangle.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    The aspect ratio is the ratio of the rectangle's longer side to its
                    ///    shorter side.  Do not get this property without setting
                    ///    Node.Rectangle first.  If the shorter side has a length of zero,
                    ///    Double.MaxValue is returned.
                    ///
                    ///    <seealso cref="Node.Rectangle" />
                    ///
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        Diag.Debug.Assert(this.m_bRectangleSet);

                        var fWidth = this.m_oRectangle.Width;
                        var fHeight = this.m_oRectangle.Height;

                        if (fWidth > fHeight) {
                            if (fHeight == 0)
                                return MAX_VALUE;

                            return (fWidth / fHeight);
                        }

                        if (fWidth == 0)
                            return MAX_VALUE;

                        return (fHeight / fWidth);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Node.prototype, "PenWidthPx", {
                    //*************************************************************************
                    //    Property: PenWidthPx
                    //
                    /// <summary>
                    /// Gets or sets the width of the pen used to draw the node's rectangle, in
                    /// pixels.
                    /// </summary>
                    ///
                    /// <value>
                    /// Width of the pen used to draw the node's rectangle, in pixels.
                    /// </value>
                    ///
                    /// <remarks>
                    ///    Do not get this property without setting it first.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        // No one should ask for the pen width if it hasn't been set yet.
                        Diag.Debug.Assert(this.m_iPenWidthPx != -1);

                        return this.m_iPenWidthPx;
                    },
                    set: function (value) {
                        this.m_iPenWidthPx = value;

                        this.AssertValid();
                    },
                    enumerable: true,
                    configurable: true
                });


                //*************************************************************************
                //    Method: InitializeWithValidation()
                //
                /// <summary>
                ///    Validates the arguments and initializes the object.
                /// </summary>
                ///
                /// <param name="sText">
                /// Text to display within the node's rectangle.
                /// </param>
                ///
                /// <param name="fSizeMetric">
                /// Determines the size of the node's rectangle.
                /// </param>
                ///
                /// <param name="fColorMetric">
                /// Determines the fill color of the node's rectangle.
                /// </param>
                ///
                /// <remarks>
                ///    This is used by several constructors.
                /// </remarks>
                //*************************************************************************
                Node.prototype.InitializeWithValidation = function (sText, fSizeMetric, color) {
                    // Validate the parameters.
                    var sMethodName = "Node";
                    Node.ValidateSizeMetric(fSizeMetric, sMethodName);

                    this.m_oTreemapGenerator = null;
                    this.m_oParentNode = null;
                    this.m_sText = sText;
                    this.m_fSizeMetric = fSizeMetric;
                    this.m_oNodeColor = color;
                    this.m_oTag = null;
                    this.m_sToolTip = null;
                    this.m_oNodes = new Microsoft.Treemap.Generator.Nodes(this);

                    // m_oRectangle
                    // m_oSavedRectangle
                    this.m_iPenWidthPx = -1;

                    this.m_bRectangleSet = false;
                    this.m_bRectangleSaved = false;

                    this.m_oShape = null;
                    this.m_oText = null;
                };

                //*************************************************************************
                //    Method: SetParent()
                //
                /// <summary>
                ///    Sets the parent node.
                /// </summary>
                ///
                /// <param name="oParentNode">
                ///    The parent <see cref="Node" /> object, or null if this node belongs to
                /// the top-level <see cref="Nodes" /> collection or the node hasn't been
                /// added to a collection.
                /// </param>
                //*************************************************************************
                Node.prototype.SetParent = function (oParentNode) {
                    Diag.Debug.Assert(oParentNode != this);

                    this.m_oParentNode = oParentNode;

                    this.AssertValid();
                };

                Object.defineProperty(Node.prototype, "TreemapGenerator", {
                    //*************************************************************************
                    //  Property: TreemapGenerator
                    //
                    /// <summary>
                    /// Sets the object that owns this object.
                    /// </summary>
                    ///
                    /// <value>
                    /// The TreemapGenerator object that owns this object.
                    /// </value>
                    ///
                    /// <remarks>
                    /// This method must be called after this node object is added to the
                    /// TreemapGenerator.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        return this.m_oTreemapGenerator;
                    },
                    set: function (value) {
                        this.m_oTreemapGenerator = value;
                    },
                    enumerable: true,
                    configurable: true
                });


                //*************************************************************************
                //    Method: GetNodeFromPoint()
                //
                /// <summary>
                ///    Looks for the innermost node whose rectangle contains the specified
                ///    point.
                /// </summary>
                ///
                /// <param name="oPointF">
                /// Point to get a Node object for.
                /// </param>
                ///
                /// <param name="oNode">
                /// Where the Node object gets stored.
                /// </param>
                ///
                /// <returns>
                ///    true if a Node object was found, false if not.
                /// </returns>
                ///
                /// <remarks>
                ///    If found, the Node object is stored in oNode and true is returned.
                /// false is returned otherwise.
                ///
                /// <para>
                /// Do not call this if <see cref="Rectangle" /> has not been set.
                /// </para>
                ///
                /// </remarks>
                //*************************************************************************
                Node.prototype.GetNodeFromPoint = function (oPointF) {
                    var oNode;

                    this.AssertValid();

                    if (this.m_oRectangle && this.m_oRectangle.ContainsPoint(oPointF)) {
                        // This node's rectangle contains the point.  Is the point
                        // also contained within a descendent?
                        oNode = this.m_oNodes.GetNodeFromPoint(oPointF);
                        if (oNode == null) {
                            // No.  Return this node.
                            oNode = this;
                        }

                        return oNode;
                    }

                    // No node contains the point.
                    return null;
                };

                //*************************************************************************
                //    Method: ValidateSizeMetric()
                //
                /// <summary>
                ///    Throws an exception if iValue is not a valid SizeMetric value.
                /// </summary>
                ///
                /// <param name="fValue">
                /// Value to validate.
                /// </param>
                ///
                /// <param name="sCaller">
                /// Name of the caller, used in exception messages.  Sample: "Nodes.Add".
                /// </param>
                //*************************************************************************
                Node.ValidateSizeMetric = function (fValue, sCaller) {
                    if (fValue < 0) {
                        throw new System.ArgumentOutOfRangeException(sCaller, fValue, sCaller + ": SizeMetric must be >= 0.");
                    }
                    // TODO: Is there an upper limit?
                };

                //*************************************************************************
                //    Method: SaveRectangle()
                //
                /// <summary>
                ///    Saves the Rectangle property in an internal variable.
                /// </summary>
                ///
                /// <remarks>
                ///    The saved value can be restored by calling <see
                /// cref="RestoreRectangle" />.  These methods are provided as helpers for
                /// ILayoutEngine objects.
                /// </remarks>
                ///
                /// <seealso cref="Node.RestoreRectangle" />
                //*************************************************************************
                Node.prototype.SaveRectangle = function () {
                    this.m_oSavedRectangle = this.m_oRectangle;

                    this.m_bRectangleSaved = true;

                    this.AssertValid();
                };

                //*************************************************************************
                //    Method: RestoreRectangle()
                //
                /// <summary>
                ///    Restores the Rectangle property saved by <see cref="SaveRectangle" />.
                /// </summary>
                ///
                /// <remarks>
                ///    There can be only one <see cref="RestoreRectangle" /> call for each
                /// <see cref="SaveRectangle" /> call.
                /// </remarks>
                ///
                /// <seealso cref="Node.SaveRectangle" />
                //*************************************************************************
                Node.prototype.RestoreRectangle = function () {
                    Diag.Debug.Assert(this.m_bRectangleSaved);

                    this.m_oRectangle = this.m_oSavedRectangle;

                    this.m_bRectangleSaved = false;

                    this.AssertValid();
                };

                //*************************************************************************
                //    Method: FireRedrawRequired()
                //
                /// <summary>
                ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                /// </summary>
                ///
                /// <remarks>
                /// This should be called when something occurs that affects the treemap's
                /// appearance.
                /// </remarks>
                //*************************************************************************
                Node.prototype.FireRedrawRequired = function () {
                    this.AssertValid();

                    // This is done by communicating directly with the TreemapGenerator.
                    // It could also be done via an event that gets handled by the
                    // TreemapGenerator, but given the potentially large number of nodes,
                    // that would be inefficient.
                    if (this.m_oTreemapGenerator != null)
                        this.m_oTreemapGenerator.FireRedrawRequired();
                };

                // draws rectangle for this node based on size already set and pen/brush passed in
                Node.prototype.DisplayRectangle = function (displayRoot, iWidthPx, oPenColor, oBrush, iNodeLevel, fAnimDuration) {
                    Diag.Debug.Assert(this.m_bRectangleSet);

                    var oRect = this.RectangleToDraw;

                    // make sure pen width doesn't exceed width or height of rectangle.
                    var widthPen = iWidthPx;
                    if (widthPen * 2 > oRect.Width)
                        widthPen = oRect.Width / 2;
                    if (widthPen * 2 > oRect.Height)
                        widthPen = oRect.Height / 2;

                    // accomodate for border width -- which is drawn outside of the content box
                    oRect.Width -= widthPen * 2;
                    oRect.Height -= widthPen * 2;

                    if (this.m_oShape == null) {
                        this.m_oShape = displayRoot.append("div").css("position", "absolute").bounds(0, 0, oRect.Width, oRect.Height);
                    }

                    this.m_oShape.animate(0); // turn off animation in case one is in progress; colors can't be animated

                    this.m_oShape.css("backgroundColor", this.AbsoluteColor.ToHTML).css("borderColor", oPenColor.ToHTML).css("borderWidth", widthPen + "px").css("borderStyle", "solid").opacity(this.AbsoluteColor.A / 255).css("zIndex", (iNodeLevel * 2).toString());

                    // TODO: oBrush.Color / Linear gradient
                    // TODO: add option do enable/disable animation
                    this.m_oShape.animate(fAnimDuration).bounds(oRect.X, oRect.Y, oRect.Width, oRect.Height);

                    var tooltip = this.tooltip;
                    this.m_oShape.attr("title", tooltip);
                };

                Node.prototype.SetToolTip = function (str) {
                    this.tooltip = str;

                    if (this.m_oShape) {
                        this.m_oShape.attr("title", str);
                    }
                };

                Node.prototype.SetRectangleFill = function (fill) {
                    if (this.m_oShape) {
                        this.m_oShape.css("backgroundColor", fill.ToHTML).opacity(fill.A / 255);
                    }
                };

                Node.prototype.RemoveRectangle = function () {
                    if (this.m_oShape) {
                        this.m_oShape.remove();
                        this.m_oShape = null;
                    }
                };

                // default mechanism for text display per node
                Node.prototype.DisplayText = function (displayRoot, oRect, oFont, oBrush, oStringFormat, iNodeLevel, fAnimDuration) {
                    if (this.m_oText == null) {
                        this.m_oText = displayRoot.append("div").css("position", "absolute").bounds(0, 0, oRect.Width, oRect.Height);
                    }

                    this.m_oText.animate(0); // turn off animation in case one is in progress; colors can't be animated
                    var tt = this.m_oText.text(this.m_sText).css("fontFamily", oFont.Name).css("fontSize", oFont.Size + "pt").css("textAlign", oStringFormat.ToCSSAlignment).css("verticalAlign", oStringFormat.ToCSSLineAlign).css("overflow", "hidden").css("cursor", "default").css("z-index", (iNodeLevel * 2 + 1).toString());

                    if (oBrush) {
                        tt.css("color", oBrush.ToHTML);
                    }

                    this.m_oText.animate(fAnimDuration).bounds(oRect.X, oRect.Y, oRect.Width, oRect.Height);

                    var tooltip = this.tooltip;
                    this.m_oText.attr("title", tooltip);
                };

                Node.prototype.SetTextColor = function (color) {
                    //if (this.m_oText)
                    //{
                    //    this.m_oText.css("color", color.ToHTML);
                    //}
                    this.m_oTextColor = color;
                };

                Node.prototype.RemoveText = function () {
                    if (this.m_oText) {
                        this.m_oText.remove();
                        this.m_oText = null;
                    }
                };

                Object.defineProperty(Node.prototype, "DisplayedElement", {
                    // for owner drawn elements, gets the last displayed element;
                    // the default text drawing and the owner drawn content are never used at the same time
                    get: function () {
                        return this.m_dispelem;
                    },
                    set: function (value) {
                        this.m_dispelem = value;
                    },
                    enumerable: true,
                    configurable: true
                });


                //*************************************************************************
                //    Method: AssertValid()
                //
                /// <summary>
                ///    Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                Node.prototype.AssertValid = function () {
                    // m_oTreemapGenerator
                    // m_oParentNode
                    // m_sText
                    Diag.Debug.Assert(this.m_fSizeMetric >= 0);

                    // m_oNodeColor
                    // m_oTag
                    // m_sToolTip
                    Diag.Debug.Assert(this.m_oNodes != null);
                    this.m_oNodes.AssertValid();

                    // m_oRectangle
                    // m_oSavedRectangle
                    Diag.Debug.Assert(this.m_iPenWidthPx == -1 || this.m_iPenWidthPx >= 0);

                    // m_bRectangleSet
                    // m_bRectangleSaved
                    // if rectangle is empty, cannot have a shape/text
                    if (this.m_oRectangle && this.m_oRectangle.IsEmpty) {
                        Diag.Debug.Assert(this.m_oShape == null);
                        Diag.Debug.Assert(this.m_oText == null);
                    }
                };
                return Node;
            })();
            Generator.Node = Node;
        })(Treemap.Generator || (Treemap.Generator = {}));
        var Generator = Treemap.Generator;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
///<reference path="../scripts/allfiles.ts" />
var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (Generator) {
            var Diag = System.Diagnostics;

            //*****************************************************************************
            //    Class: Nodes
            //
            /// <summary>
            /// Collection of <see cref="Node" /> objects.
            /// </summary>
            ///
            /// <remarks>
            /// The <see cref="ITreemapComponent.Nodes" /> property on <see
            /// cref="ITreemapComponent" /> returns a Nodes collection containing the
            /// top-level <see cref="Node" /> objects.  Also, each <see cref="Node" />
            /// object has a <see cref="Node.Nodes" /> property that returns a Nodes
            ///    collection containing the node's child <see cref="Node" /> objects.  A leaf
            /// <see cref="Node" /> object has an empty Nodes collection.
            /// </remarks>
            ///
            ///    <seealso cref="Node" />
            ///    <seealso cref="ITreemapComponent.Nodes" />
            ///
            //  Internally, Nodes uses an ArrayList object to store the Node objects.  It
            //  does not inherit from ArrayList, because that would expose too much
            //     functionality to the user.
            //
            //*****************************************************************************
            var Nodes = (function () {
                //*************************************************************************
                //    Constructor: Nodes()
                //
                /// <summary>
                /// Initializes a new instance of the Node class.
                /// </summary>
                ///
                /// <param name="oParentNode">
                /// Node that this collection belongs to, or null if this is the top-level
                /// nodes collection.
                /// </param>
                //*************************************************************************
                function Nodes(oParentNode) {
                    this.Initialize(oParentNode);
                }
                Object.defineProperty(Nodes.prototype, "Count", {
                    //*************************************************************************
                    //    Property: Count
                    //
                    /// <summary>
                    ///    Gets the number of objects in the collection.
                    /// </summary>
                    ///
                    ///    <value>
                    ///    The number of <see cref="Node" /> objects in the <see cref="Nodes" />
                    ///    collection.
                    ///    </value>
                    ///
                    ///    <remarks>
                    ///    Use <see cref="RecursiveCount" /> to get a recursive count.
                    ///    </remarks>
                    ///
                    /// <seealso cref="RecursiveCount"/>
                    /// <seealso cref="Node "/>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oNodes.length);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Nodes.prototype, "RecursiveCount", {
                    //*************************************************************************
                    //    Property: RecursiveCount
                    //
                    /// <summary>
                    /// Gets the number of objects in the collection, including all descendant
                    ///    objects.
                    /// </summary>
                    ///
                    ///    <value>
                    /// The number of <see cref="Node" /> objects in the <see cref="Nodes" />
                    ///    collection, including all descendant <see cref="Node" /> objects.
                    ///    </value>
                    ///
                    ///    <remarks>
                    ///    Use <see cref="Count" /> to get a non-recursive count.
                    ///    </remarks>
                    ///
                    /// <seealso cref="Count"/>
                    /// <seealso cref="Node" />
                    //*************************************************************************
                    get: function () {
                        var iRecursiveCount = 0;

                        for (var iNode = 0; iNode < this.Count; iNode++) {
                            var oNode = this.Item(iNode);

                            iRecursiveCount += 1 + oNode.Nodes.RecursiveCount;
                        }

                        return (iRecursiveCount);
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //    Property: Indexer
                //
                /// <summary>
                ///    Gets the object at the specified index.
                /// </summary>
                ///
                /// <value>
                ///    The <see cref="Node" /> object at the specified index.
                /// </value>
                ///
                /// <param name="zeroBasedIndex">
                /// Zero-based index of the <see cref="Node" /> to get.
                /// </param>
                ///
                /// <example>
                /// Node oFirstTopLevelNode = oTreemapGenerator.Nodes[0];
                /// </example>
                //*************************************************************************
                Nodes.prototype.Item = function (zeroBasedIndex) {
                    this.AssertValid();

                    var iCount = this.m_oNodes.length;

                    if (iCount == 0) {
                        throw new System.InvalidOperationException("Nodes[]: There are no" + " nodes in the collection.");
                    }

                    if (zeroBasedIndex < 0 || zeroBasedIndex >= iCount) {
                        throw new System.ArgumentOutOfRangeException("zeroBasedIndex", zeroBasedIndex, "Nodes[]: zeroBasedIndex must be" + " between 0 and Nodes.Count-1.");
                    }

                    return this.m_oNodes[zeroBasedIndex];
                };

                Object.defineProperty(Nodes.prototype, "EmptySpace", {
                    //*************************************************************************
                    //    Property: EmptySpace
                    //
                    /// <summary>
                    ///    Gets the object that represents empty space in the parent rectangle.
                    /// </summary>
                    ///
                    /// <value>
                    ///    An <see
                    /// cref="Microsoft.Treemap.Generator.EmptySpace" />
                    ///    object that represents empty space in the parent rectangle.
                    /// </value>
                    ///
                    /// <remarks>
                    /// You can force empty space to appear in a node's rectangle by setting
                    /// the Node.Nodes.EmptySpace.<see
                    /// cref="Microsoft.Treemap.Generator.EmptySpace.
                    /// SizeMetric" /> property to a positive value.  The location of the empty
                    /// space is determined by the <see
                    /// cref="ITreemapComponent.EmptySpaceLocation" /> property.
                    ///
                    /// <para>
                    ///    See <see cref="Node.SizeMetric" /> for details on how the size of each
                    /// node rectangle is computed and how EmptySpace is involved in the
                    ///    computations.
                    /// </para>
                    ///
                    /// </remarks>
                    ///
                    /// <seealso
                    ///    cref="Microsoft.Treemap.Generator.EmptySpace" />
                    ///    <seealso cref="Node.SizeMetric" />
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oEmptySpace);
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //    Method: Add()
                //
                /// <summary>
                /// Creates a <see cref="Node" /> object with the specified text, size
                /// metric, and absolute color, and adds it to the end of a <see
                /// cref="Nodes" /> collection.
                /// </summary>
                ///
                /// <param name="text">
                /// Text to display within the node's rectangle.
                /// </param>
                ///
                /// <param name="sizeMetric">
                /// Determines the size of the node's rectangle.  See
                ///    <see cref="Node.SizeMetric" />.
                /// </param>
                ///
                /// <param name="absoluteColor">
                /// Determines the fill color of the node's rectangle.  See
                /// <see cref="Node.AbsoluteColor" />.
                /// </param>
                ///
                /// <returns>
                ///    The new <see cref="Node" /> object.
                /// </returns>
                ///
                /// <remarks>
                /// Use this method when <see
                /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set to <see
                /// cref="NodeColorAlgorithm.UseAbsoluteColor" />.
                /// </remarks>
                ///
                ///    <seealso cref="Node" />
                //*************************************************************************
                Nodes.prototype.Add1 = function (text, sizeMetric, absoluteColor, tag, toolTip, textColor) {
                    return this.Add(new Microsoft.Treemap.Generator.Node(text, sizeMetric, absoluteColor, tag, toolTip, textColor));
                };

                //*************************************************************************
                //    Method: Add()
                //
                /// <summary>
                /// Adds an existing <see cref="Node" /> object to the end of a
                ///    <see cref="Nodes" /> collection.
                /// </summary>
                ///
                /// <param name="node">
                /// <see cref="Node" /> object to add.
                /// </param>
                ///
                /// <returns>
                ///    The <paramref name="node" /> object.
                /// </returns>
                ///
                /// <remarks>
                ///    Do not add the same <see cref="Node" /> object to the node hierarchy
                /// more than once.
                /// </remarks>
                ///
                ///    <seealso cref="Node" />
                //*************************************************************************
                Nodes.prototype.Add = function (oNode) {
                    // Add it to the collection.
                    this.m_oNodes.push(oNode);

                    // Set its parent node.
                    oNode.SetParent(this.m_oParentNode);

                    // Set its owner if possible.
                    if (this.m_oTreemapGenerator != null)
                        oNode.TreemapGenerator = this.m_oTreemapGenerator;

                    // Fire a RedrawRequired event.
                    this.FireRedrawRequired();

                    this.AssertValid();

                    return oNode;
                };

                //*************************************************************************
                //    Method: ToArray()
                //
                /// <summary>
                /// Returns an array of the <see cref="Node" /> objects in the collection.
                /// </summary>
                ///
                /// <returns>
                ///    Array of references to the <see cref="Node" /> objects in the
                ///    collection.  (The objects in the collection are not copied.)  If the
                ///    collection is empty, an empty array is returned.
                /// </returns>
                //*************************************************************************
                Nodes.prototype.ToArray = function () {
                    return this.m_oNodes;
                };

                Object.defineProperty(Nodes.prototype, "TreemapGenerator", {
                    //*************************************************************************
                    //  Property: TreemapGenerator
                    //
                    /// <summary>
                    /// Sets the object that owns this object.
                    /// </summary>
                    ///
                    /// <value>
                    /// The TreemapGenerator object that owns this object.
                    /// </value>
                    ///
                    /// <remarks>
                    /// This method must be called after this node object is added to the
                    /// TreemapGenerator.
                    /// </remarks>
                    //*************************************************************************
                    get: function () {
                        return this.m_oTreemapGenerator;
                    },
                    set: function (value) {
                        this.m_oTreemapGenerator = value;
                    },
                    enumerable: true,
                    configurable: true
                });


                //*************************************************************************
                //    Method: Initialize()
                //
                /// <summary>
                /// Initializes the object.
                /// </summary>
                ///
                /// <param name="oParentNode">
                /// Node that this collection belongs to, or null if this is the top-level
                /// nodes collection.
                /// </param>
                //*************************************************************************
                Nodes.prototype.Initialize = function (oParentNode) {
                    this.m_oTreemapGenerator = null;
                    this.m_oParentNode = oParentNode;
                    this.m_oNodes = new Array();
                    this.m_oEmptySpace = new Microsoft.Treemap.Generator.EmptySpace();
                };

                //*************************************************************************
                //    Method: Clear()
                //
                /// <summary>
                ///    Removes all nodes from the collection and sets the SizeMetric property
                /// on <see cref="EmptySpace" /> to zero.
                /// </summary>
                //*************************************************************************
                Nodes.prototype.Clear = function () {
                    this.AssertValid();

                    this.m_oNodes.length = 0;
                    this.m_oEmptySpace = new Microsoft.Treemap.Generator.EmptySpace();
                };

                //*************************************************************************
                //    Method: GetNodeFromPoint()
                //
                /// <summary>
                /// GetNodeFromPoint method.
                /// </summary>
                ///
                /// <param name="oPointF">
                /// PointF.  Point to get a Node object for.
                /// </param>
                ///
                /// <param name="oNode">
                /// Node.  Where the Node object gets stored.  null is stored if a Node
                /// object was not found.
                /// </param>
                ///
                /// <returns>
                ///    Boolean.  true if a Node object was found, false if not.
                /// </returns>
                ///
                /// <remarks>
                ///    Looks for the innermost node whose rectangle contains the specified
                ///    point.  If found, the Node object is stored in oNode and true is
                ///    returned.  false is returned otherwise.
                /// </remarks>
                //*************************************************************************
                Nodes.prototype.GetNodeFromPoint = function (oPointF) {
                    var oNode;

                    for (var iChildNode = 0; iChildNode < this.m_oNodes.length; iChildNode++) {
                        var oChildNode = this.m_oNodes[iChildNode];

                        oNode = oChildNode.GetNodeFromPoint(oPointF);
                        if (oNode)
                            return oNode;
                    }

                    // No node contains the point.
                    return null;
                };

                //*************************************************************************
                //    Method: ToArraySortedBySizeMetric()
                //
                /// <summary>
                /// ToArraySortedBySizeMetric() method.
                /// </summary>
                ///
                ///    <remarks>
                ///    Returns an array of Node objects sorted by Node.SizeMetric.
                ///    </remarks>
                ///
                /// <returns>
                ///    Array of Node objects sorted by Node.SizeMetric in descending order.
                ///    If this Nodes collection is empty, an empty array is returned.
                /// </returns>
                //*************************************************************************
                Nodes.prototype.ToArraySortedBySizeMetric = function () {
                    // Create an array and copy the Node objects from this collection to
                    // the array.
                    var aoNodes = this.m_oNodes.slice(0);

                    // Sort the array.  The Sort() method will call Node.CompareTo(),
                    // which sorts by Node.SizeMetric.
                    aoNodes.sort(function (a, b) {
                        return b.SizeMetric - a.SizeMetric;
                    });

                    return (aoNodes);
                };

                //*************************************************************************
                //    Method: FireRedrawRequired()
                //
                /// <summary>
                ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                /// </summary>
                ///
                /// <remarks>
                /// This should be called when something occurs that affects the treemap's
                /// appearance.
                /// </remarks>
                //*************************************************************************
                Nodes.prototype.FireRedrawRequired = function () {
                    // This is done by communicating directly with the TreemapGenerator.
                    // It could also be done via an event that gets handled by the
                    // TreemapGenerator, but given the potentially large number of nodes,
                    // that would be inefficient.
                    if (this.m_oTreemapGenerator != null)
                        this.m_oTreemapGenerator.FireRedrawRequired();
                };

                //*************************************************************************
                //    Method: AssertValid()
                //
                /// <summary>
                ///    Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                Nodes.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_oNodes != null);
                    Diag.Debug.Assert(this.m_oEmptySpace != null);
                    this.m_oEmptySpace.AssertValid();
                };
                return Nodes;
            })();
            Generator.Nodes = Nodes;
        })(Treemap.Generator || (Treemap.Generator = {}));
        var Generator = Treemap.Generator;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
///<reference path="../scripts/allfiles.ts" />
var System;
(function (System) {
    (function (Drawing) {
        var Diag = System.Diagnostics;

        //export class Brush
        //{
        //}
        //export class SolidBrush extends Brush
        //{
        //    constructor (color: Color)
        //    {
        //        super();
        //        this.m_color = color;
        //    }
        //    m_color: Color;
        //    get Color(): System.Drawing.Color
        //    {
        //        return this.m_color;
        //    }
        //    set Color(value: System.Drawing.Color)
        //    {
        //        this.m_color = value;
        //    }
        //}
        //export class Brushes
        //{
        //    static get AliceBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.AliceBlue);
        //    }
        //    static get AntiqueWhite(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.AntiqueWhite);
        //    }
        //    static get Aqua(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Aqua);
        //    }
        //    static get Aquamarine(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Aquamarine);
        //    }
        //    static get Azure(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Azure);
        //    }
        //    static get Beige(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Beige);
        //    }
        //    static get Bisque(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Bisque);
        //    }
        //    static get Black(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Black);
        //    }
        //    static get BlanchedAlmond(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.BlanchedAlmond);
        //    }
        //    static get Blue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Blue);
        //    }
        //    static get BlueViolet(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.BlueViolet);
        //    }
        //    static get Brown(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Brown);
        //    }
        //    static get BurlyWood(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.BurlyWood);
        //    }
        //    static get CadetBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.CadetBlue);
        //    }
        //    static get Chartreuse(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Chartreuse);
        //    }
        //    static get Chocolate(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Chocolate);
        //    }
        //    static get Coral(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Coral);
        //    }
        //    static get CornflowerBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.CornflowerBlue);
        //    }
        //    static get Cornsilk(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Cornsilk);
        //    }
        //    static get Crimson(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Crimson);
        //    }
        //    static get Cyan(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Cyan);
        //    }
        //    static get DarkBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkBlue);
        //    }
        //    static get DarkCyan(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkCyan);
        //    }
        //    static get DarkGoldenrod(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkGoldenrod);
        //    }
        //    static get DarkGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkGray);
        //    }
        //    static get DarkGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkGreen);
        //    }
        //    static get DarkKhaki(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkKhaki);
        //    }
        //    static get DarkMagenta(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkMagenta);
        //    }
        //    static get DarkOliveGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkOliveGreen);
        //    }
        //    static get DarkOrange(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkOrange);
        //    }
        //    static get DarkOrchid(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkOrchid);
        //    }
        //    static get DarkRed(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkRed);
        //    }
        //    static get DarkSalmon(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkSalmon);
        //    }
        //    static get DarkSeaGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkSeaGreen);
        //    }
        //    static get DarkSlateBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkSlateBlue);
        //    }
        //    static get DarkSlateGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkSlateGray);
        //    }
        //    static get DarkTurquoise(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkTurquoise);
        //    }
        //    static get DarkViolet(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DarkViolet);
        //    }
        //    static get DeepPink(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DeepPink);
        //    }
        //    static get DeepSkyBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DeepSkyBlue);
        //    }
        //    static get DimGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DimGray);
        //    }
        //    static get DodgerBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.DodgerBlue);
        //    }
        //    static get FireBrick(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.FireBrick);
        //    }
        //    static get FloralWhite(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.FloralWhite);
        //    }
        //    static get ForestGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.ForestGreen);
        //    }
        //    static get Fuchsia(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Fuchsia);
        //    }
        //    static get Gainsboro(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Gainsboro);
        //    }
        //    static get GhostWhite(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.GhostWhite);
        //    }
        //    static get Gold(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Gold);
        //    }
        //    static get Goldenrod(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Goldenrod);
        //    }
        //    static get Gray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Gray);
        //    }
        //    static get Green(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Green);
        //    }
        //    static get GreenYellow(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.GreenYellow);
        //    }
        //    static get Honeydew(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Honeydew);
        //    }
        //    static get HotPink(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.HotPink);
        //    }
        //    static get IndianRed(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.IndianRed);
        //    }
        //    static get Indigo(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Indigo);
        //    }
        //    static get Ivory(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Ivory);
        //    }
        //    static get Khaki(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Khaki);
        //    }
        //    static get Lavender(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Lavender);
        //    }
        //    static get LavenderBlush(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LavenderBlush);
        //    }
        //    static get LawnGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LawnGreen);
        //    }
        //    static get LemonChiffon(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LemonChiffon);
        //    }
        //    static get LightBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightBlue);
        //    }
        //    static get LightCoral(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightCoral);
        //    }
        //    static get LightCyan(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightCyan);
        //    }
        //    static get LightGoldenrodYellow(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightGoldenrodYellow);
        //    }
        //    static get LightGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightGreen);
        //    }
        //    static get LightGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightGray);
        //    }
        //    static get LightPink(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightPink);
        //    }
        //    static get LightSalmon(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightSalmon);
        //    }
        //    static get LightSeaGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightSeaGreen);
        //    }
        //    static get LightSkyBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightSkyBlue);
        //    }
        //    static get LightSlateGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightSlateGray);
        //    }
        //    static get LightSteelBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightSteelBlue);
        //    }
        //    static get LightYellow(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LightYellow);
        //    }
        //    static get Lime(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Lime);
        //    }
        //    static get LimeGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.LimeGreen);
        //    }
        //    static get Linen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Linen);
        //    }
        //    static get Magenta(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Magenta);
        //    }
        //    static get Maroon(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Maroon);
        //    }
        //    static get MediumAquamarine(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumAquamarine);
        //    }
        //    static get MediumBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumBlue);
        //    }
        //    static get MediumOrchid(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumOrchid);
        //    }
        //    static get MediumPurple(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumPurple);
        //    }
        //    static get MediumSeaGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumSeaGreen);
        //    }
        //    static get MediumSlateBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumSlateBlue);
        //    }
        //    static get MediumSpringGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumSpringGreen);
        //    }
        //    static get MediumTurquoise(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumTurquoise);
        //    }
        //    static get MediumVioletRed(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MediumVioletRed);
        //    }
        //    static get MidnightBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MidnightBlue);
        //    }
        //    static get MintCream(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MintCream);
        //    }
        //    static get MistyRose(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.MistyRose);
        //    }
        //    static get Moccasin(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Moccasin);
        //    }
        //    static get NavajoWhite(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.NavajoWhite);
        //    }
        //    static get Navy(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Navy);
        //    }
        //    static get OldLace(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.OldLace);
        //    }
        //    static get Olive(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Olive);
        //    }
        //    static get OliveDrab(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.OliveDrab);
        //    }
        //    static get Orange(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Orange);
        //    }
        //    static get OrangeRed(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.OrangeRed);
        //    }
        //    static get Orchid(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Orchid);
        //    }
        //    static get PaleGoldenrod(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PaleGoldenrod);
        //    }
        //    static get PaleGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PaleGreen);
        //    }
        //    static get PaleTurquoise(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PaleTurquoise);
        //    }
        //    static get PaleVioletRed(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PaleVioletRed);
        //    }
        //    static get PapayaWhip(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PapayaWhip);
        //    }
        //    static get PeachPuff(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PeachPuff);
        //    }
        //    static get Peru(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Peru);
        //    }
        //    static get Pink(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Pink);
        //    }
        //    static get Plum(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Plum);
        //    }
        //    static get PowderBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.PowderBlue);
        //    }
        //    static get Purple(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Purple);
        //    }
        //    static get Red(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Red);
        //    }
        //    static get RosyBrown(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.RosyBrown);
        //    }
        //    static get RoyalBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.RoyalBlue);
        //    }
        //    static get SaddleBrown(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SaddleBrown);
        //    }
        //    static get Salmon(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Salmon);
        //    }
        //    static get SandyBrown(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SandyBrown);
        //    }
        //    static get SeaGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SeaGreen);
        //    }
        //    static get Seashell(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Seashell);
        //    }
        //    static get Sienna(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Sienna);
        //    }
        //    static get Silver(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Silver);
        //    }
        //    static get SkyBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SkyBlue);
        //    }
        //    static get SlateBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SlateBlue);
        //    }
        //    static get SlateGray(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SlateGray);
        //    }
        //    static get Snow(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Snow);
        //    }
        //    static get SpringGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SpringGreen);
        //    }
        //    static get SteelBlue(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.SteelBlue);
        //    }
        //    static get Tan(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Tan);
        //    }
        //    static get Teal(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Teal);
        //    }
        //    static get Thistle(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Thistle);
        //    }
        //    static get Tomato(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Tomato);
        //    }
        //    static get Turquoise(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Turquoise);
        //    }
        //    static get Violet(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Violet);
        //    }
        //    static get Wheat(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Wheat);
        //    }
        //    static get White(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.White);
        //    }
        //    static get WhiteSmoke(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.WhiteSmoke);
        //    }
        //    static get Yellow(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.Yellow);
        //    }
        //    static get YellowGreen(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(Color.YellowGreen);
        //    }
        //}
        var Color = (function () {
            function Color(alpha, red, green, blue) {
                this.m_alpha = alpha;
                this.m_red = red;
                this.m_green = green;
                this.m_blue = blue;
            }
            Color.FromArgb1 = function (argb) {
                return new Color((argb & 0xff000000) >> 24, (argb & 0x00ff0000) >> 16, (argb & 0x0000ff00) >> 8, (argb & 0x000000ff));
            };
            Color.FromArgb2 = function (alpha, red, green, blue) {
                return new Color(alpha, red, green, blue);
            };

            Color.FromArgb3 = function (alpha, baseColor) {
                return new Color(alpha, baseColor.m_red, baseColor.m_green, baseColor.m_blue);
            };

            Color.FromArgb4 = function (red, green, blue) {
                return new Color(0xff, red, green, blue);
            };

            Color.prototype.GetBrightness = function () {
                var num = this.m_red / 255;
                var num2 = this.m_green / 255;
                var num3 = this.m_blue / 255;
                var num4 = num;
                var num5 = num;
                if (num2 > num4) {
                    num4 = num2;
                }
                if (num3 > num4) {
                    num4 = num3;
                }
                if (num2 < num5) {
                    num5 = num2;
                }
                if (num3 < num5) {
                    num5 = num3;
                }
                return ((num4 + num5) / 2);
            };

            Color.prototype.GetHue = function () {
                if ((this.m_red == this.m_green) && (this.m_green == this.m_blue)) {
                    return 0;
                }

                var num = this.m_red / 255;
                var num2 = this.m_green / 255;
                var num3 = this.m_blue / 255;
                var num7 = 0;
                var num4 = num;
                var num5 = num;
                if (num2 > num4) {
                    num4 = num2;
                }
                if (num3 > num4) {
                    num4 = num3;
                }
                if (num2 < num5) {
                    num5 = num2;
                }
                if (num3 < num5) {
                    num5 = num3;
                }
                var num6 = num4 - num5;
                if (num == num4) {
                    num7 = (num2 - num3) / num6;
                } else if (num2 == num4) {
                    num7 = 2 + ((num3 - num) / num6);
                } else if (num3 == num4) {
                    num7 = 4 + ((num - num2) / num6);
                }
                num7 *= 60;
                if (num7 < 0) {
                    num7 += 360;
                }
                return num7;
            };

            Color.prototype.GetSaturation = function () {
                var num = this.m_red / 255;
                var num2 = this.m_green / 255;
                var num3 = this.m_blue / 255;
                var num7 = 0;
                var num4 = num;
                var num5 = num;
                if (num2 > num4) {
                    num4 = num2;
                }
                if (num3 > num4) {
                    num4 = num3;
                }
                if (num2 < num5) {
                    num5 = num2;
                }
                if (num3 < num5) {
                    num5 = num3;
                }
                if (num4 == num5) {
                    return num7;
                }
                var num6 = (num4 + num5) / 2;
                if (num6 <= 0.5) {
                    return ((num4 - num5) / (num4 + num5));
                }
                return ((num4 - num5) / ((2 - num4) - num5));
            };

            Color.prototype.ToArgb = function () {
                return (this.m_alpha << 24) | (this.m_red << 16) | (this.m_green << 8) | (this.m_blue);
            };

            Object.defineProperty(Color.prototype, "ToHTML", {
                get: function () {
                    var r = "0" + this.m_red.toString(16);
                    var g = "0" + this.m_green.toString(16);
                    var b = "0" + this.m_blue.toString(16);

                    return "#" + r.substring(r.length - 2) + g.substring(g.length - 2) + b.substring(b.length - 2);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Color.prototype, "A", {
                get: function () {
                    return this.m_alpha;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Color.prototype, "R", {
                get: function () {
                    return this.m_red;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Color.prototype, "G", {
                get: function () {
                    return this.m_green;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Color.prototype, "B", {
                get: function () {
                    return this.m_blue;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Color, "AliceBlue", {
                get: function () {
                    return new Color(255, 240, 248, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "AntiqueWhite", {
                get: function () {
                    return new Color(255, 250, 235, 215);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Aqua", {
                get: function () {
                    return new Color(255, 0, 255, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Aquamarine", {
                get: function () {
                    return new Color(255, 127, 255, 212);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Azure", {
                get: function () {
                    return new Color(255, 240, 255, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Beige", {
                get: function () {
                    return new Color(255, 245, 245, 220);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Bisque", {
                get: function () {
                    return new Color(255, 255, 228, 196);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Black", {
                get: function () {
                    return new Color(255, 0, 0, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "BlanchedAlmond", {
                get: function () {
                    return new Color(255, 255, 235, 205);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Blue", {
                get: function () {
                    return new Color(255, 0, 0, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "BlueViolet", {
                get: function () {
                    return new Color(255, 138, 43, 226);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Brown", {
                get: function () {
                    return new Color(255, 165, 42, 42);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "BurlyWood", {
                get: function () {
                    return new Color(255, 222, 184, 135);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "CadetBlue", {
                get: function () {
                    return new Color(255, 95, 158, 160);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Chartreuse", {
                get: function () {
                    return new Color(255, 127, 255, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Chocolate", {
                get: function () {
                    return new Color(255, 210, 105, 30);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Coral", {
                get: function () {
                    return new Color(255, 255, 127, 80);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "CornflowerBlue", {
                get: function () {
                    return new Color(255, 100, 149, 237);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Cornsilk", {
                get: function () {
                    return new Color(255, 255, 248, 220);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Crimson", {
                get: function () {
                    return new Color(255, 220, 20, 60);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Cyan", {
                get: function () {
                    return new Color(255, 0, 255, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkBlue", {
                get: function () {
                    return new Color(255, 0, 0, 139);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkCyan", {
                get: function () {
                    return new Color(255, 0, 139, 139);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkGoldenrod", {
                get: function () {
                    return new Color(255, 184, 134, 11);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkGray", {
                get: function () {
                    return new Color(255, 169, 169, 169);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkGreen", {
                get: function () {
                    return new Color(255, 0, 100, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkKhaki", {
                get: function () {
                    return new Color(255, 189, 183, 107);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkMagenta", {
                get: function () {
                    return new Color(255, 139, 0, 139);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkOliveGreen", {
                get: function () {
                    return new Color(255, 85, 107, 47);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkOrange", {
                get: function () {
                    return new Color(255, 255, 140, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkOrchid", {
                get: function () {
                    return new Color(255, 153, 50, 204);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkRed", {
                get: function () {
                    return new Color(255, 139, 0, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkSalmon", {
                get: function () {
                    return new Color(255, 233, 150, 122);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkSeaGreen", {
                get: function () {
                    return new Color(255, 143, 188, 143);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkSlateBlue", {
                get: function () {
                    return new Color(255, 72, 61, 139);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkSlateGray", {
                get: function () {
                    return new Color(255, 47, 79, 79);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkTurquoise", {
                get: function () {
                    return new Color(255, 0, 206, 209);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DarkViolet", {
                get: function () {
                    return new Color(255, 148, 0, 211);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DeepPink", {
                get: function () {
                    return new Color(255, 255, 20, 147);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DeepSkyBlue", {
                get: function () {
                    return new Color(255, 0, 191, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DimGray", {
                get: function () {
                    return new Color(255, 105, 105, 105);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "DodgerBlue", {
                get: function () {
                    return new Color(255, 30, 144, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "FireBrick", {
                get: function () {
                    return new Color(255, 178, 34, 34);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "FloralWhite", {
                get: function () {
                    return new Color(255, 255, 250, 240);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "ForestGreen", {
                get: function () {
                    return new Color(255, 34, 139, 34);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Fuchsia", {
                get: function () {
                    return new Color(255, 255, 0, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Gainsboro", {
                get: function () {
                    return new Color(255, 220, 220, 220);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "GhostWhite", {
                get: function () {
                    return new Color(255, 248, 248, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Gold", {
                get: function () {
                    return new Color(255, 255, 215, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Goldenrod", {
                get: function () {
                    return new Color(255, 218, 165, 32);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Gray", {
                get: function () {
                    return new Color(255, 128, 128, 128);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Green", {
                get: function () {
                    return new Color(255, 0, 128, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "GreenYellow", {
                get: function () {
                    return new Color(255, 173, 255, 47);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Honeydew", {
                get: function () {
                    return new Color(255, 240, 255, 240);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "HotPink", {
                get: function () {
                    return new Color(255, 255, 105, 180);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "IndianRed", {
                get: function () {
                    return new Color(255, 205, 92, 92);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Indigo", {
                get: function () {
                    return new Color(255, 75, 0, 130);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Ivory", {
                get: function () {
                    return new Color(255, 255, 255, 240);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Khaki", {
                get: function () {
                    return new Color(255, 240, 230, 140);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Lavender", {
                get: function () {
                    return new Color(255, 230, 230, 250);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LavenderBlush", {
                get: function () {
                    return new Color(255, 255, 240, 245);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LawnGreen", {
                get: function () {
                    return new Color(255, 124, 252, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LemonChiffon", {
                get: function () {
                    return new Color(255, 255, 250, 205);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightBlue", {
                get: function () {
                    return new Color(255, 173, 216, 230);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightCoral", {
                get: function () {
                    return new Color(255, 240, 128, 128);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightCyan", {
                get: function () {
                    return new Color(255, 224, 255, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightGoldenrodYellow", {
                get: function () {
                    return new Color(255, 250, 250, 210);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightGreen", {
                get: function () {
                    return new Color(255, 144, 238, 144);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightGray", {
                get: function () {
                    return new Color(255, 211, 211, 211);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightPink", {
                get: function () {
                    return new Color(255, 255, 182, 193);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightSalmon", {
                get: function () {
                    return new Color(255, 255, 160, 122);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightSeaGreen", {
                get: function () {
                    return new Color(255, 32, 178, 170);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightSkyBlue", {
                get: function () {
                    return new Color(255, 135, 206, 250);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightSlateGray", {
                get: function () {
                    return new Color(255, 119, 136, 153);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightSteelBlue", {
                get: function () {
                    return new Color(255, 176, 196, 222);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LightYellow", {
                get: function () {
                    return new Color(255, 255, 255, 224);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Lime", {
                get: function () {
                    return new Color(255, 0, 255, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "LimeGreen", {
                get: function () {
                    return new Color(255, 50, 205, 50);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Linen", {
                get: function () {
                    return new Color(255, 250, 240, 230);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Magenta", {
                get: function () {
                    return new Color(255, 255, 0, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Maroon", {
                get: function () {
                    return new Color(255, 128, 0, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumAquamarine", {
                get: function () {
                    return new Color(255, 102, 205, 170);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumBlue", {
                get: function () {
                    return new Color(255, 0, 0, 205);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumOrchid", {
                get: function () {
                    return new Color(255, 186, 85, 211);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumPurple", {
                get: function () {
                    return new Color(255, 147, 112, 219);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumSeaGreen", {
                get: function () {
                    return new Color(255, 60, 179, 113);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumSlateBlue", {
                get: function () {
                    return new Color(255, 123, 104, 238);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumSpringGreen", {
                get: function () {
                    return new Color(255, 0, 250, 154);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumTurquoise", {
                get: function () {
                    return new Color(255, 72, 209, 204);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MediumVioletRed", {
                get: function () {
                    return new Color(255, 199, 21, 133);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MidnightBlue", {
                get: function () {
                    return new Color(255, 25, 25, 112);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MintCream", {
                get: function () {
                    return new Color(255, 245, 255, 250);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "MistyRose", {
                get: function () {
                    return new Color(255, 255, 228, 225);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Moccasin", {
                get: function () {
                    return new Color(255, 255, 228, 181);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "NavajoWhite", {
                get: function () {
                    return new Color(255, 255, 222, 173);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Navy", {
                get: function () {
                    return new Color(255, 0, 0, 128);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "OldLace", {
                get: function () {
                    return new Color(255, 253, 245, 230);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Olive", {
                get: function () {
                    return new Color(255, 128, 128, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "OliveDrab", {
                get: function () {
                    return new Color(255, 107, 142, 35);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Orange", {
                get: function () {
                    return new Color(255, 255, 165, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "OrangeRed", {
                get: function () {
                    return new Color(255, 255, 69, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Orchid", {
                get: function () {
                    return new Color(255, 218, 112, 214);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PaleGoldenrod", {
                get: function () {
                    return new Color(255, 238, 232, 170);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PaleGreen", {
                get: function () {
                    return new Color(255, 152, 251, 152);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PaleTurquoise", {
                get: function () {
                    return new Color(255, 175, 238, 238);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PaleVioletRed", {
                get: function () {
                    return new Color(255, 219, 112, 147);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PapayaWhip", {
                get: function () {
                    return new Color(255, 255, 239, 213);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PeachPuff", {
                get: function () {
                    return new Color(255, 255, 218, 185);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Peru", {
                get: function () {
                    return new Color(255, 205, 133, 63);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Pink", {
                get: function () {
                    return new Color(255, 255, 192, 203);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Plum", {
                get: function () {
                    return new Color(255, 221, 160, 221);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "PowderBlue", {
                get: function () {
                    return new Color(255, 176, 224, 230);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Purple", {
                get: function () {
                    return new Color(255, 128, 0, 128);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Red", {
                get: function () {
                    return new Color(255, 255, 0, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "RosyBrown", {
                get: function () {
                    return new Color(255, 188, 143, 143);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "RoyalBlue", {
                get: function () {
                    return new Color(255, 65, 105, 225);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SaddleBrown", {
                get: function () {
                    return new Color(255, 139, 69, 19);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Salmon", {
                get: function () {
                    return new Color(255, 250, 128, 114);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SandyBrown", {
                get: function () {
                    return new Color(255, 244, 164, 96);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SeaGreen", {
                get: function () {
                    return new Color(255, 46, 139, 87);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Seashell", {
                get: function () {
                    return new Color(255, 255, 245, 238);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Sienna", {
                get: function () {
                    return new Color(255, 160, 82, 45);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Silver", {
                get: function () {
                    return new Color(255, 192, 192, 192);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SkyBlue", {
                get: function () {
                    return new Color(255, 135, 206, 235);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SlateBlue", {
                get: function () {
                    return new Color(255, 106, 90, 205);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SlateGray", {
                get: function () {
                    return new Color(255, 112, 128, 144);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Snow", {
                get: function () {
                    return new Color(255, 255, 250, 250);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SpringGreen", {
                get: function () {
                    return new Color(255, 0, 255, 127);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "SteelBlue", {
                get: function () {
                    return new Color(255, 70, 130, 180);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Tan", {
                get: function () {
                    return new Color(255, 210, 180, 140);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Teal", {
                get: function () {
                    return new Color(255, 0, 128, 128);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Thistle", {
                get: function () {
                    return new Color(255, 216, 191, 216);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Tomato", {
                get: function () {
                    return new Color(255, 255, 99, 71);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Turquoise", {
                get: function () {
                    return new Color(255, 64, 224, 208);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Violet", {
                get: function () {
                    return new Color(255, 238, 130, 238);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Wheat", {
                get: function () {
                    return new Color(255, 245, 222, 179);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "White", {
                get: function () {
                    return new Color(255, 255, 255, 255);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "WhiteSmoke", {
                get: function () {
                    return new Color(255, 245, 245, 245);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "Yellow", {
                get: function () {
                    return new Color(255, 255, 255, 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color, "YellowGreen", {
                get: function () {
                    return new Color(255, 154, 205, 50);
                },
                enumerable: true,
                configurable: true
            });
            Color.Empty = new Color(0, 0, 0, 0);
            return Color;
        })();
        Drawing.Color = Color;

        (function (ContentAlignment) {
            ContentAlignment[ContentAlignment["BottomCenter"] = 0] = "BottomCenter";
            ContentAlignment[ContentAlignment["BottomLeft"] = 1] = "BottomLeft";
            ContentAlignment[ContentAlignment["BottomRight"] = 2] = "BottomRight";
            ContentAlignment[ContentAlignment["MiddleCenter"] = 3] = "MiddleCenter";
            ContentAlignment[ContentAlignment["MiddleLeft"] = 4] = "MiddleLeft";
            ContentAlignment[ContentAlignment["MiddleRight"] = 5] = "MiddleRight";
            ContentAlignment[ContentAlignment["TopCenter"] = 6] = "TopCenter";
            ContentAlignment[ContentAlignment["TopLeft"] = 7] = "TopLeft";
            ContentAlignment[ContentAlignment["TopRight"] = 8] = "TopRight";
        })(Drawing.ContentAlignment || (Drawing.ContentAlignment = {}));
        var ContentAlignment = Drawing.ContentAlignment;

        /*
        export enum CopyPixelOperation
        {
        Blackness,
        CaptureBlt,
        DestinationInvert,
        MergeCopy,
        MergePaint,
        NoMirrorBitmap,
        NotSourceCopy,
        NotSourceErase,
        PatCopy,
        PatInvert,
        PatPaint,
        SourceAnd,
        SourceCopy,
        SourceErase,
        SourceInvert,
        SourcePaint,
        Whiteness,
        }
        */
        var Font = (function () {
            function Font(familyName, emSize) {
                this.m_familyName = familyName;
                this.m_emSize = emSize;
            }
            Object.defineProperty(Font.prototype, "Bold", {
                get: function () {
                    // TODO
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "FontFamily", {
                get: function () {
                    // TODO
                    return new FontFamily(this.m_familyName);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "Height", {
                get: function () {
                    // TODO
                    return 4;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "Italic", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Font.prototype, "Name", {
                get: function () {
                    return this.m_familyName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "Size", {
                get: function () {
                    return this.m_emSize;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "SizeInPoints", {
                get: function () {
                    return this.m_emSize;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "Strikeout", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "Underline", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Font.prototype, "ToHTML", {
                /*
                get Unit(): System.Drawing.GraphicsUnit
                {
                return GraphicsUnit.Point;
                }
                */
                get: function () {
                    var font = this.m_emSize + "pt " + this.m_familyName;

                    /*
                    if (this.fontWeight != undefined)
                    {
                    font += " " + this.fontWeight;
                    }
                    if (this.fontStyle != undefined)
                    {
                    font += " " + this.fontStyle;
                    }
                    */
                    return font;
                },
                enumerable: true,
                configurable: true
            });
            return Font;
        })();
        Drawing.Font = Font;

        var FontFamily = (function () {
            function FontFamily(familyName) {
                this.m_familyName = familyName;
            }
            FontFamily.prototype.GetName = function (language) {
                return this.m_familyName;
            };

            Object.defineProperty(FontFamily.prototype, "Name", {
                get: function () {
                    return this.m_familyName;
                },
                enumerable: true,
                configurable: true
            });
            return FontFamily;
        })();
        Drawing.FontFamily = FontFamily;

        (function (FontStyle) {
            FontStyle[FontStyle["Bold"] = 1] = "Bold";
            FontStyle[FontStyle["Italic"] = 2] = "Italic";
            FontStyle[FontStyle["Regular"] = 0] = "Regular";
            FontStyle[FontStyle["Strikeout"] = 8] = "Strikeout";
            FontStyle[FontStyle["Underline"] = 4] = "Underline";
        })(Drawing.FontStyle || (Drawing.FontStyle = {}));
        var FontStyle = Drawing.FontStyle;

        /*
        export enum GraphicsUnit
        {
        Display,
        Document,
        Inch,
        Millimeter,
        Pixel,
        Point,
        World,
        }
        */
        /*
        export enum KnownColor
        {
        ActiveBorder,
        ActiveCaption,
        ActiveCaptionText,
        AliceBlue,
        AntiqueWhite,
        AppWorkspace,
        Aqua,
        Aquamarine,
        Azure,
        Beige,
        Bisque,
        Black,
        BlanchedAlmond,
        Blue,
        BlueViolet,
        Brown,
        BurlyWood,
        ButtonFace,
        ButtonHighlight,
        ButtonShadow,
        CadetBlue,
        Chartreuse,
        Chocolate,
        Control,
        ControlDark,
        ControlDarkDark,
        ControlLight,
        ControlLightLight,
        ControlText,
        Coral,
        CornflowerBlue,
        Cornsilk,
        Crimson,
        Cyan,
        DarkBlue,
        DarkCyan,
        DarkGoldenrod,
        DarkGray,
        DarkGreen,
        DarkKhaki,
        DarkMagenta,
        DarkOliveGreen,
        DarkOrange,
        DarkOrchid,
        DarkRed,
        DarkSalmon,
        DarkSeaGreen,
        DarkSlateBlue,
        DarkSlateGray,
        DarkTurquoise,
        DarkViolet,
        DeepPink,
        DeepSkyBlue,
        Desktop,
        DimGray,
        DodgerBlue,
        Firebrick,
        FloralWhite,
        ForestGreen,
        Fuchsia,
        Gainsboro,
        GhostWhite,
        Gold,
        Goldenrod,
        GradientActiveCaption,
        GradientInactiveCaption,
        Gray,
        GrayText,
        Green,
        GreenYellow,
        Highlight,
        HighlightText,
        Honeydew,
        HotPink,
        HotTrack,
        InactiveBorder,
        InactiveCaption,
        InactiveCaptionText,
        IndianRed,
        Indigo,
        Info,
        InfoText,
        Ivory,
        Khaki,
        Lavender,
        LavenderBlush,
        LawnGreen,
        LemonChiffon,
        LightBlue,
        LightCoral,
        LightCyan,
        LightGoldenrodYellow,
        LightGray,
        LightGreen,
        LightPink,
        LightSalmon,
        LightSeaGreen,
        LightSkyBlue,
        LightSlateGray,
        LightSteelBlue,
        LightYellow,
        Lime,
        LimeGreen,
        Linen,
        Magenta,
        Maroon,
        MediumAquamarine,
        MediumBlue,
        MediumOrchid,
        MediumPurple,
        MediumSeaGreen,
        MediumSlateBlue,
        MediumSpringGreen,
        MediumTurquoise,
        MediumVioletRed,
        Menu,
        MenuBar,
        MenuHighlight,
        MenuText,
        MidnightBlue,
        MintCream,
        MistyRose,
        Moccasin,
        NavajoWhite,
        Navy,
        OldLace,
        Olive,
        OliveDrab,
        Orange,
        OrangeRed,
        Orchid,
        PaleGoldenrod,
        PaleGreen,
        PaleTurquoise,
        PaleVioletRed,
        PapayaWhip,
        PeachPuff,
        Peru,
        Pink,
        Plum,
        PowderBlue,
        Purple,
        Red,
        RosyBrown,
        RoyalBlue,
        SaddleBrown,
        Salmon,
        SandyBrown,
        ScrollBar,
        SeaGreen,
        SeaShell,
        Sienna,
        Silver,
        SkyBlue,
        SlateBlue,
        SlateGray,
        Snow,
        SpringGreen,
        SteelBlue,
        Tan,
        Teal,
        Thistle,
        Tomato,
        Transparent,
        Turquoise,
        Violet,
        Wheat,
        White,
        WhiteSmoke,
        Window,
        WindowFrame,
        WindowText,
        Yellow,
        YellowGreen,
        }
        */
        /*
        export class Pen
        {
        constructor
        (
        color: Color,
        width? : number
        )
        {
        this.m_color = color;
        if (width)
        this.m_width = width;
        else
        this.m_width = 1;
        }
        
        m_color: Color;
        m_width: number;
        
        m_alignment: Drawing2D.PenAlignment = Drawing2D.PenAlignment.Left;
        
        get Alignment(): System.Drawing.Drawing2D.PenAlignment
        {
        return this.m_alignment;
        }
        set Alignment(value: System.Drawing.Drawing2D.PenAlignment)
        {
        this.m_alignment = value;
        }
        get Color(): System.Drawing.Color
        {
        return this.m_color;
        }
        set Color(value: System.Drawing.Color)
        {
        this.m_color = value;
        }
        get PenType(): System.Drawing.Drawing2D.PenType
        {
        return Drawing2D.PenType.SolidColor;
        }
        get Width(): number
        {
        return this.m_width;
        }
        set Width(value: number)
        {
        this.m_width = value;
        }
        }*/
        /*
        export class Pens
        {
        static get AliceBlue(): System.Drawing.Pen
        {
        return new Pen(Color.AliceBlue);
        }
        static get AntiqueWhite(): System.Drawing.Pen
        {
        return new Pen(Color.AntiqueWhite);
        }
        static get Aqua(): System.Drawing.Pen
        {
        return new Pen(Color.Aqua);
        }
        static get Aquamarine(): System.Drawing.Pen
        {
        return new Pen(Color.Aquamarine);
        }
        static get Azure(): System.Drawing.Pen
        {
        return new Pen(Color.Azure);
        }
        static get Beige(): System.Drawing.Pen
        {
        return new Pen(Color.Beige);
        }
        static get Bisque(): System.Drawing.Pen
        {
        return new Pen(Color.Bisque);
        }
        static get Black(): System.Drawing.Pen
        {
        return new Pen(Color.Black);
        }
        static get BlanchedAlmond(): System.Drawing.Pen
        {
        return new Pen(Color.BlanchedAlmond);
        }
        static get Blue(): System.Drawing.Pen
        {
        return new Pen(Color.Blue);
        }
        static get BlueViolet(): System.Drawing.Pen
        {
        return new Pen(Color.BlueViolet);
        }
        static get Brown(): System.Drawing.Pen
        {
        return new Pen(Color.Brown);
        }
        static get BurlyWood(): System.Drawing.Pen
        {
        return new Pen(Color.BurlyWood);
        }
        static get CadetBlue(): System.Drawing.Pen
        {
        return new Pen(Color.CadetBlue);
        }
        static get Chartreuse(): System.Drawing.Pen
        {
        return new Pen(Color.Chartreuse);
        }
        static get Chocolate(): System.Drawing.Pen
        {
        return new Pen(Color.Chocolate);
        }
        static get Coral(): System.Drawing.Pen
        {
        return new Pen(Color.Coral);
        }
        static get CornflowerBlue(): System.Drawing.Pen
        {
        return new Pen(Color.CornflowerBlue);
        }
        static get Cornsilk(): System.Drawing.Pen
        {
        return new Pen(Color.Cornsilk);
        }
        static get Crimson(): System.Drawing.Pen
        {
        return new Pen(Color.Crimson);
        }
        static get Cyan(): System.Drawing.Pen
        {
        return new Pen(Color.Cyan);
        }
        static get DarkBlue(): System.Drawing.Pen
        {
        return new Pen(Color.DarkBlue);
        }
        static get DarkCyan(): System.Drawing.Pen
        {
        return new Pen(Color.DarkCyan);
        }
        static get DarkGoldenrod(): System.Drawing.Pen
        {
        return new Pen(Color.DarkGoldenrod);
        }
        static get DarkGray(): System.Drawing.Pen
        {
        return new Pen(Color.DarkGray);
        }
        static get DarkGreen(): System.Drawing.Pen
        {
        return new Pen(Color.DarkGreen);
        }
        static get DarkKhaki(): System.Drawing.Pen
        {
        return new Pen(Color.DarkKhaki);
        }
        static get DarkMagenta(): System.Drawing.Pen
        {
        return new Pen(Color.DarkMagenta);
        }
        static get DarkOliveGreen(): System.Drawing.Pen
        {
        return new Pen(Color.DarkOliveGreen);
        }
        static get DarkOrange(): System.Drawing.Pen
        {
        return new Pen(Color.DarkOrange);
        }
        static get DarkOrchid(): System.Drawing.Pen
        {
        return new Pen(Color.DarkOrchid);
        }
        static get DarkRed(): System.Drawing.Pen
        {
        return new Pen(Color.DarkRed);
        }
        static get DarkSalmon(): System.Drawing.Pen
        {
        return new Pen(Color.DarkSalmon);
        }
        static get DarkSeaGreen(): System.Drawing.Pen
        {
        return new Pen(Color.DarkSeaGreen);
        }
        static get DarkSlateBlue(): System.Drawing.Pen
        {
        return new Pen(Color.DarkSlateBlue);
        }
        static get DarkSlateGray(): System.Drawing.Pen
        {
        return new Pen(Color.DarkSlateGray);
        }
        static get DarkTurquoise(): System.Drawing.Pen
        {
        return new Pen(Color.DarkTurquoise);
        }
        static get DarkViolet(): System.Drawing.Pen
        {
        return new Pen(Color.DarkViolet);
        }
        static get DeepPink(): System.Drawing.Pen
        {
        return new Pen(Color.DeepPink);
        }
        static get DeepSkyBlue(): System.Drawing.Pen
        {
        return new Pen(Color.DeepSkyBlue);
        }
        static get DimGray(): System.Drawing.Pen
        {
        return new Pen(Color.DimGray);
        }
        static get DodgerBlue(): System.Drawing.Pen
        {
        return new Pen(Color.DodgerBlue);
        }
        static get FireBrick(): System.Drawing.Pen
        {
        return new Pen(Color.FireBrick);
        }
        static get FloralWhite(): System.Drawing.Pen
        {
        return new Pen(Color.FloralWhite);
        }
        static get ForestGreen(): System.Drawing.Pen
        {
        return new Pen(Color.ForestGreen);
        }
        static get Fuchsia(): System.Drawing.Pen
        {
        return new Pen(Color.Fuchsia);
        }
        static get Gainsboro(): System.Drawing.Pen
        {
        return new Pen(Color.Gainsboro);
        }
        static get GhostWhite(): System.Drawing.Pen
        {
        return new Pen(Color.GhostWhite);
        }
        static get Gold(): System.Drawing.Pen
        {
        return new Pen(Color.Gold);
        }
        static get Goldenrod(): System.Drawing.Pen
        {
        return new Pen(Color.Goldenrod);
        }
        static get Gray(): System.Drawing.Pen
        {
        return new Pen(Color.Gray);
        }
        static get Green(): System.Drawing.Pen
        {
        return new Pen(Color.Green);
        }
        static get GreenYellow(): System.Drawing.Pen
        {
        return new Pen(Color.GreenYellow);
        }
        static get Honeydew(): System.Drawing.Pen
        {
        return new Pen(Color.Honeydew);
        }
        static get HotPink(): System.Drawing.Pen
        {
        return new Pen(Color.HotPink);
        }
        static get IndianRed(): System.Drawing.Pen
        {
        return new Pen(Color.IndianRed);
        }
        static get Indigo(): System.Drawing.Pen
        {
        return new Pen(Color.Indigo);
        }
        static get Ivory(): System.Drawing.Pen
        {
        return new Pen(Color.Ivory);
        }
        static get Khaki(): System.Drawing.Pen
        {
        return new Pen(Color.Khaki);
        }
        static get Lavender(): System.Drawing.Pen
        {
        return new Pen(Color.Lavender);
        }
        static get LavenderBlush(): System.Drawing.Pen
        {
        return new Pen(Color.LavenderBlush);
        }
        static get LawnGreen(): System.Drawing.Pen
        {
        return new Pen(Color.LawnGreen);
        }
        static get LemonChiffon(): System.Drawing.Pen
        {
        return new Pen(Color.LemonChiffon);
        }
        static get LightBlue(): System.Drawing.Pen
        {
        return new Pen(Color.LightBlue);
        }
        static get LightCoral(): System.Drawing.Pen
        {
        return new Pen(Color.LightCoral);
        }
        static get LightCyan(): System.Drawing.Pen
        {
        return new Pen(Color.LightCyan);
        }
        static get LightGoldenrodYellow(): System.Drawing.Pen
        {
        return new Pen(Color.LightGoldenrodYellow);
        }
        static get LightGreen(): System.Drawing.Pen
        {
        return new Pen(Color.LightGreen);
        }
        static get LightGray(): System.Drawing.Pen
        {
        return new Pen(Color.LightGray);
        }
        static get LightPink(): System.Drawing.Pen
        {
        return new Pen(Color.LightPink);
        }
        static get LightSalmon(): System.Drawing.Pen
        {
        return new Pen(Color.LightSalmon);
        }
        static get LightSeaGreen(): System.Drawing.Pen
        {
        return new Pen(Color.LightSeaGreen);
        }
        static get LightSkyBlue(): System.Drawing.Pen
        {
        return new Pen(Color.LightSkyBlue);
        }
        static get LightSlateGray(): System.Drawing.Pen
        {
        return new Pen(Color.LightSlateGray);
        }
        static get LightSteelBlue(): System.Drawing.Pen
        {
        return new Pen(Color.LightSteelBlue);
        }
        static get LightYellow(): System.Drawing.Pen
        {
        return new Pen(Color.LightYellow);
        }
        static get Lime(): System.Drawing.Pen
        {
        return new Pen(Color.Lime);
        }
        static get LimeGreen(): System.Drawing.Pen
        {
        return new Pen(Color.LimeGreen);
        }
        static get Linen(): System.Drawing.Pen
        {
        return new Pen(Color.Linen);
        }
        static get Magenta(): System.Drawing.Pen
        {
        return new Pen(Color.Magenta);
        }
        static get Maroon(): System.Drawing.Pen
        {
        return new Pen(Color.Maroon);
        }
        static get MediumAquamarine(): System.Drawing.Pen
        {
        return new Pen(Color.MediumAquamarine);
        }
        static get MediumBlue(): System.Drawing.Pen
        {
        return new Pen(Color.MediumBlue);
        }
        static get MediumOrchid(): System.Drawing.Pen
        {
        return new Pen(Color.MediumOrchid);
        }
        static get MediumPurple(): System.Drawing.Pen
        {
        return new Pen(Color.MediumPurple);
        }
        static get MediumSeaGreen(): System.Drawing.Pen
        {
        return new Pen(Color.MediumSeaGreen);
        }
        static get MediumSlateBlue(): System.Drawing.Pen
        {
        return new Pen(Color.MediumSlateBlue);
        }
        static get MediumSpringGreen(): System.Drawing.Pen
        {
        return new Pen(Color.MediumSpringGreen);
        }
        static get MediumTurquoise(): System.Drawing.Pen
        {
        return new Pen(Color.MediumTurquoise);
        }
        static get MediumVioletRed(): System.Drawing.Pen
        {
        return new Pen(Color.MediumVioletRed);
        }
        static get MidnightBlue(): System.Drawing.Pen
        {
        return new Pen(Color.MidnightBlue);
        }
        static get MintCream(): System.Drawing.Pen
        {
        return new Pen(Color.MintCream);
        }
        static get MistyRose(): System.Drawing.Pen
        {
        return new Pen(Color.MistyRose);
        }
        static get Moccasin(): System.Drawing.Pen
        {
        return new Pen(Color.Moccasin);
        }
        static get NavajoWhite(): System.Drawing.Pen
        {
        return new Pen(Color.NavajoWhite);
        }
        static get Navy(): System.Drawing.Pen
        {
        return new Pen(Color.Navy);
        }
        static get OldLace(): System.Drawing.Pen
        {
        return new Pen(Color.OldLace);
        }
        static get Olive(): System.Drawing.Pen
        {
        return new Pen(Color.Olive);
        }
        static get OliveDrab(): System.Drawing.Pen
        {
        return new Pen(Color.OliveDrab);
        }
        static get Orange(): System.Drawing.Pen
        {
        return new Pen(Color.Orange);
        }
        static get OrangeRed(): System.Drawing.Pen
        {
        return new Pen(Color.OrangeRed);
        }
        static get Orchid(): System.Drawing.Pen
        {
        return new Pen(Color.Orchid);
        }
        static get PaleGoldenrod(): System.Drawing.Pen
        {
        return new Pen(Color.PaleGoldenrod);
        }
        static get PaleGreen(): System.Drawing.Pen
        {
        return new Pen(Color.PaleGreen);
        }
        static get PaleTurquoise(): System.Drawing.Pen
        {
        return new Pen(Color.PaleTurquoise);
        }
        static get PaleVioletRed(): System.Drawing.Pen
        {
        return new Pen(Color.PaleVioletRed);
        }
        static get PapayaWhip(): System.Drawing.Pen
        {
        return new Pen(Color.PapayaWhip);
        }
        static get PeachPuff(): System.Drawing.Pen
        {
        return new Pen(Color.PeachPuff);
        }
        static get Peru(): System.Drawing.Pen
        {
        return new Pen(Color.Peru);
        }
        static get Pink(): System.Drawing.Pen
        {
        return new Pen(Color.Pink);
        }
        static get Plum(): System.Drawing.Pen
        {
        return new Pen(Color.Plum);
        }
        static get PowderBlue(): System.Drawing.Pen
        {
        return new Pen(Color.PowderBlue);
        }
        static get Purple(): System.Drawing.Pen
        {
        return new Pen(Color.Purple);
        }
        static get Red(): System.Drawing.Pen
        {
        return new Pen(Color.Red);
        }
        static get RosyBrown(): System.Drawing.Pen
        {
        return new Pen(Color.RosyBrown);
        }
        static get RoyalBlue(): System.Drawing.Pen
        {
        return new Pen(Color.RoyalBlue);
        }
        static get SaddleBrown(): System.Drawing.Pen
        {
        return new Pen(Color.SaddleBrown);
        }
        static get Salmon(): System.Drawing.Pen
        {
        return new Pen(Color.Salmon);
        }
        static get SandyBrown(): System.Drawing.Pen
        {
        return new Pen(Color.SandyBrown);
        }
        static get SeaGreen(): System.Drawing.Pen
        {
        return new Pen(Color.SeaGreen);
        }
        static get Seashell(): System.Drawing.Pen
        {
        return new Pen(Color.Seashell);
        }
        static get Sienna(): System.Drawing.Pen
        {
        return new Pen(Color.Sienna);
        }
        static get Silver(): System.Drawing.Pen
        {
        return new Pen(Color.Silver);
        }
        static get SkyBlue(): System.Drawing.Pen
        {
        return new Pen(Color.SkyBlue);
        }
        static get SlateBlue(): System.Drawing.Pen
        {
        return new Pen(Color.SlateBlue);
        }
        static get SlateGray(): System.Drawing.Pen
        {
        return new Pen(Color.SlateGray);
        }
        static get Snow(): System.Drawing.Pen
        {
        return new Pen(Color.Snow);
        }
        static get SpringGreen(): System.Drawing.Pen
        {
        return new Pen(Color.SpringGreen);
        }
        static get SteelBlue(): System.Drawing.Pen
        {
        return new Pen(Color.SteelBlue);
        }
        static get Tan(): System.Drawing.Pen
        {
        return new Pen(Color.Tan);
        }
        static get Teal(): System.Drawing.Pen
        {
        return new Pen(Color.Teal);
        }
        static get Thistle(): System.Drawing.Pen
        {
        return new Pen(Color.Thistle);
        }
        static get Tomato(): System.Drawing.Pen
        {
        return new Pen(Color.Tomato);
        }
        static get Turquoise(): System.Drawing.Pen
        {
        return new Pen(Color.Turquoise);
        }
        static get Violet(): System.Drawing.Pen
        {
        return new Pen(Color.Violet);
        }
        static get Wheat(): System.Drawing.Pen
        {
        return new Pen(Color.Wheat);
        }
        static get White(): System.Drawing.Pen
        {
        return new Pen(Color.White);
        }
        static get WhiteSmoke(): System.Drawing.Pen
        {
        return new Pen(Color.WhiteSmoke);
        }
        static get Yellow(): System.Drawing.Pen
        {
        return new Pen(Color.Yellow);
        }
        static get YellowGreen(): System.Drawing.Pen
        {
        return new Pen(Color.YellowGreen);
        }
        }
        */
        var Point = (function () {
            function Point(x, y) {
                this.m_x = x;
                this.m_y = y;
            }
            Object.defineProperty(Point.prototype, "IsEmpty", {
                get: function () {
                    return this.m_x == 0 && this.m_y == 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Point.prototype, "X", {
                get: function () {
                    return this.m_x;
                },
                set: function (value) {
                    this.m_x = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Point.prototype, "Y", {
                get: function () {
                    return this.m_y;
                },
                set: function (value) {
                    this.m_y = value;
                },
                enumerable: true,
                configurable: true
            });
            Point.Empty = new Point(0, 0);
            return Point;
        })();
        Drawing.Point = Point;

        var Rectangle = (function () {
            function Rectangle(left, top, right, bottom) {
                this.m_left = left;
                this.m_top = top;
                this.m_right = right;
                this.m_bottom = bottom;
            }
            Rectangle.prototype.Contains = function (rect) {
                var contains = false;

                if (rect.Left >= this.Left) {
                    if (rect.Right <= this.Right) {
                        if (rect.Top >= this.Top) {
                            if (rect.Bottom <= this.Bottom) {
                                contains = true;
                            }
                        }
                    }
                }

                return contains;
            };

            Rectangle.prototype.ContainsPoint = function (pt) {
                return this.Contains(new Rectangle(pt.X, pt.Y, pt.X, pt.Y));
            };

            Rectangle.FromLTRB = function (left, top, right, bottom) {
                return new Rectangle(left, top, right, bottom);
            };

            Rectangle.prototype.Inflate = function (width, height) {
                this.m_left -= width;
                this.m_top -= height;
                this.m_right += width;
                this.m_bottom += height;
            };

            Rectangle.Inflate = function (rect, width, height) {
                return new Rectangle(rect.m_left - width, rect.m_top - height, rect.m_right + width, rect.m_bottom + height);
            };

            Object.defineProperty(Rectangle.prototype, "Bottom", {
                get: function () {
                    return this.m_bottom;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "Height", {
                get: function () {
                    return this.m_bottom - this.m_top;
                },
                set: function (value) {
                    this.m_bottom = this.m_top + value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "IsEmpty", {
                get: function () {
                    return this.Width <= 0 || this.Height <= 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "Left", {
                get: function () {
                    return this.m_left;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "Right", {
                get: function () {
                    return this.m_right;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "Size", {
                get: function () {
                    return new Size(this.Width, this.Height);
                },
                set: function (value) {
                    this.Width = value.Width;
                    this.Height = value.Height;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "Top", {
                get: function () {
                    return this.m_top;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "Width", {
                get: function () {
                    return this.m_right - this.m_left;
                },
                set: function (value) {
                    this.m_right = this.m_left + value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "X", {
                get: function () {
                    return this.m_left;
                },
                set: function (value) {
                    this.m_left = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "Y", {
                get: function () {
                    return this.m_top;
                },
                set: function (value) {
                    this.m_top = value;
                },
                enumerable: true,
                configurable: true
            });

            Rectangle.Empty = new Rectangle(0, 0, 0, 0);
            return Rectangle;
        })();
        Drawing.Rectangle = Rectangle;

        var Size = (function () {
            function Size(width, height) {
                this.m_width = width;
                this.m_height = height;
            }
            Size.Ceiling = function (value) {
                return new Size(Math.ceil(value.Width), Math.ceil(value.Height));
            };
            Size.Round = function (value) {
                return new Size(Math.round(value.Width), Math.round(value.Height));
            };
            Object.defineProperty(Size.prototype, "Height", {
                get: function () {
                    return this.m_height;
                },
                set: function (value) {
                    this.m_height = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Size.prototype, "IsEmpty", {
                get: function () {
                    return this.m_width <= 0 || this.m_height <= 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Size.prototype, "Width", {
                get: function () {
                    return this.m_width;
                },
                set: function (value) {
                    this.m_width = value;
                },
                enumerable: true,
                configurable: true
            });
            Size.Empty = new Size(0, 0);
            return Size;
        })();
        Drawing.Size = Size;

        var StringFormat = (function () {
            function StringFormat() {
            }
            Object.defineProperty(StringFormat.prototype, "Alignment", {
                get: function () {
                    return this.m_alignment;
                },
                set: function (value) {
                    this.m_alignment = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(StringFormat.prototype, "LineAlignment", {
                get: function () {
                    return this.m_linealignment;
                },
                set: function (value) {
                    this.m_linealignment = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(StringFormat.prototype, "Trimming", {
                get: function () {
                    return this.m_trimming;
                },
                set: function (value) {
                    this.m_trimming = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(StringFormat.prototype, "ToSVGTextAnchor", {
                get: function () {
                    switch (this.m_alignment) {
                        case 2 /* Near */:
                            return "start";
                        case 0 /* Center */:
                            return "middle";
                        case 1 /* Far */:
                            return "end";
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(StringFormat.prototype, "ToCSSAlignment", {
                get: function () {
                    switch (this.m_alignment) {
                        case 2 /* Near */:
                            return "left";
                        case 0 /* Center */:
                            return "center";
                        case 1 /* Far */:
                            return "right";
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(StringFormat.prototype, "ToCSSLineAlign", {
                get: function () {
                    switch (this.m_linealignment) {
                        case 2 /* Near */:
                            return "top";
                        case 0 /* Center */:
                            return "middle";
                        case 1 /* Far */:
                            return "bottom";
                    }
                },
                enumerable: true,
                configurable: true
            });
            return StringFormat;
        })();
        Drawing.StringFormat = StringFormat;

        (function (StringAlignment) {
            StringAlignment[StringAlignment["Center"] = 0] = "Center";
            StringAlignment[StringAlignment["Far"] = 1] = "Far";
            StringAlignment[StringAlignment["Near"] = 2] = "Near";
        })(Drawing.StringAlignment || (Drawing.StringAlignment = {}));
        var StringAlignment = Drawing.StringAlignment;

        (function (StringFormatFlags) {
            StringFormatFlags[StringFormatFlags["DirectionRightToLeft"] = 0] = "DirectionRightToLeft";
            StringFormatFlags[StringFormatFlags["DirectionVertical"] = 1] = "DirectionVertical";
            StringFormatFlags[StringFormatFlags["DisplayFormatControl"] = 2] = "DisplayFormatControl";
            StringFormatFlags[StringFormatFlags["FitBlackBox"] = 3] = "FitBlackBox";
            StringFormatFlags[StringFormatFlags["LineLimit"] = 4] = "LineLimit";
            StringFormatFlags[StringFormatFlags["MeasureTrailingSpaces"] = 5] = "MeasureTrailingSpaces";
            StringFormatFlags[StringFormatFlags["NoClip"] = 6] = "NoClip";
            StringFormatFlags[StringFormatFlags["NoFontFallback"] = 7] = "NoFontFallback";
            StringFormatFlags[StringFormatFlags["NoWrap"] = 8] = "NoWrap";
        })(Drawing.StringFormatFlags || (Drawing.StringFormatFlags = {}));
        var StringFormatFlags = Drawing.StringFormatFlags;
        (function (StringTrimming) {
            StringTrimming[StringTrimming["Character"] = 0] = "Character";
            StringTrimming[StringTrimming["EllipsisCharacter"] = 1] = "EllipsisCharacter";
            StringTrimming[StringTrimming["EllipsisPath"] = 2] = "EllipsisPath";
            StringTrimming[StringTrimming["EllipsisWord"] = 3] = "EllipsisWord";
            StringTrimming[StringTrimming["None"] = 4] = "None";
            StringTrimming[StringTrimming["Word"] = 5] = "Word";
        })(Drawing.StringTrimming || (Drawing.StringTrimming = {}));
        var StringTrimming = Drawing.StringTrimming;
        (function (StringUnit) {
            StringUnit[StringUnit["Display"] = 0] = "Display";
            StringUnit[StringUnit["Document"] = 1] = "Document";
            StringUnit[StringUnit["Em"] = 2] = "Em";
            StringUnit[StringUnit["Inch"] = 3] = "Inch";
            StringUnit[StringUnit["Millimeter"] = 4] = "Millimeter";
            StringUnit[StringUnit["Pixel"] = 5] = "Pixel";
            StringUnit[StringUnit["Point"] = 6] = "Point";
            StringUnit[StringUnit["World"] = 7] = "World";
        })(Drawing.StringUnit || (Drawing.StringUnit = {}));
        var StringUnit = Drawing.StringUnit;
        var StructFormat;
        (function (StructFormat) {
            StructFormat[StructFormat["Ansi"] = 0] = "Ansi";
            StructFormat[StructFormat["Auto"] = 1] = "Auto";
            StructFormat[StructFormat["Unicode"] = 2] = "Unicode";
        })(StructFormat || (StructFormat = {}));

        //export class SystemBrushes
        //{
        //    static get Highlight(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(SystemColors.Highlight);
        //    }
        //    static get Window(): System.Drawing.Brush
        //    {
        //        return new SolidBrush(SystemColors.Window);
        //    }
        //}
        // TODO: look up real system colors
        var SystemColors = (function () {
            function SystemColors() {
            }
            Object.defineProperty(SystemColors, "Window", {
                get: function () {
                    return Color.White;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SystemColors, "WindowFrame", {
                get: function () {
                    return Color.Gray;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SystemColors, "WindowText", {
                get: function () {
                    return Color.Black;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SystemColors, "Highlight", {
                get: function () {
                    return Color.Yellow;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SystemColors, "HighlightText", {
                get: function () {
                    return Color.White;
                },
                enumerable: true,
                configurable: true
            });
            return SystemColors;
        })();
        Drawing.SystemColors = SystemColors;
    })(System.Drawing || (System.Drawing = {}));
    var Drawing = System.Drawing;
})(System || (System = {}));
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TextHeightMultiplier = 1.1;

var Microsoft;
(function (Microsoft) {
    (function (Treemap) {
        (function (Util) {
            var Diag = System.Diagnostics;

            //*****************************************************************************
            //	Class: FontForRectangle
            //
            /// <summary>
            ///	Provides a Font object to use for drawing text inside a rectangle.
            /// </summary>
            ///
            /// <remarks>
            /// Specify font information in the constructor.  You can then call <see
            /// cref="CanFitInRectangle" /> or <see cref="CanFitInRectangleTruncate" /> to
            /// determine whether the font can be used to draw specified text inside a
            /// specified rectangle without exceeding the rectangle's bounds.
            ///
            /// <para>
            ///	Call <see cref="Dispose()" /> when you are done using the object.
            /// </para>
            ///
            ///	</remarks>
            //*****************************************************************************
            var FontForRectangle = (function () {
                //*************************************************************************
                //	Constructor: FontForRectangle()
                //
                /// <summary>
                /// Initializes a new instance of the FontForRectangle class.
                /// </summary>
                ///
                /// <param name="sFamily">
                /// Font family.
                /// </param>
                ///
                /// <param name="fEmSize">
                /// Font size.
                /// </param>
                ///
                ///	<param name="oGraphics">
                /// Object that will use the font.
                /// </param>
                //*************************************************************************
                function FontForRectangle(sFamily, fEmSize, displayRoot) {
                    Diag.Debug.AssertNotEmpty(sFamily);
                    Diag.Debug.Assert(fEmSize > 0);
                    Diag.Debug.Assert(displayRoot != null);

                    // Create the font.
                    this.m_oFont = new System.Drawing.Font(sFamily, fEmSize);

                    this.AssertValid();
                }
                //*************************************************************************
                //	Method: CanFitInRectangle()
                //
                /// <summary>
                ///	Determines whether the font can be used to draw the specified text
                ///	inside the specified rectangle without exceeding the rectangle's
                ///	bounds.
                /// </summary>
                ///
                /// <param name="sText">
                /// Text that will be drawn in <paramref name="oRectangle" />.
                /// </param>
                ///
                /// <param name="oRectangle">
                /// Rectangle that <paramref name="sText" /> will be drawn in.
                /// </param>
                ///
                ///	<param name="oGraphics">
                /// Object the caller will use to draw the text.
                /// </param>
                ///
                /// <returns>
                ///	true if the font can be used to draw <paramref name="sText" /> into
                /// <paramref name="oRectangle" />.
                /// </returns>
                //*************************************************************************
                FontForRectangle.prototype.CanFitInRectangle = function (sText, oRectangle, displayRoot) {
                    Diag.Debug.Assert(sText != null);
                    Diag.Debug.Assert(displayRoot != null);
                    this.AssertValid();

                    var temp = displayRoot.append("text").text(sText).position(oRectangle.X, oRectangle.Y).font(this.m_oFont.Name, this.m_oFont.Size + "pt");

                    var fCanFit = (temp.width() < oRectangle.Width && temp.height() < oRectangle.Height);

                    temp.remove();

                    return fCanFit;
                };

                //*************************************************************************
                //	Method: CanFitInRectangleTruncate()
                //
                /// <summary>
                ///	Determines whether the font can be used to draw the specified text or
                /// a truncated version of the text inside the specified rectangle without
                /// exceeding the rectangle's bounds.
                /// </summary>
                ///
                /// <param name="sText">
                /// Text that will be drawn in <paramref name="oRectangle" />.  This may
                /// get replaced with a truncated version of the text.
                /// </param>
                ///
                /// <param name="oRectangle">
                /// Rectangle that <paramref name="sText" /> will be drawn in.
                /// </param>
                ///
                ///	<param name="oGraphics">
                /// Object the caller will use to draw the text.
                /// </param>
                ///
                /// <returns>
                ///	true if the font can be used to draw <paramref name="sText" /> or a
                /// truncated version of <paramref name="sText" /> into <paramref
                /// name="oRectangle" />.
                /// </returns>
                ///
                /// <remarks>
                /// If the font can be used to draw <paramref name="sText" /> into
                /// <paramref name="oRectangle" />, true is returned.  Otherwise, if a
                /// truncated version of <paramref name="sText" /> fits into <paramref
                /// name="oRectangle" />, the truncated text is stored at <paramref
                /// name="sText" /> and true is returned.  Otherwise, false is returned.
                /// </remarks>
                //*************************************************************************
                FontForRectangle.prototype.CanFitInRectangleTruncate = function (sText, oRectangle, displayRoot) {
                    Diag.Debug.Assert(sText != null);
                    Diag.Debug.Assert(displayRoot != null);
                    this.AssertValid();

                    // Try the text as is.
                    if (this.CanFitInRectangle(sText, oRectangle, displayRoot))
                        return sText;

                    // Truncate the text and try again.
                    var sTruncatedText = this.TruncateText(sText);

                    if (this.CanFitInRectangle(sTruncatedText, oRectangle, displayRoot)) {
                        return sTruncatedText;
                    }

                    return null;
                };

                Object.defineProperty(FontForRectangle.prototype, "Font", {
                    //*************************************************************************
                    //	Property: Font
                    //
                    /// <summary>
                    /// Gets the font represented by the object.
                    /// </summary>
                    ///
                    /// <value>
                    /// The <see cref="Font" /> represented by the object.
                    /// </value>
                    //*************************************************************************
                    get: function () {
                        this.AssertValid();

                        return (this.m_oFont);
                    },
                    enumerable: true,
                    configurable: true
                });

                //*************************************************************************
                //	Method: TruncateText()
                //
                /// <summary>
                /// Attempts to truncate text.
                /// </summary>
                ///
                /// <param name="sText">
                /// Text to truncate.
                /// </param>
                ///
                /// <param name="sTruncatedText">
                /// Where the truncated text gets stored if true is returned.
                /// </param>
                ///
                /// <returns>
                /// true if the text can be truncated.
                /// </returns>
                ///
                /// <remarks>
                /// If <paramref name="sText" /> can be truncated, the truncated version is
                /// stored at <paramref name="sTruncatedText" /> and true is returned.
                /// false is returned otherwise.
                /// </remarks>
                //*************************************************************************
                FontForRectangle.prototype.TruncateText = function (sText) {
                    Diag.Debug.Assert(sText != null);
                    this.AssertValid();

                    if (sText.length < FontForRectangle.MinTruncatableTextLength) {
                        return null;
                    }

                    var sTruncatedText = sText.substring(0, FontForRectangle.MinTruncatableTextLength - 1) + "...";

                    return sTruncatedText;
                };

                //*************************************************************************
                //	Method: AssertValid()
                //
                /// <summary>
                ///	Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                FontForRectangle.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_oFont != null);
                };

                FontForRectangle.MinTruncatableTextLength = 4;
                return FontForRectangle;
            })();
            Util.FontForRectangle = FontForRectangle;

            

            

            

            //*****************************************************************************
            //	Class: MaximizingFontMapper
            //
            /// <summary>
            ///	Provides the largest possible Font object to use for drawing a node's text.
            /// </summary>
            ///
            /// <remarks>
            ///	Specify a range of font sizes to use in the constructor.  You can then call
            /// <see cref="NodeToFont" /> to get a Font object for drawing a node's text.
            /// The returned font is the largest within the specified font range that
            /// doesn't exceed the bounds of the node's rectangle.
            ///
            /// <para>
            ///	Call <see cref="Dispose()" /> when you are done using the object.
            /// </para>
            ///
            ///	</remarks>
            //*****************************************************************************
            var MaximizingFontMapper = (function () {
                //*************************************************************************
                //	Constructor: MaximizingFontMapper()
                //
                /// <summary>
                /// Initializes a new instance of the MaximizingFontMapper class.
                /// </summary>
                ///
                /// <param name="sFamily">
                /// Font family.
                /// </param>
                ///
                /// <param name="fMinSizePt">
                /// Minimum font size, in points.
                /// </param>
                ///
                /// <param name="fMaxSizePt">
                /// Maximum font size, in points.
                /// </param>
                ///
                /// <param name="fIncrementPt">
                /// Increment between fonts.
                /// </param>
                ///
                /// <param name="oGraphics">
                /// Object the caller will use to draw the node's text.
                /// </param>
                //*************************************************************************
                function MaximizingFontMapper(sFamily, fMinSizePt, fMaxSizePt, fIncrementPt, displayRoot) {
                    Diag.Debug.AssertNotEmpty(sFamily);
                    Diag.Debug.Assert(displayRoot != null);

                    // Check the arguments.
                    MaximizingFontMapper.ValidateSizeRange(fMinSizePt, fMaxSizePt, fIncrementPt, "MaximizingFontMapper.Initialize()");

                    // Create an array and add a set of FontForRectangle objects to it,
                    // ordered by decreasing font size.
                    this.m_oFontForRectangles = new Array();

                    for (var fSizePt = fMinSizePt; fSizePt <= fMaxSizePt; fSizePt += fIncrementPt) {
                        var oFontForRectangle = new FontForRectangle(sFamily, fSizePt, displayRoot);

                        this.m_oFontForRectangles.splice(0, 0, oFontForRectangle);
                    }

                    this.m_displayRoot = displayRoot;

                    this.AssertValid();
                }
                //*************************************************************************
                //	Method: NodeToFont()
                //
                /// <summary>
                ///	Returns a Font object to use for drawing a node's text.
                /// </summary>
                ///
                /// <param name="oNode">
                /// The node that needs to be drawn.
                /// </param>
                ///
                /// <param name="iNodeLevel">
                /// Node level.  Top-level nodes are at level 0.
                /// </param>
                ///
                /// <param name="oGraphics">
                /// Object the caller will use to draw the node's text.
                /// </param>
                ///
                /// <param name="oFont">
                /// Where the font gets stored.  The font is owned by the object
                /// implementing this interface.  Do not call the font's Dispose() method.
                /// </param>
                ///
                /// <param name="sTextToDraw">
                /// Where the text to draw gets stored.  This is either the node's text or
                /// an abbreviated form of the node's text.
                /// </param>
                ///
                /// <returns>
                /// true if an appropriate font was found, false if not.
                /// </returns>
                ///
                /// <remarks>
                /// If a Font object suitable for drawing the text for <paramref
                /// name="oNode" /> is available, the font is stored at <paramref
                /// name="oFont" />, the text to draw is stored at <paramref
                /// name="sTextToDraw" />, and true is returned.  false if returned
                /// otherwise.
                /// </remarks>
                //*************************************************************************
                MaximizingFontMapper.prototype.NodeToFont = function (oNode, oRect, iNodeLevel, sTextToDraw) {
                    Diag.Debug.Assert(oNode != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);
                    this.AssertValid();

                    var sText = oNode.Text;

                    for (var iFontForRectangle = 0; iFontForRectangle < this.m_oFontForRectangles.length; iFontForRectangle++) {
                        var oFontForRectangle = this.m_oFontForRectangles[iFontForRectangle];

                        if (oFontForRectangle.CanFitInRectangle(sText, oRect, this.m_displayRoot)) {
                            sTextToDraw = sText;

                            // TODO: fix out parameter
                            return oFontForRectangle.Font;
                        }
                    }

                    // No font was found.
                    sTextToDraw = null;

                    return null;
                };

                //*************************************************************************
                //	Method: ValidateSizeRange()
                //
                /// <summary>
                ///	Throws an exception if one of the parameters is invalid.
                /// </summary>
                ///
                /// <param name="fMinSizePt">
                /// Minimum font size, in points.  Must be > 0.
                /// </param>
                ///
                /// <param name="fMaxSizePt">
                /// Maximum font size, in points.  Must be > 0 and >= fMinSizePt.
                /// </param>
                ///
                /// <param name="fIncrementPt">
                /// Increment between fonts.  Must be > 0.
                /// </param>
                ///
                /// <param name="sCaller">
                /// Name of the caller.  Used in exception messages.  Sample:
                ///	"MaximizingFontMapper.Initialize()".
                /// </param>
                //*************************************************************************
                MaximizingFontMapper.ValidateSizeRange = function (fMinSizePt, fMaxSizePt, fIncrementPt, sCaller) {
                    if (fMinSizePt <= 0) {
                        throw new System.ArgumentOutOfRangeException("fMinSizePt", fMinSizePt, sCaller + ": fMinSizePt must be > 0.");
                    }

                    if (fMaxSizePt <= 0) {
                        throw new System.ArgumentOutOfRangeException("fMaxSizePt", fMaxSizePt, sCaller + ": fMaxSizePt must be > 0.");
                    }

                    if (fMaxSizePt < fMinSizePt) {
                        throw new System.ArgumentOutOfRangeException("fMaxSizePt", fMaxSizePt, sCaller + ": fMaxSizePt must be >= fMinSizePt.");
                    }

                    if (fIncrementPt <= 0) {
                        throw new System.ArgumentOutOfRangeException("fIncrementPt", fIncrementPt, sCaller + ": fIncrementPt must be > 0.");
                    }
                };

                //*************************************************************************
                //	Method: AssertValid()
                //
                /// <summary>
                /// AssertValid method.
                /// </summary>
                ///
                /// <remarks>
                ///	Asserts if the object is in an invalid state.  Debug-only.
                /// </remarks>
                //*************************************************************************
                MaximizingFontMapper.prototype.AssertValid = function () {
                };
                return MaximizingFontMapper;
            })();
            Util.MaximizingFontMapper = MaximizingFontMapper;

            //*****************************************************************************
            //	Class: PerLevelFontMapper
            //
            /// <summary>
            ///	Provides a Font object to use for drawing a node's text.
            /// </summary>
            ///
            /// <remarks>
            /// Specify a font family and a treemap rectangle in the constructor, then call
            /// <see cref="NodeToFont" /> to get a Font object for drawing a node's text.
            /// The size of the font is determined by the node's level and by the size of
            /// the treemap rectangle.
            ///
            /// <para>
            ///	Call <see cref="Dispose()" /> when you are done using the object.
            /// </para>
            ///
            ///	</remarks>
            //*****************************************************************************
            var PerLevelFontMapper = (function () {
                //*************************************************************************
                //	Constructor: PerLevelFontMapper()
                //
                /// <summary>
                /// Initializes a new instance of the PerLevelFontMapper class.
                /// </summary>
                ///
                /// <param name="sFamily">
                /// Font family.
                /// </param>
                ///
                /// <param name="oTreemapRectangle">
                /// Treemap's outer rectangle.
                /// </param>
                ///
                /// <param name="fTreemapRectangleDivisor">
                /// The font size for level 0 is the treemap rectangle height divided by
                /// fTreemapRectangleDivisor.
                /// </param>
                ///
                /// <param name="fPerLevelDivisor">
                /// The font size for level N is the font size for level N-1 divided by
                /// fPerLevelDivisor.
                /// </param>
                ///
                /// <param name="fMinimumFontSize">
                /// Minimum font size.
                /// </param>
                ///
                /// <param name="oGraphics">
                /// Object the caller will use to draw the node's text.
                /// </param>
                //*************************************************************************
                function PerLevelFontMapper(sFamily, oTreemapRectangle, fTreemapRectangleDivisor, fPerLevelDivisor, fMinimumFontSize, displayRoot) {
                    Diag.Debug.AssertNotEmpty(sFamily);
                    Diag.Debug.Assert(fTreemapRectangleDivisor > 0);
                    Diag.Debug.Assert(fPerLevelDivisor > 0);
                    Diag.Debug.Assert(fMinimumFontSize > 0);
                    Diag.Debug.Assert(displayRoot != null);

                    // The largest font is determined by the height of the treemap
                    // rectangle.
                    var fFontSize = oTreemapRectangle.Height / fTreemapRectangleDivisor;

                    // Create an array and add a set of FontForRectangle objects to it,
                    // one per treemap level.  Stop when the font gets too small.
                    this.m_oFontForRectangles = new Array();

                    while (fFontSize > fMinimumFontSize) {
                        var oFontForRectangle = new FontForRectangle(sFamily, fFontSize, displayRoot);

                        this.m_oFontForRectangles.push(oFontForRectangle);

                        fFontSize /= fPerLevelDivisor;
                    }

                    this.m_displayRoot = displayRoot;

                    this.AssertValid();
                }
                //*************************************************************************
                //	Method: NodeToFont()
                //
                /// <summary>
                ///	Returns a Font object to use for drawing a node's text.
                /// </summary>
                ///
                /// <param name="oNode">
                /// The node that needs to be drawn.
                /// </param>
                ///
                /// <param name="iNodeLevel">
                /// Node level.  Top-level nodes are at level 0.
                /// </param>
                ///
                /// <param name="oGraphics">
                /// Object the caller will use to draw the node's text.
                /// </param>
                ///
                /// <param name="oFont">
                /// Where the font gets stored.  The font is owned by the object
                /// implementing this interface.  Do not call the font's Dispose() method.
                /// </param>
                ///
                /// <param name="sTextToDraw">
                /// Where the text to draw gets stored.  This is either the node's text or
                /// an abbreviated form of the node's text.
                /// </param>
                ///
                /// <returns>
                /// true if an appropriate font was found, false if not.
                /// </returns>
                ///
                /// <remarks>
                /// If a Font object suitable for drawing the text for <paramref
                /// name="oNode" /> is available, the font is stored at <paramref
                /// name="oFont" />, the text to draw is stored at <paramref
                /// name="sTextToDraw" />, and true is returned.  false if returned
                /// otherwise.
                /// </remarks>
                //*************************************************************************
                PerLevelFontMapper.prototype.NodeToFont = function (oNode, oRect, iNodeLevel, sTextToDraw) {
                    Diag.Debug.Assert(oNode != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);
                    this.AssertValid();

                    if (iNodeLevel < this.m_oFontForRectangles.length) {
                        // Get the FontForRectangle object for the specified node level.
                        var oFontForRectangle = this.m_oFontForRectangles[iNodeLevel];

                        // Check whether this font can be used to draw the text within the
                        // node's rectangle.
                        var sText = oNode.Text;

                        if (oFontForRectangle.CanFitInRectangle(sText, oRect, this.m_displayRoot)) {
                            sTextToDraw = sText;

                            // TODO: fix out param
                            return oFontForRectangle.Font;
                        }
                    }

                    // There is no appropriate font.
                    sTextToDraw = null;

                    return null;
                };

                //*************************************************************************
                //	Method: AssertValid()
                //
                /// <summary>
                /// Asserts if the object is in an invalid state.  Debug-only.
                /// </summary>
                //*************************************************************************
                PerLevelFontMapper.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_oFontForRectangles != null);
                };
                return PerLevelFontMapper;
            })();
            Util.PerLevelFontMapper = PerLevelFontMapper;

            //*****************************************************************************
            //	Class: LayoutEngineBase
            //
            /// <summary>
            /// Abstract base class for derived classes that lay out the rectangles in a
            /// treemap.
            /// </summary>
            ///
            /// <remarks>
            /// This can be used as the base class for a derived class that lays out the
            /// rectangles in a treemap.  It implements <see
            /// cref="ILayoutEngine.SetNodeRectanglesToEmpty(Node)" /> but leaves the
            /// implementation of <see cref="ILayoutEngine.CalculateNodeRectangles" /> to
            /// the derived class.
            /// </remarks>
            //*****************************************************************************
            var LayoutEngineBase = (function () {
                function LayoutEngineBase() {
                }
                //*************************************************************************
                //    Method: CalculateNodeRectangles()
                //
                /// <summary>
                /// Calculates and sets the <see cref="Node.Rectangle" /> property on each
                /// <see cref="Node" /> in a node collection.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of sibling <see cref="Node" /> objects.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="oParentNode">
                /// Parent of <paramref name="oNodes" />, or null if <paramref
                /// name="oNodes" /> is the treemap's top-level node collection.
                /// </param>
                ///
                /// <param name="eEmptySpaceLocation">
                /// Determines where the empty space is placed within <paramref
                /// name="oParentRectangle" /> if oNodes.EmptySpace.<see
                /// cref="EmptySpace.SizeMetric" /> is positive.
                /// </param>
                ///
                /// <remarks>
                /// This method uses an implementation-specific algorithm to set the <see
                /// cref="Node.Rectangle" /> property on each <see cref="Node" /> object in
                /// <paramref name="oNodes" /> so that all the rectangles fit within
                /// <paramref name="oParentRectangle" /> and do not overlap.  In one call,
                /// it deals with just one set of sibling nodes and one parent rectangle.
                /// To create a complete nested treemap, call this method for the treemap's
                /// top-level nodes, then again for each node's set of child nodes, again
                /// for their children, and so on.
                ///
                /// <para>
                ///    The calculated rectangles have borders with zero widths.  If oNodeB is
                /// immediately to the right of oNodeA, for example, then
                ///    oNodeA.Rectangle.Right == oNodeB.Rectangle.Left.  The rectangles have
                ///    no padding.
                /// </para>
                ///
                ///    </remarks>
                //*************************************************************************
                LayoutEngineBase.prototype.CalculateNodeRectangles = function (oNodes, oParentRectangle, oParentNode, eEmptySpaceLocation) {
                };

                //*************************************************************************
                //    Method: SetNodeRectanglesToEmpty()
                //
                /// <summary>
                /// Sets the <see cref="Node.Rectangle" /> property on a <see
                /// cref="Node" /> and all its descendants to an empty rectangle.
                /// </summary>
                ///
                /// <param name="oNode">
                /// <see cref="Node" /> object to set the <see cref="Node.Rectangle" />
                /// property on.
                /// </param>
                //*************************************************************************
                LayoutEngineBase.prototype.SetNodeRectanglesToEmpty = function (oNode) {
                    Diag.Debug.Assert(oNode != null);

                    this.SetNodeRectangleToEmpty(oNode);
                    this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                };

                //*************************************************************************
                //    Method: SetNodeRectanglesToEmpty()
                //
                /// <overloads>
                /// Sets the <see cref="Node.Rectangle" /> property on nodes in a node
                /// collection to an empty rectangle.
                /// </overloads>
                ///
                /// <summary>
                /// Sets the <see cref="Node.Rectangle" /> property on each <see
                /// cref="Node" /> in a node collection to an empty rectangle.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of sibling <see cref="Node" /> objects.
                /// </param>
                ///
                /// <param name="bRecursive">
                /// If true, the rectangles for all descendent nodes are also set to empty
                /// rectangles.
                /// </param>
                ///
                /// <remarks>
                /// This method sets the <see cref="Node.Rectangle" /> property on each
                /// <see cref="Node" /> object in <paramref name="oNodes" /> to an empty
                /// rectangle.  If <paramref name="bRecursive" /> is true, it then does the
                /// same to all descendent nodes.
                /// </remarks>
                //*************************************************************************
                LayoutEngineBase.prototype.SetNodesRectanglesToEmpty = function (oNodes, bRecursive) {
                    Diag.Debug.Assert(oNodes != null);

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        this.SetNodeRectangleToEmpty(oNode);

                        if (bRecursive)
                            this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                    }
                };

                //*************************************************************************
                //  Method: SetNodeRectanglesToEmpty()
                //
                /// <summary>
                /// Sets the <see cref="Node.Rectangle" /> property on specified nodes in
                /// a node collection to an empty rectangle.
                /// </summary>
                ///
                /// <param name="aoNodes">
                /// Array of <see cref="Node" /> objects.
                /// </param>
                ///
                ///    <param name="iIndexOfFirstNodeToSet">
                ///    Index of the first node in <paramref name="aoNodes" /> to set to empty.
                ///    </param>
                ///
                ///    <param name="iIndexOfLastNodeToSet">
                ///    Index of the last node in <paramref name="aoNodes" /> to set to empty.
                ///    </param>
                ///
                /// <remarks>
                /// This helper method can be used by derived classes.  It sets the <see
                /// cref="Node.Rectangle" /> property on each specified node to an empty
                /// rectangle.  It then does the same for all descendents of the specified
                /// nodes.
                /// </remarks>
                //*************************************************************************
                LayoutEngineBase.prototype.SetANodeRectanglesToEmpty = function (aoNodes, iIndexOfFirstNodeToSet, iIndexOfLastNodeToSet) {
                    Diag.Debug.Assert(aoNodes != null);
                    Diag.Debug.Assert(iIndexOfFirstNodeToSet >= 0);
                    Diag.Debug.Assert(iIndexOfFirstNodeToSet < aoNodes.length);
                    Diag.Debug.Assert(iIndexOfLastNodeToSet >= 0);
                    Diag.Debug.Assert(iIndexOfLastNodeToSet < aoNodes.length);

                    for (var i = iIndexOfFirstNodeToSet; i <= iIndexOfLastNodeToSet; i++) {
                        var oNode = aoNodes[i];

                        this.SetNodeRectangleToEmpty(oNode);

                        // Recurse into the node's children.
                        this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                    }
                };

                //*************************************************************************
                //    Method: SetNodeRectangleToEmpty()
                //
                /// <summary>
                /// Sets the <see cref="Node.Rectangle" /> property on a specified node to
                /// an empty rectangle.
                /// </summary>
                ///
                /// <param name="oNode">
                /// <see cref="Node" /> object.
                /// </param>
                ///
                /// <remarks>
                /// This method sets the <see cref="Node.Rectangle" /> property on
                /// <paramref name="oNode" /> to an empty rectangle.
                /// </remarks>
                //*************************************************************************
                LayoutEngineBase.prototype.SetNodeRectangleToEmpty = function (oNode) {
                    Diag.Debug.Assert(oNode != null);

                    oNode.RemoveRectangle();
                    oNode.RemoveText();
                    var elem = oNode.DisplayedElement;
                    if (elem) {
                        elem.remove();
                        oNode.DisplayedElement = null;
                    }
                    oNode.Rectangle = System.Drawing.Rectangle.FromLTRB(0, 0, 0, 0);
                };
                return LayoutEngineBase;
            })();
            Util.LayoutEngineBase = LayoutEngineBase;

            //*****************************************************************************
            //	Class: SquarifiedLayoutEngine
            //
            /// <summary>
            ///	Lays out the rectangles in a treemap using a squarified algorithm.
            /// </summary>
            ///
            /// <remarks>
            /// This class lays out a treemap's rectangles so they are as square as
            /// possible.  The code is based on an algorithm presented in "Squarified
            /// Treemaps," by Mark Bruls, Kees Huizing, and Jarke J. van Wijk.
            ///	</remarks>
            //*****************************************************************************
            var SquarifiedLayoutEngine = (function (_super) {
                __extends(SquarifiedLayoutEngine, _super);
                //*************************************************************************
                //	Constructor: SquarifiedLayoutEngine()
                //
                /// <summary>
                /// Initializes a new instance of the SquarifiedLayoutEngine class.
                /// </summary>
                ///
                /// <param name="bBottomWeighted">
                /// If true, larger child nodes are placed in the lower left corner of the
                /// parent rectangle.  If false, larger child nodes are placed in the upper
                /// left corner.
                /// </param>
                //*************************************************************************
                function SquarifiedLayoutEngine(bBottomWeighted) {
                    _super.call(this);
                    this.m_bBottomWeighted = bBottomWeighted;
                }
                //*************************************************************************
                //	Method: CalculateNodeRectangles()
                //
                /// <summary>
                /// Calculates and sets the <see cref="Node.Rectangle" /> property on each
                /// <see cref="Node" /> in a node collection.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of sibling <see cref="Node" /> objects.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="oParentNode">
                /// Parent of <paramref name="oNodes" />, or null if <paramref
                /// name="oNodes" /> is the treemap's top-level node collection.
                /// </param>
                ///
                /// <param name="eEmptySpaceLocation">
                /// Determines where the empty space is placed within <paramref
                /// name="oParentRectangle" /> if oNodes.EmptySpace.<see
                /// cref="EmptySpace.SizeMetric" /> is positive.
                /// </param>
                ///
                /// <remarks>
                /// This method uses an implementation-specific algorithm to set the <see
                /// cref="Node.Rectangle" /> property on each <see cref="Node" /> object in
                /// <paramref name="oNodes" /> so that all the rectangles fit within
                /// <paramref name="oParentRectangle" /> and do not overlap.  In one call,
                /// it deals with just one set of sibling nodes and one parent rectangle.
                /// To create a complete nested treemap, call this method for the treemap's
                /// top-level nodes, then again for each node's set of child nodes, again
                /// for their children, and so on.
                ///
                /// <para>
                ///	The calculated rectangles have borders with zero widths.  If oNodeB is
                /// immediately to the right of oNodeA, for example, then
                ///	oNodeA.Rectangle.Right == oNodeB.Rectangle.Left.  The rectangles have
                ///	no padding.
                /// </para>
                ///
                ///	</remarks>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.CalculateNodeRectangles = function (oNodes, oParentRectangle, oParentNode, eEmptySpaceLocation) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(oParentRectangle.Width > 0);
                    Diag.Debug.Assert(oParentRectangle.Height > 0);

                    if (oNodes.Count == 0)
                        return;

                    // Sort the nodes by their SizeMetric property.
                    var aoSortedNodes = oNodes.ToArraySortedBySizeMetric();

                    // Get the area that will be taken up by each SizeMetric unit.
                    var dAreaPerSizeMetric = this.GetAreaPerSizeMetric(oNodes, oParentRectangle, oParentNode);

                    if (dAreaPerSizeMetric == 0) {
                        // The nodes in oNodes should not be drawn.
                        this.SetNodesRectanglesToEmpty(oNodes, true);
                        return;
                    }

                    if (eEmptySpaceLocation == 1 /* Top */ && oNodes.EmptySpace.SizeMetric > 0) {
                        // The caller wants to force the empty space specified by
                        // oNodes.EmptySpace to the top of the parent rectangle.  Figure
                        // out the area and width of the empty space.
                        var dEmptySpaceArea = dAreaPerSizeMetric * oNodes.EmptySpace.SizeMetric;

                        Diag.Debug.Assert(oParentRectangle.Width > 0);

                        var dEmptySpaceHeight = dEmptySpaceArea / oParentRectangle.Width;

                        // Subtract the empty space from the parent rectangle.
                        oParentRectangle = System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oParentRectangle.Top + dEmptySpaceHeight, oParentRectangle.Right, oParentRectangle.Bottom);

                        if (oParentRectangle.Height <= 0) {
                            // The nodes in oNodes should not be drawn.
                            this.SetNodesRectanglesToEmpty(oNodes, true);
                            return;
                        }
                    }

                    // Calculate a squarified rectangle for each node.
                    this.CalculateSquarifiedNodeRectangles(aoSortedNodes, oParentRectangle, dAreaPerSizeMetric);

                    for (var iNode = 0; iNode < aoSortedNodes.length; iNode++) {
                        var oNode = aoSortedNodes[iNode];
                        var oRectangle = oNode.Rectangle;

                        Diag.Debug.Assert(oRectangle.Width >= 0);
                        Diag.Debug.Assert(oRectangle.Height >= 0);
                    }
                };

                //*************************************************************************
                //	Method: CalculateSquarifiedNodeRectangles()
                //
                /// <summary>
                ///	This protected method does most of the work for <see
                /// cref="CalculateNodeRectangles" />.
                /// </summary>
                ///
                /// <param name="aoSortedNodes">
                /// Array of <see cref="Node" /> objects.  Contains a complete set of
                /// sibling nodes, sorted by Node.SizeMetric in descending order.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="dAreaPerSizeMetric">
                /// Area that will be taken up by each SizeMetric unit.
                /// </param>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.CalculateSquarifiedNodeRectangles = function (aoSortedNodes, oParentRectangle, dAreaPerSizeMetric) {
                    Diag.Debug.Assert(aoSortedNodes != null);
                    Diag.Debug.Assert(oParentRectangle.Width > 0);
                    Diag.Debug.Assert(oParentRectangle.Height > 0);
                    Diag.Debug.Assert(dAreaPerSizeMetric >= 0);

                    var iNodes = aoSortedNodes.length;

                    // Indexes of nodes that have already been inserted into
                    // oParentRectangle, or -1 if none have been inserted yet.
                    var iIndexOfFirstInsertedNode = -1;
                    var iIndexOfLastInsertedNode = -1;

                    // Index of the next node to insert.
                    var iIndexOfNodeToInsert = 0;

                    // Sum of the SizeMetric values for the nodes that have already been
                    // inserted and the next node to insert.
                    var dSizeMetricSum = 0;

                    // Worst aspect ratio of the nodes that have already been inserted into
                    // oParentRectangle.  Aspect ratios are 1.0 or greater.  1.0 is ideal.
                    // Initialize this to a large value so that any other value will be
                    // better.
                    var dOldWorstAspectRatio = MAX_VALUE;

                    while (iIndexOfNodeToInsert < iNodes) {
                        if (oParentRectangle.IsEmpty) {
                            // This shouldn't happen, but because of rounding errors,
                            // conversions from Doubles to Singles, and use of the
                            // Rectangle.FromLTRB() method (which has to convert its
                            // arguments to an internal Point and Size), it occasionally
                            // does.  Handle it by setting to empty the rectangles for all
                            // nodes that haven't been inserted yet.
                            this.SetANodeRectanglesToEmpty(aoSortedNodes, iIndexOfNodeToInsert, iNodes - 1);

                            return;
                        }

                        var oNodeToInsert = aoSortedNodes[iIndexOfNodeToInsert];
                        var dSizeMetricOfNodeToInsert = oNodeToInsert.SizeMetric;

                        if (dSizeMetricOfNodeToInsert == 0) {
                            // The node has a zero SizeMetric.  Set its rectangle (and
                            // descendents) to empty, then move on to the next node.
                            this.SetANodeRectanglesToEmpty(aoSortedNodes, iIndexOfNodeToInsert, iIndexOfNodeToInsert);

                            iIndexOfNodeToInsert++;
                            continue;
                        }

                        var bNodeWasInsertedBefore = (iIndexOfFirstInsertedNode != -1);

                        if (bNodeWasInsertedBefore) {
                            // Tell all nodes that have already been inserted to save
                            // their rectangles.  Inserting a new node causes the
                            // rectangles for the already-inserted nodes to be
                            // recalculated, and if the new rectangles are worse than the
                            // old ones, the old ones will have to be restored.
                            this.SaveInsertedRectangles(aoSortedNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);
                        }

                        dSizeMetricSum += dSizeMetricOfNodeToInsert;

                        // Insert the new node above, below, or to the right of the already
                        // inserted nodes.
                        this.InsertNodesInRectangle(aoSortedNodes, oParentRectangle, (bNodeWasInsertedBefore ? iIndexOfFirstInsertedNode : iIndexOfNodeToInsert), iIndexOfNodeToInsert, dSizeMetricSum, dAreaPerSizeMetric);

                        // Compute the new worst aspect ratio.  Since the nodes are sorted
                        // by descending SizeMetric values, the newly inserted node has the
                        // worst one.
                        var dNewWorstAspectRatio = oNodeToInsert.AspectRatio;

                        // Has it improved or at least stayed the same?
                        if (dNewWorstAspectRatio <= dOldWorstAspectRatio) {
                            // Yes, so leave the newly inserted node where it is and move
                            // on to the next node.
                            if (bNodeWasInsertedBefore) {
                                iIndexOfLastInsertedNode++;
                            } else {
                                iIndexOfFirstInsertedNode = iIndexOfLastInsertedNode = iIndexOfNodeToInsert;
                            }

                            iIndexOfNodeToInsert++;
                            dOldWorstAspectRatio = dNewWorstAspectRatio;
                        } else {
                            // The insertion of the new node made the aspect ratio worse,
                            // so cancel what we just did.
                            if (bNodeWasInsertedBefore) {
                                this.RestoreInsertedRectangles(aoSortedNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);
                            }

                            // Leave the previously inserted nodes where they are, and get
                            // a rectangle for the remaining empty space.  The next pass
                            // through the loop will take the node that just failed and
                            // insert it into the empty space.
                            oParentRectangle = this.GetRemainingEmptySpace(aoSortedNodes, oParentRectangle, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);

                            iIndexOfFirstInsertedNode = -1;
                            iIndexOfLastInsertedNode = -1;
                            dSizeMetricSum = 0;
                            dOldWorstAspectRatio = MAX_VALUE;
                        }
                    }
                };

                //*************************************************************************
                //	Method: InsertNodesInRectangle()
                //
                /// <summary>
                ///	Inserts a set of nodes into a rectangle.
                /// </summary>
                ///
                /// <param name="aoSortedNodes">
                /// Array of Node objects.  Contains a complete set of sibling nodes,
                /// sorted by Node.SizeMetric in descending order.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="iIndexOfFirstNodeToInsert">
                /// Zero-based index of the first node in <paramref name="aoSortedNodes" />
                /// to insert.
                /// </param>
                ///
                /// <param name="iIndexOfLastNodeToInsert">
                /// Zero-based index of the last node in <paramref name="aoSortedNodes" />
                /// to insert.
                /// </param>
                ///
                /// <param name="dSizeMetricSum">
                /// Sum of the SizeMetric values for the nodes to be inserted.  Must be
                /// greater than zero.
                /// </param>
                ///
                /// <param name="dAreaPerSizeMetric">
                /// Area that will be taken up by each SizeMetric unit.  Must be greater
                /// than or equal to zero.
                /// </param>
                ///
                /// <remarks>
                ///	This method inserts the specified nodes in <paramref
                /// name="aoSortedNodes" /> into <paramref name="oParentRectangle" />.
                ///
                /// <para>
                /// If the rectangle is wider than it is tall, the nodes are inserted on
                /// top of each other so that they fill the left part of the rectangle
                /// either from bottom to top (if m_bBottomWeighted is true) or top to
                /// bottom (if m_bBottomWeighted is false).  That probably leaves some
                /// space on the right side of the rectangle.
                /// </para>
                ///
                /// <para>
                /// If the rectangle is taller than it is wide, the nodes are inserted to
                /// the right of each other so that they fill the bottom (if
                /// m_bBottomWeighted is true) or top (if m_bBottomWeighted is false) of
                /// the rectangle, from left to right.  That probably leaves some space at
                /// the top or bottom of the rectangle.
                /// </para>
                ///
                ///	<para>
                /// The algorithm presented in "Squarified Treemaps," by Mark Bruls, Kees
                /// Huizing, and Jarke J. van Wijk, always inserts larger nodes at the
                /// lower left corner of the parent rectangle.  This method modifies the
                /// algorithm by adding an option to insert larger nodes at the upper left
                /// corner.
                ///	</para>
                ///
                ///	<para>
                ///	Note that the results of this method call may not be optimal.  It's up
                ///	to the caller to determine whether the results are good and to take
                ///	corrective action if they are not.
                ///	</para>
                ///
                /// </remarks>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.InsertNodesInRectangle = function (aoSortedNodes, oParentRectangle, iIndexOfFirstNodeToInsert, iIndexOfLastNodeToInsert, dSizeMetricSum, dAreaPerSizeMetric) {
                    Diag.Debug.Assert(aoSortedNodes != null);
                    Diag.Debug.Assert(oParentRectangle.Width > 0);
                    Diag.Debug.Assert(oParentRectangle.Height > 0);
                    Diag.Debug.Assert(iIndexOfFirstNodeToInsert >= 0);
                    Diag.Debug.Assert(iIndexOfLastNodeToInsert >= 0);
                    Diag.Debug.Assert(iIndexOfLastNodeToInsert >= iIndexOfFirstNodeToInsert);
                    Diag.Debug.Assert(iIndexOfLastNodeToInsert < aoSortedNodes.length);
                    Diag.Debug.Assert(dSizeMetricSum > 0);
                    Diag.Debug.Assert(dAreaPerSizeMetric >= 0);

                    var i;

                    // If the rectangle is wider than it is tall, the nodes will get
                    // inserted from bottom to top or top to bottom.  Otherwise, they will
                    // get inserted from left to right.
                    var bInsertVertically = (oParentRectangle.Width >= oParentRectangle.Height);

                    // Get the rectangle's height or width, whichever is shorter.
                    var dParentHeightOrWidth = bInsertVertically ? oParentRectangle.Height : oParentRectangle.Width;

                    Diag.Debug.Assert(dParentHeightOrWidth != 0);

                    // Compute the area that will be taken up by the nodes.
                    var dNodesArea = dAreaPerSizeMetric * dSizeMetricSum;

                    // Compute the width or height of the nodes.  (They all have the same
                    // width or height.)
                    var dNodeWidthOrHeight = dNodesArea / dParentHeightOrWidth;

                    var dNodeLeft = 0;
                    var dNodeRight = 0;
                    var dNodeTop = 0;
                    var dNodeBottom = 0;

                    if (bInsertVertically) {
                        // Compute the left and right edges of the nodes.  These don't
                        // change.
                        dNodeLeft = oParentRectangle.Left;
                        dNodeRight = dNodeLeft + dNodeWidthOrHeight;

                        // The top and bottom edges will be recalculated for each node.
                        dNodeTop = dNodeBottom = (this.m_bBottomWeighted) ? oParentRectangle.Bottom : oParentRectangle.Top;
                    } else {
                        // Compute the top and bottom edges of the nodes.  These don't
                        // change.
                        if (this.m_bBottomWeighted) {
                            dNodeBottom = oParentRectangle.Bottom;
                            dNodeTop = dNodeBottom - dNodeWidthOrHeight;
                        } else {
                            dNodeTop = oParentRectangle.Top;
                            dNodeBottom = dNodeTop + dNodeWidthOrHeight;
                        }

                        // The left and right edges will be recalculated for each node.
                        dNodeLeft = dNodeRight = oParentRectangle.Left;
                    }

                    for (i = iIndexOfFirstNodeToInsert; i <= iIndexOfLastNodeToInsert; i++) {
                        var oNode = aoSortedNodes[i];

                        // The node's height or width is a fraction of the rectangle's
                        // height or width, where the fraction is determined by the ratio
                        // of the node's SizeMetric value to the sum of values for all the
                        // inserted nodes.
                        Diag.Debug.Assert(dSizeMetricSum != 0);

                        var dNodeHeightOrWidth = dParentHeightOrWidth * (oNode.SizeMetric / dSizeMetricSum);

                        if (bInsertVertically) {
                            if (this.m_bBottomWeighted) {
                                dNodeTop = dNodeBottom - dNodeHeightOrWidth;
                            } else {
                                dNodeBottom = dNodeTop + dNodeHeightOrWidth;
                            }
                        } else {
                            dNodeRight = dNodeLeft + dNodeHeightOrWidth;
                        }

                        oNode.Rectangle = System.Drawing.Rectangle.FromLTRB(dNodeLeft, dNodeTop, dNodeRight, dNodeBottom);

                        Diag.Debug.Assert(oNode.Rectangle.Width >= 0);
                        Diag.Debug.Assert(oNode.Rectangle.Height >= 0);

                        if (bInsertVertically) {
                            if (this.m_bBottomWeighted) {
                                // The bottom of the next node should be at the top of this
                                // node.
                                dNodeBottom = dNodeTop;
                            } else {
                                // The top of the next node should be at the bottom of this
                                // node.
                                dNodeTop = dNodeBottom;
                            }
                        } else {
                            // The left side of the next node should be to the right of
                            // this node.
                            dNodeLeft = dNodeRight;
                        }
                    }
                };

                //*************************************************************************
                //	Method: SaveInsertedRectangles()
                //
                /// <summary>
                ///	Calls <see cref="Node.SaveRectangle" /> for each inserted node.
                /// </summary>
                ///
                /// <param name="aoNodes">
                /// Array of Node objects.
                /// </param>
                ///
                /// <param name="iIndexOfFirstInsertedNode">
                /// Zero-based index of the first node that has been inserted.
                /// </param>
                ///
                /// <param name="iIndexOfLastInsertedNode">
                /// Zero-based index of the last node that has been inserted.
                /// </param>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.SaveInsertedRectangles = function (aoNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                    Diag.Debug.Assert(aoNodes != null);
                    Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                    for (var i = iIndexOfFirstInsertedNode; i <= iIndexOfLastInsertedNode; i++) {
                        aoNodes[i].SaveRectangle();
                    }
                };

                //*************************************************************************
                //	Method: RestoreInsertedRectangles()
                //
                /// <summary>
                ///	Calls <see cref="Node.RestoreRectangle" /> for each inserted node.
                /// </summary>
                ///
                /// <param name="aoNodes">
                /// Array of Node objects.
                /// </param>
                ///
                /// <param name="iIndexOfFirstInsertedNode">
                /// Zero-based index of the first node that has been inserted.
                /// </param>
                ///
                /// <param name="iIndexOfLastInsertedNode">
                /// Zero-based index of the last node that has been inserted.
                /// </param>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.RestoreInsertedRectangles = function (aoNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                    Diag.Debug.Assert(aoNodes != null);
                    Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                    for (var i = iIndexOfFirstInsertedNode; i <= iIndexOfLastInsertedNode; i++) {
                        aoNodes[i].RestoreRectangle();
                    }
                };

                //*************************************************************************
                //	Method: GetAreaPerSizeMetric()
                //
                /// <summary>
                ///	Returns the area within a parent rectangle that will be taken up by
                /// each SizeMetric unit of the nodes that will be placed into the
                /// rectangle.
                /// </summary>
                ///
                /// <param name="oNodes">
                /// Collection of Node objects.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="oParentNode">
                /// Parent of <paramref name="oNodes" />, or null if <paramref
                /// name="oNodes" /> is the treemap's top-level node collection.
                /// </param>
                ///
                /// <returns>
                /// Area within oParentRectangle that will be taken up by each <see
                /// cref="Node.SizeMetric" /> unit.  A return value of zero indicates that
                /// the nodes in oNodes should not be drawn.
                /// </returns>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.GetAreaPerSizeMetric = function (oNodes, oParentRectangle, oParentNode) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(oParentRectangle.Width > 0);
                    Diag.Debug.Assert(oParentRectangle.Height > 0);

                    // Compute the total area of the parent.
                    var dTotalArea = oParentRectangle.Width * oParentRectangle.Height;

                    // Get the sum of the child SizeMetric values.
                    var dChildSizeMetricSum = 0;

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        dChildSizeMetricSum += oNode.SizeMetric;
                    }

                    // Add the SizeMetric value of the EmptySpace object that belongs to
                    // the Nodes collection.
                    dChildSizeMetricSum += oNodes.EmptySpace.SizeMetric;

                    // If the sum is zero, the nodes in oNodes should not be drawn.
                    if (dChildSizeMetricSum == 0)
                        return (0);

                    Diag.Debug.Assert(dChildSizeMetricSum != 0);

                    return (dTotalArea / dChildSizeMetricSum);
                };

                //*************************************************************************
                //	Method: GetRemainingEmptySpace()
                //
                /// <summary>
                ///	Returns a rectangle that contains the empty space not already filled by
                /// a set of inserted nodes.
                /// </summary>
                ///
                /// <param name="aoNodes">
                /// Array of Node objects.
                /// </param>
                ///
                /// <param name="oParentRectangle">
                /// Parent rectangle the nodes should be laid out within.  Can't be empty
                /// -- must have positive width and height.
                /// </param>
                ///
                /// <param name="iIndexOfFirstInsertedNode">
                /// Zero-based index of the first node that has already been inserted into
                /// <paramref name="oParentRectangle" />.
                /// </param>
                ///
                /// <param name="iIndexOfLastInsertedNode">
                /// Zero-based index of the last node that has already been inserted into
                /// <paramref name="oParentRectangle" />.
                /// </param>
                ///
                /// <returns>
                /// New rectangle that contains the empty space.  May be empty.
                /// </returns>
                ///
                /// <remarks>
                ///	If there is no empty space left, an empty rectangle is returned.
                /// </remarks>
                //*************************************************************************
                SquarifiedLayoutEngine.prototype.GetRemainingEmptySpace = function (aoNodes, oParentRectangle, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                    Diag.Debug.Assert(aoNodes != null);
                    Diag.Debug.Assert(oParentRectangle.Width > 0);
                    Diag.Debug.Assert(oParentRectangle.Height > 0);
                    Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                    Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                    var oRemainingEmptySpace;

                    // Get the most recently inserted rectangle.
                    var oLastInsertedRectangle = aoNodes[iIndexOfLastInsertedNode].Rectangle;

                    if (oParentRectangle.Width >= oParentRectangle.Height) {
                        // Nodes were added from bottom to top or top to bottom.  Move the
                        // left edge of the rectangle to the right of the inserted nodes.
                        oRemainingEmptySpace = System.Drawing.Rectangle.FromLTRB(oLastInsertedRectangle.Right, oParentRectangle.Top, oParentRectangle.Right, oParentRectangle.Bottom);
                    } else {
                        // Nodes were added from left to right.
                        if (this.m_bBottomWeighted) {
                            // Move the bottom edge of the rectangle to the top of the
                            // inserted nodes.
                            oRemainingEmptySpace = System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oParentRectangle.Top, oParentRectangle.Right, oLastInsertedRectangle.Top);
                        } else {
                            // Move the top edge of the rectangle to the bottom of the
                            // inserted nodes.
                            oRemainingEmptySpace = System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oLastInsertedRectangle.Bottom, oParentRectangle.Right, oParentRectangle.Bottom);
                        }
                    }

                    // If the rectangle's height or width is <= 0, return an empty
                    // rectangle.
                    if (oRemainingEmptySpace.IsEmpty)
                        oRemainingEmptySpace = System.Drawing.Rectangle.FromLTRB(0, 0, 0, 0);

                    return (oRemainingEmptySpace);
                };
                return SquarifiedLayoutEngine;
            })(LayoutEngineBase);
            Util.SquarifiedLayoutEngine = SquarifiedLayoutEngine;

            var BottomWeightedSquarifiedLayoutEngine = (function (_super) {
                __extends(BottomWeightedSquarifiedLayoutEngine, _super);
                function BottomWeightedSquarifiedLayoutEngine() {
                    _super.call(this, true);
                }
                return BottomWeightedSquarifiedLayoutEngine;
            })(SquarifiedLayoutEngine);
            Util.BottomWeightedSquarifiedLayoutEngine = BottomWeightedSquarifiedLayoutEngine;

            var TopWeightedSquarifiedLayoutEngine = (function (_super) {
                __extends(TopWeightedSquarifiedLayoutEngine, _super);
                function TopWeightedSquarifiedLayoutEngine() {
                    _super.call(this, false);
                }
                return TopWeightedSquarifiedLayoutEngine;
            })(SquarifiedLayoutEngine);
            Util.TopWeightedSquarifiedLayoutEngine = TopWeightedSquarifiedLayoutEngine;

            var TextDrawerBase = (function () {
                function TextDrawerBase(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration) {
                    this.m_eNodeLevelsWithText = eNodeLevelsWithText;
                    this.m_iMinNodeLevelWithText = iMinNodeLevelWithText;
                    this.m_iMaxNodeLevelWithText = iMaxNodeLevelWithText;
                    this.m_fAnimDuration = fAnimDuration;
                    // this.AssertValid();
                }
                TextDrawerBase.prototype.AssertValid = function () {
                    // Diag.Debug.Assert( Enum.IsDefined(typeof(NodeLevelsWithText), this.m_eNodeLevelsWithText) );
                    Diag.Debug.Assert(this.m_iMinNodeLevelWithText >= 0);
                    Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= 0);
                    Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= this.m_iMinNodeLevelWithText);
                };

                TextDrawerBase.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                    // abstract
                };

                TextDrawerBase.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                    // abstract
                };

                TextDrawerBase.prototype.TextShouldBeDrawnForNode = function (oNode, iNodeLevel) {
                    Diag.Debug.Assert(oNode != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);
                    this.AssertValid();

                    switch (this.m_eNodeLevelsWithText) {
                        case 0 /* All */:
                            return (true);

                        case 2 /* None */:
                            return (false);

                        case 1 /* Leaves */:
                            return (oNode.Nodes.Count == 0);

                        case 3 /* Range */:
                            return (iNodeLevel >= this.m_iMinNodeLevelWithText && iNodeLevel <= this.m_iMaxNodeLevelWithText);

                        default:
                            Diag.Debug.Assert(false);
                            return (false);
                    }
                };
                return TextDrawerBase;
            })();
            Util.TextDrawerBase = TextDrawerBase;

            var CenterCenterTextDrawer = (function (_super) {
                __extends(CenterCenterTextDrawer, _super);
                function CenterCenterTextDrawer(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontNormSizePt, fFontMinSizePt, fFontMaxSizePt, fFontIncrementPt, oFontSolidColor, iFontMinAlpha, iFontMaxAlpha, iFontAlphaIncrementPerLevel, oSelectedFontColor, fAnimDuration) {
                    _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                    this.m_sFontFamily = sFontFamily;

                    this.m_fFontNormSizePt = fFontNormSizePt;
                    this.m_fFontMinSizePt = fFontMinSizePt;
                    this.m_fFontMaxSizePt = fFontMaxSizePt;
                    this.m_fFontIncrementPt = fFontIncrementPt;

                    this.m_oFontSolidColor = oFontSolidColor;

                    this.m_iFontMinAlpha = iFontMinAlpha;
                    this.m_iFontMaxAlpha = iFontMaxAlpha;
                    this.m_iFontAlphaIncrementPerLevel = iFontAlphaIncrementPerLevel;

                    this.m_oSelectedFontColor = oSelectedFontColor;
                    this.m_fAnimDuration = fAnimDuration;

                    this.AssertValid();
                }
                CenterCenterTextDrawer.prototype.AssertValid = function () {
                    _super.prototype.AssertValid.call(this);

                    Diag.Debug.AssertNotEmpty(this.m_sFontFamily);

                    Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMaxSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontMaxSizePt >= this.m_fFontMinSizePt);
                    Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                    Diag.Debug.Assert(this.m_fFontNormSizePt <= this.m_fFontMaxSizePt);
                    Diag.Debug.Assert(this.m_fFontIncrementPt > 0);

                    Diag.Debug.Assert(this.m_oFontSolidColor.A == 255);

                    Diag.Debug.Assert(this.m_iFontMinAlpha >= 0 && this.m_iFontMinAlpha <= 255);
                    Diag.Debug.Assert(this.m_iFontMaxAlpha >= 0 && this.m_iFontMaxAlpha <= 255);
                    Diag.Debug.Assert(this.m_iFontMaxAlpha >= this.m_iFontMinAlpha);
                    Diag.Debug.Assert(this.m_iFontAlphaIncrementPerLevel > 0);
                    // m_oSelectedFontColor
                };

                CenterCenterTextDrawer.prototype.CreateFontMapper = function (displayRoot) {
                    Diag.Debug.Assert(displayRoot != null);
                    this.AssertValid();

                    // Create a MaximizingFontMapper for now.  Possible future upgrade:
                    // Add an option to use either a MaximizingFontMapper or a
                    // PerLevelFontMapper.
                    var oMaximizingFontMapper = new MaximizingFontMapper(this.m_sFontFamily, this.m_fFontMinSizePt, this.m_fFontMaxSizePt, this.m_fFontIncrementPt, displayRoot);

                    return (oMaximizingFontMapper);
                };

                CenterCenterTextDrawer.prototype.CreateStringFormat = function () {
                    // The node text should be centered both vertically and horizontally
                    // within the node's rectangle.
                    var oStringFormat = new System.Drawing.StringFormat();
                    oStringFormat.Alignment = 0 /* Center */;
                    oStringFormat.LineAlignment = 0 /* Center */;

                    return (oStringFormat);
                };

                CenterCenterTextDrawer.prototype.CreateTransparentBrushMapper = function () {
                    var oTransparentBrushMapper = new Microsoft.Treemap.GraphicsLib.TransparentBrushMapper();

                    oTransparentBrushMapper.Initialize(this.m_oFontSolidColor, this.m_iFontMinAlpha, this.m_iFontMaxAlpha, this.m_iFontAlphaIncrementPerLevel);

                    return (oTransparentBrushMapper);
                };

                CenterCenterTextDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oNodes != null);
                    this.AssertValid();

                    var oFontMapper = null;
                    var oTransparentBrushMapper = null;

                    // Save the current rendering hint.  This gets modified by
                    // DrawTextForNodes() on a per-node basis.
                    // Create an object that implements IFontMapper.
                    oFontMapper = this.CreateFontMapper(displayRoot);

                    // Create a TransparentBrushMapper object.
                    oTransparentBrushMapper = this.CreateTransparentBrushMapper();

                    // Create the required StringFormat object.
                    var oStringFormat = this.CreateStringFormat();

                    // Draw all the text.
                    this.DrawTextForNodes(oNodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, 0, this.m_fAnimDuration);
                };

                CenterCenterTextDrawer.prototype.DrawTextForNodes = function (oNodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, iNodeLevel, fAnimDuration) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oFontMapper != null);
                    Diag.Debug.Assert(oStringFormat != null);
                    Diag.Debug.Assert(oTransparentBrushMapper != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        var oNodeRectangle = oNode.RectangleToDraw;

                        // Skip over empty rectangles.  An empty rectangle indicates that
                        // a node's calculated rectangle is too small to display.
                        if (oNodeRectangle.IsEmpty)
                            continue;

                        // Check whether text should be drawn for this node level.
                        if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                            // Get a font to use for the text.
                            var oFont;
                            var sTextToDraw = oNode.Text;

                            oFont = oFontMapper.NodeToFont(oNode, oNodeRectangle, iNodeLevel, sTextToDraw);

                            if (oFont) {
                                // Get a transparent brush to use.
                                var oBrush = oTransparentBrushMapper.LevelToTransparentBrush(iNodeLevel);

                                // Draw the text.
                                oNode.DisplayText(displayRoot, oNodeRectangle, oFont, oBrush, oStringFormat, iNodeLevel, fAnimDuration);
                            } else {
                                oNode.RemoveText();
                            }
                        } else {
                            oNode.RemoveText();
                        }

                        // Repeat for this node's child nodes.
                        this.DrawTextForNodes(oNode.Nodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, iNodeLevel + 1, this.m_fAnimDuration);
                    }
                };

                CenterCenterTextDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                    Diag.Debug.Assert(oSelectedNode != null);
                    this.AssertValid();

                    oSelectedNode.SetTextColor(this.m_oSelectedFontColor);
                };
                return CenterCenterTextDrawer;
            })(TextDrawerBase);
            Util.CenterCenterTextDrawer = CenterCenterTextDrawer;

            var TopTextDrawer = (function (_super) {
                __extends(TopTextDrawer, _super);
                function TopTextDrawer(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontNormSizePt, fFontMinSizePt, iMinimumTextHeight, oTextColor, oSelectedFontColor, oSelectedBackColor, fAnimDuration) {
                    _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                    this.m_sFontFamily = sFontFamily;
                    this.m_fFontNormSizePt = fFontNormSizePt;
                    this.m_fFontMinSizePt = fFontMinSizePt;
                    this.m_iMinimumTextHeight = iMinimumTextHeight;
                    this.m_oTextColor = oTextColor;
                    this.m_oSelectedFontColor = oSelectedFontColor;
                    this.m_oSelectedBackColor = oSelectedBackColor;

                    this.AssertValid();
                }
                TopTextDrawer.prototype.AssertValid = function () {
                    _super.prototype.AssertValid.call(this);

                    Diag.Debug.AssertNotEmpty(this.m_sFontFamily);
                    Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                    Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                    Diag.Debug.Assert(this.m_iMinimumTextHeight >= 0);
                    // m_oTextColor
                    // m_oSelectedFontColor
                    // m_oSelectedBackColor
                };

                TopTextDrawer.prototype.CreateStringFormat = function (bLeafNode, iTextHeight) {
                    var oStringFormat = new System.Drawing.StringFormat();

                    // For leaf nodes, the text should be left-justified at the top of the
                    // node's rectangle and wrap within the rectangle.
                    //
                    // For non-leaf nodes, the text should be center-justified at the top
                    // of the node's rectangle and limited to a single line.
                    oStringFormat.LineAlignment = oStringFormat.Alignment = bLeafNode ? 2 /* Near */ : 0 /* Center */;

                    // Trim the string with ellipses.
                    oStringFormat.Trimming = 1 /* EllipsisCharacter */;

                    // TODO: trim ourselves since canvas text doesn't do that.
                    return (oStringFormat);
                };

                TopTextDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oNodes != null);
                    this.AssertValid();

                    var oFontForRectangle = null;
                    var oFontForLeaf = null;
                    var oTextBrush = null;

                    // Get a font to use.
                    oFontForRectangle = new FontForRectangle(this.m_sFontFamily, this.m_fFontNormSizePt, displayRoot);

                    if ((this.m_fFontNormSizePt - 2) > this.m_fFontMinSizePt) {
                        oFontForLeaf = new FontForRectangle(this.m_sFontFamily, this.m_fFontNormSizePt - 2, displayRoot);
                    } else {
                        oFontForLeaf = oFontForRectangle;
                    }

                    // Get the height required to draw text.
                    var iTextHeight = TopTextDrawer.GetTextHeight2(displayRoot, oFontForRectangle.Font, this.m_iMinimumTextHeight);

                    // Get a brush to use.
                    oTextBrush = this.m_oTextColor;

                    // Create the required StringFormat objects.
                    var oNonLeafStringFormat = this.CreateStringFormat(false, iTextHeight);
                    var oLeafStringFormat = this.CreateStringFormat(true, iTextHeight);

                    // Draw the text.
                    this.DrawTextForNodes(oNodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, null, oNonLeafStringFormat, oLeafStringFormat, 0);
                };

                TopTextDrawer.prototype.DrawTextForNode = function (displayRoot, oNode, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oNode != null);
                    Diag.Debug.Assert(oFontForRectangle != null);
                    Diag.Debug.Assert(oFontForLeaf != null);
                    Diag.Debug.Assert(iTextHeight >= 0);
                    Diag.Debug.Assert(oTextBrush != null);
                    Diag.Debug.Assert(oNonLeafStringFormat != null);
                    Diag.Debug.Assert(oLeafStringFormat != null);
                    this.AssertValid();

                    var bIsLeaf = (oNode.Nodes.Count == 0);

                    // Get the node's rectangle, then shrink it to accommodate the node's
                    // border.
                    var oInnerBorderRectangle = oNode.RectangleToDraw;
                    var iPenWidthPx = oNode.PenWidthPx;
                    oInnerBorderRectangle.Inflate(-iPenWidthPx, -iPenWidthPx);

                    var oTextRectangle;
                    var oFontForText;

                    if (bIsLeaf) {
                        // The text should wrap within the rectangle.
                        oTextRectangle = System.Drawing.Rectangle.Inflate(oInnerBorderRectangle, -2, -2);
                        oFontForText = oFontForLeaf;
                    } else {
                        // The text should be limited to a single line.
                        oTextRectangle = System.Drawing.Rectangle.FromLTRB(oInnerBorderRectangle.Left, oInnerBorderRectangle.Top, oInnerBorderRectangle.Right, oInnerBorderRectangle.Top + iTextHeight + iPenWidthPx);
                        oFontForText = oFontForRectangle;
                    }

                    // If the text rectangle isn't large enough to contain text, do
                    // nothing.
                    var iTextRectangleWidth = oTextRectangle.Width;
                    var iTextRectangleHeight = oTextRectangle.Height;

                    if (iTextRectangleWidth <= 0 || iTextRectangleHeight <= 0 || iTextRectangleHeight > oInnerBorderRectangle.Height) {
                        oNode.RemoveText();
                        return;
                    }

                    //---- get text color from NODE or GENERATOR ----
                    var tb = oNode.m_oTextColor;
                    if (!tb) {
                        tb = this.m_oTextColor;
                    }

                    if (tb) {
                        oTextBrush = tb;
                    }

                    // Draw the text.
                    oNode.DisplayText(displayRoot, oTextRectangle, oFontForText.Font, oTextBrush, bIsLeaf ? oLeafStringFormat : oNonLeafStringFormat, iNodeLevel, this.m_fAnimDuration);
                    // TODO: use oBackgroundBrush if necessary
                };

                TopTextDrawer.prototype.DrawTextForNodes = function (oNodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oFontForRectangle != null);
                    Diag.Debug.Assert(iTextHeight >= 0);
                    Diag.Debug.Assert(oTextBrush != null);
                    Diag.Debug.Assert(oNonLeafStringFormat != null);
                    Diag.Debug.Assert(oLeafStringFormat != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        var oNodeRectangle = oNode.Rectangle;

                        // Skip over empty rectangles.  An empty rectangle indicates that
                        // a node's calculated rectangle is too small to display.
                        if (oNodeRectangle.IsEmpty)
                            continue;

                        // Check whether text should be drawn for this node level.
                        if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                            // Draw the text.
                            this.DrawTextForNode(displayRoot, oNode, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel);
                        } else {
                            oNode.RemoveText();
                        }

                        // Repeat for this node's child nodes.
                        this.DrawTextForNodes(oNode.Nodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel + 1);
                    }
                };

                TopTextDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                    Diag.Debug.Assert(oSelectedNode != null);
                    this.AssertValid();

                    oSelectedNode.SetTextColor(this.m_oSelectedFontColor);
                };

                TopTextDrawer.GetTextHeight = function (displayRoot, sFontFamily, fFontSizePt, iMinimumTextHeight) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.AssertNotEmpty(sFontFamily);
                    Diag.Debug.Assert(fFontSizePt > 0);
                    Diag.Debug.Assert(iMinimumTextHeight >= 0);

                    var oFontForRectangle = null;
                    var iTextHeight;

                    oFontForRectangle = new FontForRectangle(sFontFamily, fFontSizePt, displayRoot);

                    iTextHeight = TopTextDrawer.GetTextHeight2(displayRoot, oFontForRectangle.Font, iMinimumTextHeight);

                    return (iTextHeight);
                };
                TopTextDrawer.GetTextHeight2 = function (displayRoot, oFont, iMinimumTextHeight) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oFont != null);
                    Diag.Debug.Assert(iMinimumTextHeight >= 0);

                    // Multiply the text height returned by Font.GetHeight() by a constant
                    // to provide a margin above and below the text.
                    // TODO: this should really be in oFont.GetHeight()
                    var d = document.createElement("span");
                    d.style.font = oFont.ToHTML;
                    d.textContent = "Hg";
                    document.body.appendChild(d);
                    var emHeight = d.offsetHeight;
                    document.body.removeChild(d);

                    // var temp = displayRoot.append("text")
                    //    .text("M")
                    //    .font(oFont.Name, oFont.Size);
                    // temp.remove();
                    var iTextHeight = Math.ceil(TextHeightMultiplier * emHeight);

                    iTextHeight = Math.max(iTextHeight, iMinimumTextHeight);

                    return (iTextHeight);
                };
                return TopTextDrawer;
            })(TextDrawerBase);
            Util.TopTextDrawer = TopTextDrawer;

            var OwnerDrawDrawer = (function (_super) {
                __extends(OwnerDrawDrawer, _super);
                function OwnerDrawDrawer(ownerDraw, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontSizePt, oTextColor, oSelectedFontColor, oSelectedBackColor, fAnimDuration) {
                    _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                    this.m_ownerDraw = ownerDraw;

                    this.m_sFontFamily = sFontFamily;
                    this.m_fFontSizePt = fFontSizePt;
                    this.m_oTextColor = oTextColor;
                    this.m_oSelectedFontColor = oSelectedFontColor;
                    this.m_oSelectedBackColor = oSelectedBackColor;

                    this.m_ownerDraw.SetDrawingContext(sFontFamily, fFontSizePt, oTextColor, oSelectedFontColor, oSelectedBackColor);
                    this.AssertValid();
                }
                OwnerDrawDrawer.prototype.AssertValid = function () {
                    Diag.Debug.Assert(this.m_ownerDraw != null);

                    Diag.Debug.AssertNotEmpty(this.m_sFontFamily);
                    Diag.Debug.Assert(this.m_fFontSizePt > 0);
                    // m_oTextColor
                    // m_oSelectedFontColor
                    // m_oSelectedBackColor
                };

                OwnerDrawDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oNodes != null);
                    this.AssertValid();

                    // TODO: font mapper, color mapper, etc.
                    this.DrawContentForNodes(displayRoot, oNodes, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, 0);
                };

                OwnerDrawDrawer.prototype.DrawContentForNodes = function (displayRoot, oNodes, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel) {
                    Diag.Debug.Assert(oNodes != null);
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(iNodeLevel >= 0);

                    var iTextHeight = this.m_ownerDraw.GetTopHeight(displayRoot);

                    // same as TreemapGenerator.DecrementPadding
                    var iDecrementedLeftRightPaddingPx = Math.max(iLeftRightPaddingPx - iPaddingDecrementPerLevelPx, Microsoft.Treemap.Generator.TreemapGenerator.MinPaddingPx);

                    for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                        var oNode = oNodes.Item(iNode);
                        var oNodeRectangle = oNode.Rectangle;

                        // Skip over empty rectangles.  An empty rectangle indicates that
                        // a node's calculated rectangle is too small to display.
                        if (oNodeRectangle.IsEmpty)
                            continue;

                        if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                            this.DrawContentForNode(displayRoot, oNode, iTextHeight, iDecrementedLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel);
                        } else {
                            var elem = oNode.DisplayedElement;
                            if (elem) {
                                elem.remove();
                                oNode.DisplayedElement = null;
                            }
                        }

                        // Repeat for this node's child nodes.
                        this.DrawContentForNodes(displayRoot, oNode.Nodes, iDecrementedLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel + 1);
                    }
                };

                OwnerDrawDrawer.prototype.DrawContentForNode = function (displayRoot, oNode, iTextHeight, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel) {
                    Diag.Debug.Assert(displayRoot != null);
                    Diag.Debug.Assert(oNode != null);
                    Diag.Debug.Assert(iTextHeight >= 0);
                    this.AssertValid();

                    var bIsLeaf = (oNode.Nodes.Count == 0);

                    // Get the node's rectangle, then shrink it to accommodate the node's
                    // border.
                    var oInnerBorderRectangle = oNode.RectangleToDraw;
                    var iPenWidthPx = oNode.PenWidthPx;
                    oInnerBorderRectangle.Inflate(-iPenWidthPx, -iPenWidthPx);

                    var oTextRectangle;

                    if (bIsLeaf) {
                        // The text should wrap within the rectangle.
                        oTextRectangle = oInnerBorderRectangle;
                    } else {
                        // The text should be limited to a single line.
                        // passing must be sutracted from left/right so that the rectangle
                        // fits above all children and between the outer and inner borders
                        oTextRectangle = System.Drawing.Rectangle.FromLTRB(oInnerBorderRectangle.Left + iLeftRightPaddingPx, oInnerBorderRectangle.Top, oInnerBorderRectangle.Right - iLeftRightPaddingPx, oInnerBorderRectangle.Top + iTextHeight);

                        if (oTextRectangle.Height > oInnerBorderRectangle.Height) {
                            oTextRectangle.Height = oInnerBorderRectangle.Height;
                        }
                        if (oTextRectangle.Width > oInnerBorderRectangle.Width) {
                            oTextRectangle.Width = oInnerBorderRectangle.Width;
                        }
                    }

                    // If the text rectangle isn't large enough to contain text, do
                    // nothing.
                    var iTextRectangleWidth = oTextRectangle.Width;
                    var iTextRectangleHeight = oTextRectangle.Height;

                    if (iTextRectangleWidth <= 0 || iTextRectangleHeight <= 0) {
                        var elem = oNode.DisplayedElement;
                        if (elem) {
                            elem.remove();
                            oNode.DisplayedElement = null;
                        }
                        return;
                    }

                    // Draw the content.
                    var elem = this.m_ownerDraw.DisplayContent(displayRoot, oNode.DisplayedElement, oTextRectangle, oNode, bIsLeaf, iNodeLevel);
                    oNode.DisplayedElement = elem;
                };

                OwnerDrawDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                    Diag.Debug.Assert(oSelectedNode != null);
                    this.AssertValid();

                    this.m_ownerDraw.ShowSelected(oSelectedNode.DisplayedElement, oSelectedNode, true);
                };
                return OwnerDrawDrawer;
            })(TextDrawerBase);
            Util.OwnerDrawDrawer = OwnerDrawDrawer;
        })(Treemap.Util || (Treemap.Util = {}));
        var Util = Treemap.Util;
    })(Microsoft.Treemap || (Microsoft.Treemap = {}));
    var Treemap = Microsoft.Treemap;
})(Microsoft || (Microsoft = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// changeAgent.js.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - allocated one per view; shares change/state info with changeMgr.
///-----------------------------------------------------------------------------------------------------------------

vp.changeAgentFactory = function (viewName, shareName, appName, externalShare, dataChangedFunc)
{
    //---- private state ----
    var session = null;
    var changeMgr = null;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.changeAgent";

    //---- readonly public properties ----
    closure.viewName = viewName;
    closure.shareName = shareName;
    closure.appName = appName;
    closure.externalShare = externalShare;
    closure.processId = new Date();
    closure.callBack = dataChangedFunc;
    
    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return session.data;
        }

        changeMgr.setData(closure, value, session);
        return this;
    };

    closure.unregister = function()
    {
        changeMgr.unregister(closure);
    };

    //---- init code ----
    if (!vp.changeMgr)
    {
        //---- create a global changeMgr that is shared by all views ----
        vp.changeMgr = vp.changeMgrFactory();
    }

    changeMgr = vp.changeMgr;
    session = changeMgr.register(closure);

    return closure;
};

vp.changeAgent = function (viewName, shareName, appName, externalShare, dataChangedFunc)
{
    var agent = vp.changeAgentFactory(viewName, shareName, appName, externalShare, dataChangedFunc);
    return agent;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// changeMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - used to share change information between in-process and external/networked views.
///-----------------------------------------------------------------------------------------------------------------
/// How this works:  Let's say we have an HTML based charting app called "xPlot".  It operates on 
/// one set of data tables at a time, but offers multiple views of that data.  Each view in xPlot should call:
///
///     var changeAgent = vp.changeMgr.registerView(shareName, appName, externalShare, onChangedFunc);
///
/// "shareName" is the name of the shared data, e.g., "data1".  Multiple channels of sharing can be established within 
/// or between applicatons using different names.
///
/// "appName" is the friendly name of the application being run.  In the above case, it would be "xPlot".
///
/// "externalShare" controls whether or not the sharing extends outside of the current application.  if set to "true",
/// the ChangeService (running on the hosting server) will be used to relay data between sharing clients.
///
/// "onChangedFunc" is a callback function that is called by the changeMgr whenever a change agent has signaled that
/// something has changed.  Normally, views will closure or rebuild themselves according to the data in the changeAgent.data property.
///
/// Note that "data" being shared (changeAgent.data) can be anything, but is usually a small json object that holds 
/// properties of the data (for example: data source name, selection query, filter query, and highlight query).
///
/// Whenever something in the "data" is changed by a view, it is recommended that each view NOT closure the associated elements
/// directly, but use "changeAgent.ChangeData()" to do so, and then wait for the callback to be called before updating the view.
///-----------------------------------------------------------------------------------------------------------------

vp.changeMgrFactory = function ()
{
    //---- private state ----
    var sessions = [];
    var subscribers = [];
    var serviceUrl = vp.pagePath() + "/Service/ChangeService.asmx";
    var timer = null;
    var updateSpan = 500;       // 500 ms

    //---- closure: ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.changeMgr";

    closure.register = function (agent)
    {
        var session = sessions[agent.shareName];
        if (session === undefined)
        {
            //---- its a new session ----
            session =
            {
                name: agent.shareName, data: null, sourceViewName: null, sourceTimeStamp: null,
                serviceChangeNum: 0, subscribers: [], subscribersChangeNumber: 0,
                tellService: agent.externalShare
            };

            sessions[agent.shareName] = session;

            if (agent.externalShare)
            {
                registerSessionWithService(session, agent.appName, agent.processId);
            }
        }

        session.subscribers.push(agent);
        return session;
    };

    var setDataCore = function (session, value, changeTime, agent, viewName, appName, computerName, userName)
    {
        session.data = value;
        session.sourceTimeStamp = changeTime;
        session.sourceViewName = viewName;

        //---- notify all subscribers ----
        for (var i = 0; i < session.subscribers.length; i++)
        {
            var subscriber = session.subscribers[i];

            if (subscriber != agent)        // don't sent to agent who made the change
            {
                var changeInfo = {
                    time: changeTime, view: viewName, app: appName,
                    computer: computerName, user: userName
                };

                subscriber.callBack(value, changeInfo);
            }
        }
    }

    //---- property: data ----
    closure.setData = function (agent, value, session)
    {
        setDataCore(session, value, new Date(), agent, agent.viewName, agent.appName, null, null);

        if (session.tellService)
        {
            sendDataChange(session, agent);
        }
    };

    /// private. registers the specified session name with the service 
    var registerSessionWithService = function (session, appName, processId)
    {
        var url = serviceUrl + "/RegisterSession?sessionName=" + session.name + "&processName=" + appName + "&processId="
           + processId;

        vp.httpRead(url, true, function (xmlhttp)
        {
            var success = 0;
        },
        function (xmlhttp)
        {
            var error = 0;
        });
    };

    var sendDataChange = function (session, agent)
    {
        var data = session.data;
        var jsonData = JSON.stringify(data);
        //var jsonEncodedData = encodeURIComponent(jsonData);

        var changedTime = new Date();

        var url = serviceUrl + "/UpdateData?sessionName=" + session.name +   // "&data=" + jsonData +
            "&processName=" + agent.appName + "&processId=" + agent.processId + "&timeChanged=" + changedTime + 
            "&viewName=" + agent.viewName;

        var safeUrl = encodeURI(url);

        //---- create the xmlHttp object ----
        var xmlhttp = vp.createXMLHttpRequest();
        var callAsync = true;
        xmlhttp.open("GET", url, callAsync);

        //---- send the potentially very long data string via a custom header ----
        xmlhttp.setRequestHeader("dataParam", jsonData);

        vp.debug("changeMgr.sendDataChange: data.length=" + jsonData.length);

        //---- set up sucess / failure handlers ----
        xmlhttp.onreadystatechange = function ()
        {
            if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
            {
                if (xmlhttp.status == 200)
                {
                    //---- SUCCESS ----
                    var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);
                    session.serviceChangeNum = data.newChangeNum;

                    var dummy = 9;
                }
                else
                {
                    //---- FAILURE ----
                    var error = 9;
                }
            }
        };

        //---- start it now ----
        xmlhttp.send();
    };

    var getDataChanges = function ()
    {
        var requestArray = [];
        var keys = vp.keys(sessions);

        for (var i = 0; i < keys.length; i++)
        {
            var session = sessions[keys[i]];
            var request = { sessionName: session.name, lastChangeNum: session.serviceChangeNum };

            requestArray.push(request);
        }

        var json = JSON.stringify(requestArray);
        var jsonEncoded = encodeURIComponent(json);

        var url = serviceUrl + "/GetDataChanges?jsonRequestList=" + jsonEncoded;

        vp.httpRead(url, true, function (xmlhttp)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);
            var changeArray = data;
            for (var i = 0; i < changeArray.length; i++)
            {
                var change = changeArray[i];

                var session = sessions[change.sessionName];
                if (session)
                {
                    session.serviceChangeNum = change.lastChangeNum;
                    var data = JSON.parse(change.data);     // eval("(" + change.data + ")");
                    var time = new Date(change.changedTime);

                    setDataCore(session, data, time, null, change.viewName, change.appName, change.computerName, change.userName);
                }
            }

            var dummy = 9;
        },
        function (xmlhttp)
        {
            var error = 9;
        });
    };

    closure.unregister = function(agent)
    {
        var session = sessions[agent.shareName];
        if (session)
        {
            session.subscribers.remove(agent);
        }
    };

    //---- init code for changeMgr ----
    timer = setInterval(getDataChanges, updateSpan);      // read data changes from service every one second

    return closure;
};


﻿///-----------------------------------------------------------------------------------------------------------------
/// query.js.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - implements a query object composed of query terms and operators
///    - support query-based views that implment highlighting, selection, and filtering
///    - used by "changeAgent" to support "selection", "filter", and "highlight" objects
///
///    - functions:
///         - reset()
///         - test(data)            // returns TRUE if data is "in" the query 
///
///         - orWith(exp)           // exp OR prev            (shift-key highlight/select)
///         - invert()              // NOT prev               (invert of select/filter)
///         - toggleTo(exp)         // toggle "exp" in prev   (ctrl-key highlight/select)
///         - boundsQuery(exp)      // select elems from bounds query  (draw rectangle around elements)
///
///         - addGroup(fromQUery, invert)   // adds terms from another query as a grouped set of terms
///-----------------------------------------------------------------------------------------------------------------
/// testing: see query.html
///-----------------------------------------------------------------------------------------------------------------

vp.nextQueryNum = 1;

vp.query = function ()
{
    //---- private state ----
    var terms = [];
    var newTestNeeded = true;
    var funcHolder = null;
    var usesGroups = false;

    var myId = vp.nextQueryNum++;
    var generatedTestName = "generatedTest" + myId;

    //---- closure() ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.query";

    //---- public: reset() ----
    closure.reset = function (value)
    {
        terms = [];
        usesGroups = false;
        markNewTestNeeded();

        return this;
    };

    var generateTermEval = function(opCode, exp, indent)
    {
        var func = "";

        if (opCode == "orWith")
        {
            func += indent + "prev = prev || (" + exp + ");\n";
        }
        else if (opCode == "andWith")
        {
            func += indent + "prev = prev && (" + exp + ");\n";
        }
        else if (opCode == "invert")
        {
            func += indent + "prev = (! prev);\n";
        }
        else if (opCode == "toggleTo")
        {
            func += indent + "var isIn = (" + exp + ");\n";
            func += indent + "prev = (isIn) ? (! prev) : (prev) ;\n";
        }
        else if (opCode == "boundsQuery")
        {
            func += indent + "prev = (" + exp + ");\n"; 
        }
        else if (opCode == "andWithInvert")
        {
            func += indent + "var isIn = (" + exp + ");\n";
            func += indent + "prev = prev && (! isIn);\n";
        }

        return func;
    };

    //---- private: generateSeriesTest() ----
    var generateSeriesTest = function ()
    {
        newTestNeeded = false;

        var func = "function " + generatedTestName + "(data1) \n";
        func += "{ \n";

        func += "  var count = arguments.length;    // series count \n";
        func += "  var topPrev = undefined;   \n";

        for (var i = 0; i < terms.length; i++)
        {
            //---- we only expect group objects here ----
            var group = terms[i];

            var gterms = group.terms;
            var useInvert = group.invert;

            func += "\n";

            func += "  //---- start code for group " + i + " ---- \n";

            if (gterms.length > 0)
            {
                func += "  var prev = false;    // prev for this group \n";
                func += "  for(var i=0; i < count; i++) // for each series\n";
                func += "  { \n";
                func += "    var data = arguments[i]; \n";

                //---- generate code for this group's terms ----
                for (var g = 0; g < gterms.length; g++)
                {
                    var innerTerm = gterms[g];
                    func += generateTermEval(innerTerm.op, innerTerm.exp, "    ");
                }

                if (useInvert)
                {
                    func += "    prev = (! prev);    // apply TOGGLE\n";
                }

                func += "    if (prev)      // break on first TRUE \n";
                func += "    { \n";
                func += "        break; \n";
                func += "    } \n";
                func += "  } \n\n";

                func += "  if (topPrev)     // combine with prior groups result \n";
                func += "  { \n";
                func += "    prev = (topPrev || prev); \n";
                func += "  } \n";
                func += "  topPrev = prev; \n";
            }
            else
            {
                if (useInvert)
                {
                    func += "    topPrev = (! topPrev);    // apply TOGGLE to prev group\n";
                }
            }
            func += "  //---- end of code for group ---- \n\n";
        }

        func += "\n  return topPrev;\n";
        func += "}\n";

        addDynamicScript(func);
    }

    //---- private: generateTest() ----
    var generateTest = function ()
    {
        newTestNeeded = false;

        var func = "function " + generatedTestName + "(data)\n";
        func += "{\n";

        func += "  var prev = false;\n";

        for (var i = 0; i < terms.length; i++)
        {
            var term = terms[i];
            func += generateTermEval(term.op, term.exp, "  ");
        }

        func += "\n  return prev;\n";
        func += "}\n";

        addDynamicScript(func);
    }

    var addDynamicScript = function(func)
    {
        //---- it seems we need to re-append it each time to make this work (overwrites last script?) ----
        if (funcHolder)
        {
            document.body.removeChild(funcHolder[0]);
        }

        funcHolder = vp.select(document.body).append("script")
            .text(func);
    }

    var generateTestNow = function ()
    {
        if (usesGroups)
        {
            generateSeriesTest();
        }
        else
        {
            generateTest();
        }
    }

    closure.termsAreEqual = function (terms1, terms2)
    {
        var diff = (terms1.length != terms2.length);
        if (!diff)
        {
            //---- compare each term ----
            for (var i = 0; i < terms1.length; i++)
            {
                var t1 = terms1[i];
                var t2 = terms2[i];

                if (vp.isDefined(t1.terms))
                {
                    diff = vp.isNotDefined(t2.terms);
                    if (!diff)
                    {
                        //---- comparing 2 GROUP terms ----
                        diff = (t1.invertResult != t2.invertResult);
                        if (!diff)
                        {
                            diff = (!closure.termsAreEqual(t1.terms, t2.terms));
                        }
                    }
                }
                else
                {
                    diff = vp.isDefined(t2.terms);
                    if (!diff)
                    {
                        //---- comparing 2 SIMPLE terms ----
                        diff = (t1 != t2);
                    }
                }

                if (diff)
                {
                    break;
                }
            }
        }

        return diff;
    };

    //---- public: test(data) ----
    closure.test = function (data)
    {
        if (newTestNeeded)
        {
            generateTestNow();
        }

        var callExp = generatedTestName + "(data)"
        var isIn = eval(callExp);
        return isIn;
    };

    /// call should pass all series data items, one per param.
    /// expected to operate on term groups and reduce results to single T/F for each group.
    closure.testSeries = function (data1)
    {
        if (newTestNeeded)
        {
            generateTestNow();
        }

        var callExp = generatedTestName + "(data1)"
        var isIn = eval(callExp);
        return isIn;
    };

    var markNewTestNeeded = function()
    {
        newTestNeeded = true;
    }

    //---- public: orWith(exp) ----
    closure.orWith = function (exp)
    {
        var term = { op: "orWith", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: andWith(exp) ----
    closure.andWith = function (exp)
    {
        var term = { op: "andWith", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: invert() ----
    closure.invert = function ()
    {
        var addIt = true;

        //---- can we cancel the last INVERT cmd? ----
        if (terms.length > 0)
        {
            var lastIndex = terms.length - 1;
            if (terms[lastIndex].op == "invert")
            {
                terms.removeAt(lastIndex);
                addIt = false;
            }
        }

        if (addIt)
        {
            var term = { op: "invert", exp: null };
            terms.push(term);
        }

        markNewTestNeeded();

        return this;
    };

    //---- public: toggleTo(exp) ----
    closure.toggleTo = function (exp)
    {
        var term = { op: "toggleTo", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: boundsQuery(exp) ----
    closure.boundsQuery = function (exp)
    {
        var term = { op: "boundsQuery", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: andWithInvert(exp) ----
    closure.andWithInvert = function (exp)
    {
        var term = { op: "andWithInvert", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- add terms from another query as a group object with an associated "invert" flag.
    closure.addGroup = function (fromQuery, invertResult)
    {
        var groupTerms = [];
        usesGroups = true;
        var addIt = true;

        if (fromQuery)
        {
            var fromTerms = fromQuery.terms();
            for (var i = 0; i < fromTerms.length; i++)
            {
                //---- replace the shape test in "exp" with a data test ----
                var fromTerm = fromTerms[i];
                var newExp = (fromTerm.exp) ? fromTerm.exp.replace("vp.queryShapeTest(", "vp.queryDataTest(") : null;

                var term = {op: fromTerm.op, exp: newExp};
                groupTerms.push(term);
            }
        }
        else if (invertResult)
        {
            //---- this is an INVERT cmd (with no from terms) ----
            //---- can we cancel the last INVERT cmd? ----
            if (terms.length > 0)
            {
                var lastIndex = terms.length - 1;
                if ((terms[lastIndex].invert) && (terms[lastIndex].terms.length == 0))   
                {
                    terms.removeAt(lastIndex);
                    addIt = false;
                }
            }
        }

        if (addIt)
        {
            var groupObj = { terms: groupTerms, invert: invertResult };
            terms.push(groupObj);
        }

        markNewTestNeeded();

        return this;
    };

    /// public property: terms()
    closure.terms = function (value)
    {
        if (arguments.length == 0)
        {
            return terms;
        }

        terms = value;
        markNewTestNeeded();

        return this;
    };

    //---- init code ----

    return closure;
};


//---- this function called by generated code (to make generated code a bit simpler) ----
//---- used to query 1 or more data records ----
vp.queryDataTest = function (data, exp, dataId, shapeId)
{
    return (exp) && (data.dataId == dataId);
};

///---- used to query 1 or more shapes ----
vp.queryShapeTest = function (data, exp, dataId, shapeId)
{
    return (exp) && (data.dataId == dataId) && (data.shapeId == shapeId);
};

///---- used to query 1 or more shapes within a 2 value bounds ----
//----- keep this as hard-code function for easier debugging ----
vp.boundsQueryTest = function (data, exp)
{
    return (exp);
};///-----------------------------------------------------------------------------------------------------------------
/// singleWrapper.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - class that wraps a single element (HTML, SVG, Canvas, or WebGL item).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (visuals) {
        /** class that wraps a single element (HTML, SVG, Canvas, or WebGL item). */
        var singleWrapperClass = (function () {
            function singleWrapperClass(elem) {
                this.ctr = "vp.singleWrapper";
                this.prop = null;
                this.elem = elem;

                //---- these are one and the same ----
                this.prop = this.customAttr;

                //---- we want calling code to be able to treat this as an array (so it doesn't have to special case ss vs. this) ----
                var self = this;
                self.length = 0;

                //---- make "selectedSet" look/act like an array object ---
                self.push = Array.prototype.push;
                self.splice = Array.prototype.splice;
                self.indexOf = Array.prototype.indexOf;
                self.select = Array.prototype.select;

                self.push(elem);

                //---- remove this as soon as all 15 controls are converted to TypeScript ----
                //---- extend this wrapper if elem with custom control properties ----
                var anyElem = elem;

                if ((anyElem) && (anyElem.control) && (anyElem.control.extendWrapper)) {
                    anyElem.control.extendWrapper(this);
                }
            }
            singleWrapperClass.prototype.element = function (value) {
                if (arguments.length == 0) {
                    return this.elem;
                }

                this[0] = value;
                this.elem = value;
            };

            singleWrapperClass.prototype.css = function (name, value) {
                if (arguments.length == 1) {
                    return vp.css(this.elem, name);
                }

                vp.css(this.elem, name, value);
                return this;
            };

            singleWrapperClass.prototype.bounds = function (x, y, width, height) {
                vp.bounds(this.elem, x, y, width, height);
                return this;
            };

            singleWrapperClass.prototype.colors = function (fill, stroke, strokeWidth) {
                vp.colors(this.elem, fill, stroke, strokeWidth);
                return this;
            };

            singleWrapperClass.prototype.text = function (value) {
                if (arguments.length == 0) {
                    return vp.text(this.elem);
                }

                vp.text(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.tabIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.tabIndex(this.elem);
                }

                vp.tabIndex(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.title = function (value) {
                if (arguments.length == 0) {
                    return vp.title(this.elem);
                }

                vp.title(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.value = function (value) {
                if (arguments.length == 0) {
                    return vp.value(this.elem);
                }

                vp.value(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.html = function (value) {
                if (arguments.length == 0) {
                    return vp.html(this.elem);
                }

                vp.html(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.show = function (showIt) {
                vp.show(this.elem, showIt);
                return this;
            };

            singleWrapperClass.prototype.showToggle = function () {
                vp.showToggle(this.elem);
                return this;
            };

            singleWrapperClass.prototype.hide = function () {
                vp.hide(this.elem);
                return this;
            };

            singleWrapperClass.prototype.collapse = function () {
                vp.collapse(this.elem);
                return this;
            };

            singleWrapperClass.prototype.expand = function () {
                vp.expand(this.elem);
                return this;
            };

            singleWrapperClass.prototype.dataIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.dataIndex(this.elem);
                }

                vp.dataIndex(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.dataItem = function (value) {
                if (arguments.length == 0) {
                    return vp.dataItem(this.elem);
                }

                vp.dataItem(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.dataPair = function (dataItem, dataIndex) {
                vp.dataPair(this.elem, dataItem, dataIndex);
                return this;
            };

            //---- warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. ----
            singleWrapperClass.prototype.dataBind = function (bindingName, data, pkFunc, isNewData) {
                return vp.dataBind(this.elem, this, bindingName, data, pkFunc, isNewData);
            };

            singleWrapperClass.prototype.to = function (x, y) {
                vp.to(this.elem, x, y);
                return this;
            };

            singleWrapperClass.prototype.from = function (x, y) {
                vp.from(this.elem, x, y);
                return this;
            };

            singleWrapperClass.prototype.attach = function (name, callBack) {
                vp.attach(this.elem, name, callBack);
                return this;
            };

            singleWrapperClass.prototype.detach = function (name, callBack) {
                vp.detach(this.elem, name, callBack);
                return this;
            };

            singleWrapperClass.prototype.transform = function (value) {
                if (arguments.length == 0) {
                    return vp.transform(this.elem);
                }

                vp.transform(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.translate = function (x, y) {
                vp.translate(this.elem, x, y);
                return this;
            };

            singleWrapperClass.prototype.transformOrigin = function (value) {
                if (arguments.length == 0) {
                    return vp.transformOrigin(this.elem);
                }

                vp.transformOrigin(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.href = function (value) {
                if (arguments.length == 0) {
                    return vp.href(this.elem);
                }

                vp.href(this.elem, value);
                return this;
                // return vp.attrNS("http://www.w3.org/1999/xlink", "href", value);
            };

            singleWrapperClass.prototype.safeHref = function (value, fallback) {
                if ((!value) || (value.length == 0)) {
                    value = fallback;
                }

                vp.href(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.font = function (family, size, weight, style) {
                vp.font(this.elem, family, size, weight, style);
                return this;
            };

            singleWrapperClass.prototype.setClass = function (value) {
                vp.setClass(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.hasClass = function (value) {
                var returnValue = vp.hasClass(this.elem, value);
                return returnValue;
            };

            singleWrapperClass.prototype.addClass = function (value) {
                vp.addClass(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.removeClass = function (value) {
                vp.removeClass(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.toggleClass = function (value) {
                vp.toggleClass(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.id = function (value) {
                if (arguments.length == 0) {
                    return vp.id(this.elem);
                }

                vp.id(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.getBounds = function (relToParent) {
                return vp.getBounds(this.elem, relToParent);
            };

            singleWrapperClass.prototype.center = function (cx, cy) {
                vp.center(this.elem, cx, cy);
                return this;
            };

            singleWrapperClass.prototype.position = function (x, y) {
                vp.position(this.elem, x, y);
                return this;
            };

            singleWrapperClass.prototype.absPosition = function (left, top) {
                vp.absPosition(this.elem, left, top);
                return this;
            };

            singleWrapperClass.prototype.opacity = function (value) {
                if (arguments.length == 0) {
                    return vp.opacity(this.elem);
                }

                vp.opacity(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.radius = function (value) {
                if (arguments.length == 0) {
                    return vp.radius(this.elem);
                }

                vp.radius(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.attr = function (name, value) {
                if (arguments.length == 1) {
                    return vp.attr(this.elem, name);
                }

                vp.attr(this.elem, name, value);
                return this;
            };

            singleWrapperClass.prototype.customAttr = function (name, value) {
                if (arguments.length == 1) {
                    return vp.customAttr(this.elem, name);
                }

                vp.customAttr(this.elem, name, value);
                return this;
            };

            singleWrapperClass.prototype.remove = function () {
                vp.remove(this.elem);
                return this;
            };

            singleWrapperClass.prototype.toolTipEnabled = function (value) {
                if (arguments.length == 0) {
                    return vp.toolTipEnabled(this.elem);
                }

                vp.toolTipEnabled(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    return vp.height(this.elem);
                }

                vp.height(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    return vp.width(this.elem);
                }

                vp.width(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.totalHeight = function () {
                return vp.totalHeight(this.elem);
            };

            singleWrapperClass.prototype.totalWidth = function () {
                return vp.totalWidth(this.elem);
            };

            singleWrapperClass.prototype.left = function (value) {
                if (arguments.length == 0) {
                    return vp.left(this.elem);
                }

                vp.left(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.top = function (value) {
                if (arguments.length == 0) {
                    return vp.top(this.elem);
                }

                vp.top(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.checked = function (value) {
                if (arguments.length == 0) {
                    return vp.checked(this.elem);
                }

                vp.checked(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.clear = function () {
                vp.clear(this.elem);
                return this;
            };

            singleWrapperClass.prototype.add = function (content) {
                var elems = vp.add(this.elem, content);
                var ss = vp.wrapElements(elems);

                return ss;
            };

            singleWrapperClass.prototype.append = function (content) {
                var ss = vp.append(this.elem, content);
                return ss;
            };

            singleWrapperClass.prototype.prepend = function (content) {
                var ss = vp.prepend(this.elem, content);
                return ss;
            };

            singleWrapperClass.prototype.insertBefore = function (content) {
                var ss = vp.insertBefore(this.elem, content);
                return ss;
            };

            singleWrapperClass.prototype.insertAfter = function (content) {
                var ss = vp.insertAfter(this.elem, content);
                return ss;
            };

            singleWrapperClass.prototype.addStop = function (offset, color, opacity) {
                vp.addStop(this.elem, offset, color, opacity);
                return this;
            };

            singleWrapperClass.prototype.animate = function (duration, ease, container) {
                vp.animate(this.elem, duration, ease, container);
                return this;
            };

            singleWrapperClass.prototype.frameRateChanged = function (callBack) {
                vp.frameRateChanged(this.elem, callBack);
            };

            /// creates a new selectedSet from the current this.elem and the specified element/array.
            singleWrapperClass.prototype.merge = function (elemOrArray) {
                var newElements = null;

                if (elemOrArray instanceof vp.selectedSet) {
                    elemOrArray = elemOrArray.toArray();
                } else if (elemOrArray instanceof vp.visuals.singleWrapperClass) {
                    elemOrArray = elemOrArray.elem;
                }

                if (vp.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                } else {
                    newElements = this.toArray();
                    newElements.push(elemOrArray);
                }

                var newSet = new vp.selectedSet(newElements);

                return newSet;
            };

            singleWrapperClass.prototype.toArray = function () {
                return [this.elem];
            };

            singleWrapperClass.prototype.wrap = function (index) {
                var we = null;

                if (index == 0) {
                    we = vp.wrapElements(this.elem);
                }

                return we;
            };

            singleWrapperClass.prototype.kids = function () {
                var kids = vp.children(this.elem);
                var wrappedKids = vp.wrapElements(kids);

                return wrappedKids;
            };

            singleWrapperClass.prototype.each = function (callback) {
                //---- pass our element to callback as wrapped ("this") ----
                callback.call(this, 0, this);
                return this;
            };

            singleWrapperClass.prototype.elementSizes = function (callBack) {
                return vp.elementSizes(this.elem, callBack);
            };

            singleWrapperClass.prototype.focus = function () {
                vp.focus(this.elem);
                return this;
            };

            singleWrapperClass.prototype.background = function (value) {
                if (arguments.length == 0) {
                    return vp.background(this.elem);
                }

                vp.background(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.dataId = function (value) {
                if (arguments.length == 0) {
                    return vp.dataId(this.elem);
                }

                vp.dataId(this.elem, value);
                return this;
            };

            singleWrapperClass.prototype.shapeId = function (value) {
                if (arguments.length == 0) {
                    return vp.shapeId(this.elem);
                }

                vp.shapeId(this.elem, value);
                return this;
            };
            return singleWrapperClass;
        })();
        visuals.singleWrapperClass = singleWrapperClass;

        function createSingleWrapper(elem) {
            return new singleWrapperClass(elem);
        }
        visuals.createSingleWrapper = createSingleWrapper;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataGrid.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates an HTML-based dataGrid control.  The current implementation is readonly.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /// signature: vp.visuals.createDataGrid()
        ///     summary: creates an HTML readonly data grid (table) for the specified data
        ///     snippet: _aray = [-5, 3, 0, 3];
        ///     snippet: _myGrid = vp.visuals.createDataGrid().data(aray);
        ///     returns: the newly created data grid parent element.
        /** Builds an HTML table that displays the rows & cols in "data".  returns the control that can be used
        to configure properties and hook events.  The root HTML element can be accessed thru "control.element()". */
        var dataGridClass = (function (_super) {
            __extends(dataGridClass, _super);
            function dataGridClass() {
                _super.call(this, null);
                this.ctr = "vp.visuals.dataGrid";
                //---- property variables ----
                this._showHdr = true;
                this._showAltLines = true;
                this._showDividers = true;
                this._boldFirstCol = false;
                this._isHeaderLocked = false;
                this._data = null;
                this._columnNames = null;
                this._buildNeeded = false;
                this._timer = null;
                this._dividerColor = "#ccc";
                this._headerRow = null;
                this._lockedHeaderRow = null;
                this._divTableHolder = null;
                // public method to rebuild the datagrid synchronously ----
                this.buildNow = function () {
                    this.build();
                };
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    if (this._buildNeeded) {
                        this.build();
                    }

                    return this._rootElement;
                };
                //---- property: data ----
                this.data = function (value) {
                    if (value === undefined) {
                        return this._data;
                    }

                    this._data = value;
                    this.markRebuildNeeded();
                    return this;
                };
                this.markRebuildNeeded = function () {
                    var _this = this;
                    if (!this._buildNeeded) {
                        this._buildNeeded = true;
                        this._timer = setTimeout(function (e) {
                            return _this.build();
                        }, 1);
                    }
                };
                //---- property: showHeader ----
                this.showHeader = function (value) {
                    if (value === undefined) {
                        return this._showHdr;
                    }

                    this._showHdr = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: showAltLines ----
                this.showAltLines = function (value) {
                    if (value === undefined) {
                        return this._showAltLines;
                    }

                    this._showAltLines = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: showDividers ----
                this.showDividers = function (value) {
                    if (value === undefined) {
                        return this._showDividers;
                    }

                    this._showDividers = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: boldFirstColumn ----
                this.boldFirstColumn = function (value) {
                    if (value === undefined) {
                        return this._boldFirstCol;
                    }

                    this._boldFirstCol = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: isHeaderLocked ----
                this.isHeaderLocked = function (value) {
                    if (value === undefined) {
                        return this._isHeaderLocked;
                    }

                    this._isHeaderLocked = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: columnNames ----
                this.columnNames = function (value) {
                    if (value === undefined) {
                        return this._columnNames;
                    }

                    this._columnNames = value;
                    this.markRebuildNeeded();

                    return this;
                };
                /// internal.
                this.addDataGridCol = function (row, dataItem, showDividers, colNum, boldFirstCol) {
                    var td = document.createElement("td");

                    row.appendChild(td);
                    vp.setClass(td, "dataGridCell");

                    if ((colNum == 0) && (boldFirstCol)) {
                        //vp.css(td, "font-weight", "bold");
                        vp.css(td, "color", "#808080");
                    } else {
                        //vp.css(td, "color", "black");     // let styleSheet specify this
                    }

                    if (!showDividers) {
                        vp.css(td, "border", "none");
                    } else {
                        vp.css(td, "border", "1px solid " + this._dividerColor);
                    }

                    vp.css(td, "padding-left", "4px");
                    vp.css(td, "padding-right", "4px");

                    td.textContent = dataItem.toString();
                };

                var rootElem = vp.createHtml("div");
                this._rootElement = rootElem;
                this._root = vp.select(this._rootElement);

                rootElem.control = this;

                //element = rootElem;
                this.element(rootElem); // set wrapper root element
                //this.build();
                //this._rootElement.control = this;;
            }
            dataGridClass.prototype.build = function () {
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }
                this._buildNeeded = false;

                this._root.clear();

                var table = this._root.append("table")[0];
                vp.setClass(table, "dataGrid");

                if (!this._showDividers) {
                    vp.css(table, "border", "none");
                    vp.attr(table, "rules", "none");
                }

                if (this._data && this._data.length) {
                    var data = this._data;
                    var colNames = ["col1"];

                    for (var i = 0; i < data.length; i++) {
                        var row = document.createElement("tr");
                        table.appendChild(row);

                        if (!this._showDividers) {
                            vp.css(row, "border", "none");
                        }

                        if ((!this._showAltLines) || (i % 2 == 0)) {
                            vp.setClass(row, "dataGrid");
                        } else {
                            vp.setClass(row, "dataGrid altRow");
                        }

                        var dataRow = data[i];

                        if (dataRow.length != null) {
                            for (var c = 0; c < dataRow.length; c++) {
                                this.addDataGridCol(row, dataRow[c], this._showDividers, c, this._boldFirstCol);

                                if ((this._showHdr) && (i == 0)) {
                                    //---- build column names from first row ----
                                    colNames[c] = "col" + (c + 1);
                                }
                            }

                            var colCount = Math.max(colCount, dataRow.length);
                        } else if (vp.isNumber(dataRow)) {
                            //---- single column ----
                            this.addDataGridCol(row, dataRow, this._showDividers, 0, this._boldFirstCol);
                        } else {
                            var atCount = 0;

                            for (var atName in dataRow) {
                                this.addDataGridCol(row, dataRow[atName], this._showDividers, atCount, this._boldFirstCol);

                                if ((this._showHdr) && (i == 0)) {
                                    //---- build column names from first row ----
                                    colNames[atCount] = atName;
                                }

                                atCount++;
                            }
                        }
                    }

                    //---- after all records processed (and all cols seen), add COL HEADERS ----
                    if (this._showHdr) {
                        this.buildHeader(colNames, table);
                    }
                }

                //table.setAttribute("cellspacing", 15);
                //table.setAttribute("cellpadding", 4);
                vp.setClass(table, "dataGrid");
            };

            dataGridClass.prototype.buildHeader = function (colNames, table) {
                //---- create row to hold headers ----
                var headerRow = document.createElement("tr");
                var lockedHeaderRow = null;

                if (table.childNodes.length) {
                    table.insertBefore(headerRow, table.childNodes[0]);
                } else {
                    table.appendChild(headerRow);
                }

                if (this._columnNames) {
                    colNames = this._columnNames;
                }

                if (this._isHeaderLocked) {
                    //---- create a separate table for the headers so it doesn't scroll with the table ----
                    var headerOnlyTable = this._root.append("table")[0];
                    vp.setClass(headerOnlyTable, "dataGridLockedHeader");

                    //this._root.css("background", "#f0f0f0")
                    //---- create a div to hold our main table ----
                    var divTableHolder = this._root.append("div").css("overflow-y", "scroll").css("display", "inline-block").css("width", "100%");

                    this._divTableHolder = divTableHolder;

                    divTableHolder.append(table);
                    vp.select(table).css("width", "100%");

                    //---- will need to create a 2nd header row ----
                    lockedHeaderRow = document.createElement("tr");
                    headerOnlyTable.appendChild(lockedHeaderRow);

                    //---- make headerRow collapsed so that it doesn't show (but still helps calc col widths) ----
                    vp.css(headerRow, "visibility", "collapse");
                }

                for (var i = 0; i < colNames.length; i++) {
                    this.addHeaderCol(headerRow, colNames[i]);

                    if (lockedHeaderRow) {
                        this.addHeaderCol(lockedHeaderRow, colNames[i]);
                    }
                }

                if (this._isHeaderLocked) {
                    this.addHeaderCol(lockedHeaderRow, ""); // add filler column at end
                    vp.css(headerOnlyTable, "width", "100%");

                    this._headerRow = headerRow;
                    this._lockedHeaderRow = lockedHeaderRow;

                    this.scheduleResize();
                    this.resizeHeaderColsAndTable();

                    //---- when we are resized, match columns sizes & table height ----
                    vp.attach(this.elem, "resize", vp.cb(this, this.scheduleResize));
                }
            };

            dataGridClass.prototype.scheduleResize = function () {
                var _this = this;
                setTimeout(function (e) {
                    return _this.resizeHeaderColsAndTable();
                }, 1000);
            };

            dataGridClass.prototype.addHeaderCol = function (headerRow, colName) {
                var th = document.createElement("th");
                th.setAttribute("align", "left");

                if (!this._showDividers) {
                    vp.css(th, "border", "none");
                } else {
                    vp.css(th, "border", "1px solid " + this._dividerColor);
                }

                headerRow.appendChild(th);

                th.textContent = colName;
            };

            dataGridClass.prototype.resizeHeaderColsAndTable = function () {
                //---- use hdrRow to set column widths in lockedHeaderRow ----
                var hdrRow = vp.select(this._headerRow).kids();
                var lockedRow = vp.select(this._lockedHeaderRow).kids();

                for (var i = 0; i < hdrRow.length; i++) {
                    var w = vp.select(hdrRow[i]).width();
                    w = Math.max(0, w - 3); // adjust for padding, border
                    vp.select(lockedRow[i]).width(w);
                }

                //---- also, size divTableHolder" as table height ----
                var rootHeight = this._root.height();
                if (rootHeight > 0) {
                    var headerHeight = vp.height(this._lockedHeaderRow);
                    var tableHeight = Math.max(0, rootHeight - headerHeight);

                    this._divTableHolder.height(tableHeight - 0);
                }
            };
            return dataGridClass;
        })(vp.visuals.singleWrapperClass);
        visuals.dataGridClass = dataGridClass;

        function createDataGrid() {
            return new dataGridClass();
        }
        visuals.createDataGrid = createDataGrid;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// fastDataGrid.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates a Canvas-based virtual dataGrid control.  The current implementation is readonly.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /// signature: vp.visuals.createFastDataGrid()
        ///     summary: creates a Canvas-based virtual readonly data grid for the specified data
        ///     snippet: _aray = [-5, 3, 0, 3];
        ///     snippet: _myGrid = vp.visuals.createFastDataGrid().data(aray);
        ///     returns: the newly created data grid parent element.
        /** Builds a Canvas-based virtual data grid that displays the data found in a JSON array of records.  returns the control that can be used
        to configure properties and hook events.  The root HTML element can be accessed thru "control.element()". */
        var fastDataGridClass = (function (_super) {
            __extends(fastDataGridClass, _super);
            function fastDataGridClass() {
                var _this = this;
                _super.call(this, null);
                this.ctr = "vp.visuals.fastDataGrid";
                //---- property variables ----
                this._showHeader = true;
                this._showAltLines = true;
                this._showColDividers = true;
                this._showRowDividers = true;
                this._boldFirstCol = false;
                this._useMaxColWidths = false;
                this._maxColWidth = undefined;
                this._data = null;
                //---- other variables ----
                this._buildNeeded = false;
                this._timer = null;
                this._textHeight = 0;
                this._charWidth = 0;
                this._topRow = -1;
                this._numRowsVisible = 0;
                this._canvasWidth = 0;
                this._canvasHeight = 0;
                this._divWidth = 0;
                this._buildTimer = null;
                this._ignoreScrollBarChanges = false;
                this._padding = 2;
                this._drawTimer = null;
                this._usingVerticalScroll = false;
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    //if (this._buildNeeded)
                    //{
                    //    this.build();
                    //}
                    return this._rootElement;
                };
                //---- property: data ----
                this.data = function (value) {
                    if (value === undefined) {
                        return this._data;
                    }

                    this._data = value;
                    this.onNewData();

                    return this;
                };
                //---- property: showHdr ----
                this.showHeader = function (value) {
                    if (value === undefined) {
                        return this._showHeader;
                    }

                    this._showHeader = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showAltLines ----
                this.showAltLines = function (value) {
                    if (value === undefined) {
                        return this._showAltLines;
                    }

                    this._showAltLines = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showColDividers ----
                this.showColumnDividers = function (value) {
                    if (value === undefined) {
                        return this._showColDividers;
                    }

                    this._showColDividers = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showRowDividers ----
                this.showRowDividers = function (value) {
                    if (value === undefined) {
                        return this._showRowDividers;
                    }

                    this._showRowDividers = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: boldFirstCol ----
                this.boldFirstColumn = function (value) {
                    if (value === undefined) {
                        return this._boldFirstCol;
                    }

                    this._boldFirstCol = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: useMaxColWidths ----
                this.useMaxColumnWidths = function (value) {
                    if (value === undefined) {
                        return this._useMaxColWidths;
                    }

                    this._useMaxColWidths = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: maxColWidth ----
                this.maxColumnWidth = function (value) {
                    if (value === undefined) {
                        return this._maxColWidth;
                    }

                    this._maxColWidth = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: colInfo ----
                this.columnInfo = function (value) {
                    if (value === undefined) {
                        return this._colInfo;
                    }

                    this._colInfo = value;
                    this.markBuildNeeded();

                    return this;
                };

                //---- create CONTROLS ----
                var rootElem = vp.createHtml("div");
                this._rootElement = rootElem;
                this._root = vp.select(this._rootElement).setClass("dataGrid").css("position", "absolute");

                rootElem.control = this;
                this.element(rootElem); // set wrapper root element

                var canvasDiv = vp.createHtml("div");
                this._canvasDiv = canvasDiv;
                rootElem.appendChild(canvasDiv);

                var canvas = vp.createHtml("canvas");
                this._canvas = canvas;
                canvasDiv.appendChild(canvas);

                vp.select(canvasDiv).css("position", "absolute");

                this._ctx = canvas.getContext("2d");

                var scrollBar = vp.visuals.verticalScrollBar();
                rootElem.appendChild(scrollBar);
                this._scrollBar = vp.select(scrollBar).css("position", "absolute").css("display", "none");

                this._scrollBar.attach("change", function (e) {
                    return _this.onScrollChange();
                });

                vp.attach(rootElem, "resize", function (e) {
                    return _this.markBuildNeeded();
                });

                //---- get initial size, etc. ----
                this.markBuildNeeded();
            }
            fastDataGridClass.prototype.onScrollChange = function () {
                if (!this._ignoreScrollBarChanges) {
                    var value = this._scrollBar.value();
                    this.setTopRow(value);
                }
            };

            fastDataGridClass.prototype.markBuildNeeded = function () {
                var _this = this;
                if (this._buildTimer) {
                    clearTimeout(this._buildTimer);
                }

                this._buildTimer = setTimeout(function (e) {
                    return _this.build();
                }, 25);
            };

            fastDataGridClass.prototype.computeX = function (left, right, spacing, align) {
                var x = left + spacing;

                if (align == "center") {
                    x = (right + left) / 2;
                } else if (align == "right") {
                    x = right - spacing;
                }

                return x;
            };

            fastDataGridClass.prototype.drawGridRow = function (ctx, maxRight, y, isOdd, record) {
                var colInfo = this._colInfo;
                var left = 2;
                var padding = this._padding;
                var textHeight = this._textHeight;

                //---- read relevent attributes from current theme ----
                var daHdrRow = vp.currentTheme().getDrawingAttributes("fastDataGrid.hdrRow");
                var daDataRow = vp.currentTheme().getDrawingAttributes("fastDataGrid.dataRow");
                var daAltRow = vp.currentTheme().getDrawingAttributes("fastDataGrid.altRow");
                var daDivider = vp.currentTheme().getDrawingAttributes("fastDataGrid.divider");

                var hdrFont = daHdrRow.font;
                var dataFont = daDataRow.font;
                var altFont = daAltRow.font;

                ctx.font = (record) ? dataFont : hdrFont;
                ctx.fillStyle = (record) ? daDataRow.fill : daHdrRow.fill;

                //---- draw alt background color, if odd ----
                if (this._showAltLines) {
                    if (isOdd) {
                        //---- alt row background ----
                        ctx.save();
                        ctx.fillStyle = daAltRow.background;
                        ctx.fillRect(0, y - textHeight + .5, this._canvasWidth, textHeight - 1);
                        ctx.restore();

                        ctx.fillStyle = daAltRow.fill;
                        ctx.font = altFont;
                    } else if (!record) {
                        //---- hdr background ----
                        ctx.save();
                        ctx.fillStyle = daHdrRow.background;
                        ctx.fillRect(0, y - textHeight - .5, this._canvasWidth, textHeight + 1);
                        ctx.restore();
                    }
                }

                for (var k = 0; k < colInfo.length; k++) {
                    if (this._boldFirstCol && record) {
                        if (k == 0) {
                            ctx.font = daDataRow.boldFont;
                        } else if (k == 1) {
                            ctx.font = dataFont;
                        }
                    }

                    var ci = colInfo[k];

                    //---- note: ci.actualWidth includes padding and border ----
                    var right = Math.min(maxRight, left + ci.actualWidth - 2 * padding - 1);

                    //---- clip text so that it doesn't spill over into padding or next field ----
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(left, y - textHeight, ci.actualWidth, textHeight); //  right - left, textHeight);
                    ctx.clip();

                    if (record) {
                        //---- drawing data row ----
                        ctx.textAlign = ci.dataAlign;
                        var x = this.computeX(left, right, padding, ctx.textAlign);
                        var value = record[ci.dataName];
                        ctx.fillText(value, x, y);
                    } else {
                        //---- drawing hdr row ----
                        ctx.textAlign = ci.hdrAlign;
                        var x = this.computeX(left, right, padding, ctx.textAlign);
                        ctx.fillText(ci.hdrName, x, y);
                    }

                    ctx.restore();
                    left = (right + 1 + 2 * padding);
                }

                if (this._showRowDividers) {
                    //---- draw bottom line ----
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this._canvasWidth, y);
                    ctx.strokeStyle = daDivider.stroke; // "#a0a0a0";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            };

            fastDataGridClass.prototype.draw = function () {
                if (this._drawTimer) {
                    //cancelAnimationFrame(this._drawTimer);
                    this._drawTimer = null;
                }

                //---- clear the canvas ----
                var ctx = this._ctx;
                var data = this._data;

                //---- clear client area using color of data row background ----
                var daDataRow = vp.currentTheme().getDrawingAttributes("fastDataGrid.dataRow");
                ctx.fillStyle = daDataRow.background;
                ctx.fillRect(0, 0, this._canvasWidth, this._canvasHeight);

                ctx.textBaseline = "bottom";

                var clientWidth = this._canvasWidth;
                var padding = this._padding;
                var maxRight = clientWidth - padding;
                var colInfo = this._colInfo;

                if (this._colInfo && data && data.length) {
                    var y = .5;

                    if (this._showHeader) {
                        y += this._textHeight;
                        this.drawGridRow(ctx, maxRight, y, false, null);
                    }

                    //---- draw rows ----
                    ctx.fillStyle = "gray";
                    var isOdd = true;

                    for (var r = 0; r < this._numRowsVisible; r++) {
                        var index = this._topRow + r;
                        if (index >= data.length) {
                            //---- past last record ----
                        } else {
                            y += this._textHeight;
                            this.drawGridRow(ctx, maxRight, y, isOdd, data[index]);
                        }

                        isOdd = (!isOdd);
                    }

                    if (this._showColDividers) {
                        var x = 0;
                        var daDivider = vp.currentTheme().getDrawingAttributes("fastDataGrid.divider");

                        for (var k = 0; k < colInfo.length; k++) {
                            //---- don't draw right-most border if there is no vertical scrollbar ----
                            if ((!this._usingVerticalScroll) && (k == colInfo.length - 1)) {
                                break;
                            }

                            //---- draw right border ----
                            var ci = colInfo[k];

                            //---- note: ci.actualWidth includes padding & border space ----
                            x += ci.actualWidth;

                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, this._canvasHeight);
                            ctx.strokeStyle = daDivider.stroke; // "#a0a0a0";
                            ctx.stroke();
                        }
                    }
                }
            };

            fastDataGridClass.prototype.layoutControls = function (canvasWidth, omitCalcCols) {
                var w = this._root.width();
                var h = this._root.height();

                var usingVerticalScroll = (this._data && this._data.length > this._numRowsVisible);

                var sw = (usingVerticalScroll) ? 20 : 5;
                var divWidth = Math.max(0, w - sw);
                var canvasDiv = vp.select(this._canvasDiv);

                if (canvasWidth === undefined) {
                    canvasWidth = divWidth;
                }

                if (canvasWidth > divWidth) {
                    canvasDiv.css("overflow-x", "scroll").css("overflow-y", "hidden");
                } else {
                    canvasDiv.css("overflow-x", "hidden").css("overflow-y", "hidden");
                }

                //---- layout CANVAS ----
                vp.select(this._canvas).attr("width", canvasWidth).attr("height", h);

                //---- layout CANVAS DIV ----
                vp.select(this._canvasDiv).css("width", divWidth).css("height", h);

                //---- layout vertical SCROLLBAR ----
                if (usingVerticalScroll) {
                    this._scrollBar.bounds(divWidth, 0, sw, h).css("display", "inline-block");
                } else {
                    this._scrollBar.css("display", "none");
                }

                this._usingVerticalScroll = usingVerticalScroll;

                this._canvasWidth = canvasWidth;
                this._divWidth = divWidth;
                this._canvasHeight = h;

                if (!omitCalcCols) {
                    this.calcColumnWidths(divWidth);
                }
            };

            /** Called primarily after RESIZE of dataGrid control has occured. */
            fastDataGridClass.prototype.build = function () {
                this._buildTimer = null;
                var h = this._root.height();

                //---- calc number of rows visible in canvas ----
                var sz = vp.measureText("W", "fastDataGrid");
                var height = Math.ceil(sz.height);
                this._textHeight = height;

                //---- get max accuracy for char width ----
                this._charWidth = this._ctx.measureText("W").width;
                this._charWidth *= 1.05; // add 5% to get better results  (measureText() doesn't seem to be totally accurate)

                this._numRowsVisible = Math.floor(h / height);
                if (this._showHeader) {
                    this._numRowsVisible--;
                }

                this.layoutControls();

                this.configScrollbar();

                this.markDrawNeeded();
            };

            fastDataGridClass.prototype.markDrawNeeded = function () {
                var _this = this;
                if (!this._drawTimer) {
                    //this._drawTimer = requestAnimationFrame((e) => this.draw());
                    this._drawTimer = setTimeout(function (e) {
                        return _this.draw();
                    }, 125);
                }
            };

            fastDataGridClass.prototype.configScrollbar = function () {
                var data = this._data;
                if (data && data.length) {
                    var count = data.length;
                    var lastTopRecord = Math.max(0, count - this._numRowsVisible);

                    //---- set up scrollbar ----
                    this._scrollBar.min(0).max(lastTopRecord).value(0).smallChange(1).largeChange(Math.max(1, this._numRowsVisible));
                }
            };

            fastDataGridClass.prototype.onNewData = function () {
                this.configScrollbar();

                this._colInfo = null;

                this.setUpColInfo();

                this.setTopRow(0);
            };

            fastDataGridClass.prototype.setTopRow = function (value) {
                this._topRow = value;
                this._ignoreScrollBarChanges = true;

                this._scrollBar.value(value);

                this._ignoreScrollBarChanges = false;

                this.markDrawNeeded();
            };

            fastDataGridClass.prototype.setUpColInfo = function () {
                var colInfo = this._colInfo;
                var data = this._data;
                var clientWidth = this._root.width();

                if (data && data.length) {
                    if (!colInfo) {
                        colInfo = [];

                        //---- build default column info ----
                        var firstRec = data[0];
                        var keys = vp.keys(firstRec);

                        for (var k = 0; k < keys.length; k++) {
                            var key = keys[k];

                            var col = {
                                hdrName: key, dataName: key, hdrAlign: "left", dataAlign: "left", requestedWidth: undefined, actualWidth: undefined
                            };
                            colInfo[k] = col;
                        }

                        this._colInfo = colInfo;
                    }

                    this.calcColumnWidths(clientWidth);
                }
            };

            /** calc the largest string for hdr/data rows of col "index". */
            fastDataGridClass.prototype.getMaxColWidth = function (index) {
                var maxLen = 0;
                var data = this._data;

                if (this._colInfo) {
                    maxLen = this._colInfo[index].hdrName.length;
                    var colName = this._colInfo[index].dataName;

                    if (data && data.length) {
                        for (var i = 0; i < data.length; i++) {
                            var record = data[i];
                            var len = (record[colName] + "").length;
                            if (len > maxLen) {
                                maxLen = len;
                            }
                        }
                    }
                }

                var width = 1 + 2 * this._padding + (maxLen * this._charWidth);
                vp.debug("getMaxColWidth: maxLen=" + maxLen + ", width=" + width);

                return width;
            };

            fastDataGridClass.prototype.calcColumnWidths = function (clientWidth) {
                var colInfo = this._colInfo;
                if (colInfo && colInfo.length) {
                    var cw = clientWidth / colInfo.length;
                    var cwTotal = 0;

                    for (var k = 0; k < colInfo.length; k++) {
                        if (colInfo[k].requestedWidth === undefined) {
                            if (this._useMaxColWidths) {
                                cw = this.getMaxColWidth(k);
                            }
                        } else {
                            cw = colInfo[k].requestedWidth;
                        }

                        if ((this._maxColWidth !== undefined) && (cw > this._maxColWidth)) {
                            cw = this._maxColWidth;
                        }

                        colInfo[k].actualWidth = cw;
                        cwTotal += cw;
                    }

                    var availWidth = this._divWidth;

                    if ((this._useMaxColWidths) && (cwTotal < availWidth)) {
                        var delta = (availWidth - cwTotal);
                        var perCol = delta / colInfo.length;

                        for (var k = 0; k < colInfo.length; k++) {
                            colInfo[k].actualWidth += perCol;
                        }

                        cwTotal += delta;
                    }

                    cwTotal = Math.max(this._canvasWidth, cwTotal);

                    //---- make canvas wider than original, if needed ----
                    this.layoutControls(cwTotal, true);
                }
            };
            return fastDataGridClass;
        })(vp.visuals.singleWrapperClass);
        visuals.fastDataGridClass = fastDataGridClass;

        function createFastDataGrid() {
            return new fastDataGridClass();
        }
        visuals.createFastDataGrid = createFastDataGrid;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// plot.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - this implements a standard chart, with support for this._title, legend, axes, and ribbon.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        var nextPlotId = 1;

        /** implements a standard chart, with support for this._title, legend, axes, and ribbon. */
        var plotClass = (function (_super) {
            __extends(plotClass, _super);
            function plotClass() {
                _super.call(this, null);
                this.ctr = "vp.visuals.plotClass";
                //---- private state (from vvPlot) ----
                this._layers = [];
                //---- plot-only property variables ----
                this._plotId = nextPlotId++;
                this._isAnimEnabled = true;
                this._isUiEnabled = true;
                this._isHoverEnabled = true;
                this._isSelectionEnabled = true;
                this._isTooltipEnabled = true;
                this._isXAxisVisible = true;
                this._isXGridVisible = true;
                this._isYAxisVisible = true;
                this._isYGridVisible = true;
                this._isTitleVisible = true;
                this._isLegendVisible = true;
                this._isAxisBoxVisible = true;
                this._xLabelFit = undefined;
                this._onError = undefined;
                this._gridLineType = 1;
                this._showBoxTicks = false;
                this._drawTicksOnInside = false;
                //_toolTipFormatter = undefined;        // for now, use the layer.toolTipFormatter()
                this._shapesEnterFromBottom = null;
                this._showRibbon = false;
                this._title = "";
                this._xLimit = undefined;
                this._yLimit = undefined;
                //_xLabel = undefined;      // moved to attribute as "title" property
                //_yLabel = undefined;
                this._titleSize = 14;
                this._ribbonBar = null;
                this._frameMargins = null;
                this._selectCallback = null;
                this._rebuildCallback = null;
                this._tooltip = null;
                this._chartFrame = null;
                this._plotShapes = null;
                this._useStdTooltips = true;
                this._rcShapes = null;
                this._htmlShapesGroup = null;
                this._postCreateCallback = null;
                this._hoverCallback = null;
                //---- should these properties be in vvMappings? ----
                //_toolTipCols = true;             // defaults to "all columns"
                this._nextDataId = 3;
                this._rootElement = null;
                this._rootDiv = null;
                this._svgDoc = null;
                //---- these variables hold the parts of the chart we have built ----
                this._chartFrameGroup = null;
                this._shapesGroup = null;
                this._tooltipDiv = null;
                //---- removed use of "_spacesDoc" as of 8/7/2013.  at the time, thought it was causing mouse event ----
                //---- problems (but it was not).  Left it out since it complicates things (design, debugging) ----
                //---- Note: we now do clipping using "clip-path". ----
                //_shapesDoc = null;                 // nested SVG document (wrapped, parent: this._svgDoc)
                this._uiStateMgr = null;
                this._chartType = undefined;
                this._xScale = null;
                this._yScale = null;
                this._timer = null;
                this._xMin = 0;
                this._xMax = 0;
                this._yMin = 0;
                this._yMax = 0;

                var rootElem = vp.createHtml("div");
                this._rootElement = rootElem;
                this._rootDiv = vp.select(rootElem);

                rootElem.control = this;

                //element = rootElem;
                this.element(rootElem); // set wrapper root element

                this.initialBuild();
            }
            //---- property: rootElement ----
            plotClass.prototype.rootElement = function () {
                return this._rootElement;
            };

            plotClass.prototype.getNextDataId = function () {
                var id = this._nextDataId;
                this._nextDataId++;

                return id;
            };

            plotClass.prototype.clearLayers = function () {
                this._uiStateMgr.plotShapes([]);
                this._layers = [];

                //---- this is the only time is OK to directly clear the shapesGroup ----
                this._shapesGroup.clear();

                this.addOrUpdateClipPath(this._shapesGroup, this._rcShapes.width, this._rcShapes.height);

                this.markRebuildNeeded();
            };

            plotClass.prototype.append = function (strOrLayer) {
                var layer = null;

                if ((strOrLayer) && (strOrLayer.ctr) && (strOrLayer.ctr.startsWith("vp.layers"))) {
                    layer = strOrLayer;

                    layer.vvParent(this);

                    //---- append an existing layer object ----
                    this._layers.push(layer);
                    //layer.onPlotDataChanged(true);
                } else {
                    if (strOrLayer.startsWith("layer")) {
                        var layerType = strOrLayer.substr(4).toLowerCase();

                        layer = vp.vvLayer();
                        this._layers.push(layer);

                        layer.layerType(layerType);
                        layer.vvParent(this);
                    } else if (strOrLayer.startsWith("stat")) {
                        var statType = strOrLayer.substr(4).toLowerCase();

                        layer = vp.vvLayer();
                        this._layers.push(layer);

                        layer.statType(statType);
                        layer.vvParent(this);
                    }

                    if (layer) {
                        //layer.onPlotDataChanged(true);
                    }
                }

                this.markRebuildNeeded();
                return layer;
            };

            plotClass.prototype.removeLayer = function (layer) {
                this._layers.remove(layer);

                //---- remove each shape drawn by this layer (from this._shapesGroup and from this._uiStateMgr) ----
                if (layer.drawnShapes) {
                    var shapes = layer.drawnShapes;
                    this._plotShapes = this._uiStateMgr.plotShapes().toArray();

                    for (var i = 0; i < shapes.length; i++) {
                        var shape = shapes[i];
                        vp.remove(shape); // remove it from this._shapesGroup

                        this._plotShapes.remove(shape);
                    }

                    var ps = vp.wrapElements(this._plotShapes);
                    this._uiStateMgr.plotShapes(ps);
                }

                layer.vvParent(null);

                this.markRebuildNeeded();
            };

            plotClass.prototype.layers = function () {
                return this._layers;
            };

            //---- property: this._showRibbon ----
            plotClass.prototype.showRibbon = function (value) {
                if (arguments.length == 0) {
                    return this._showRibbon;
                }

                this._showRibbon = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: shapesEnterFromBottom ----
            plotClass.prototype.shapesEnterFromBottom = function (value) {
                if (arguments.length == 0) {
                    return this._shapesEnterFromBottom;
                }

                if (this._shapesEnterFromBottom != value) {
                    this._shapesEnterFromBottom = value;
                    //---- don't rebuild just to see enter effect a different way ----
                    //this.markRebuildNeeded();
                }

                return this;
            };

            //---- property: this._title ----
            plotClass.prototype.title = function (value) {
                if (arguments.length == 0) {
                    return this._title;
                }

                this._title = value;
                this.markRebuildNeeded();

                return this;
            };

            plotClass.prototype.isAnimEnabled = function (value) {
                vp.argCheck(arguments, "isAnimEnabled", 0, 1, ['bool']);

                if (arguments.length == 0) {
                    return this._isAnimEnabled;
                }

                this._isAnimEnabled = value;

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.isAnimEnabled(this._isAnimEnabled);
                }

                return this;
            };

            plotClass.prototype.onToolTipsChanged = function () {
                if (this._tooltip) {
                    var enabled = ((this._isTooltipEnabled) && (!this._useStdTooltips));
                    this._tooltip.isEnabled(enabled);
                }
            };

            //---- property: this._useStdTooltips ----
            plotClass.prototype.useStdTooltips = function (value) {
                if (arguments.length == 0) {
                    return this._useStdTooltips;
                }

                this._useStdTooltips = value;
                this.onToolTipsChanged();

                return this;
            };

            //---- property: this._postCreateCallback ----
            plotClass.prototype.postCreateCallback = function (value) {
                if (arguments.length == 0) {
                    return this._postCreateCallback;
                }

                this._postCreateCallback = value;

                return this;
            };

            //---- property: this._uiStateMgr ----
            plotClass.prototype.uiStateMgr = function (value) {
                return this._uiStateMgr;
            };

            //---- property: this._isUiEnabled ----
            plotClass.prototype.isUiEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isUiEnabled;
                }

                this._isUiEnabled = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.isUiEnabled(value);
                }

                this.markRebuildNeeded();

                return this;
            };

            //---- property: onError ----
            /** optional callback to record errors and return corrected values, when applicable. */
            plotClass.prototype.onError = function (value) {
                if (arguments.length == 0) {
                    return this._onError;
                }

                this._onError = value;
                return this;
            };

            //---- property: this._isHoverEnabled ----
            plotClass.prototype.isHoverEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isHoverEnabled;
                }

                this._isHoverEnabled = value;
                return this;
            };

            //---- property: this._isSelectionEnabled ----
            plotClass.prototype.isSelectionEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isSelectionEnabled;
                }

                this._isSelectionEnabled = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.isSelectionEnabled(value);
                }

                return this;
            };

            //---- property: this._isTooltipEnabled ----
            plotClass.prototype.isTooltipEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isTooltipEnabled;
                }

                this._isTooltipEnabled = value;
                this.onToolTipsChanged();

                return this;
            };

            //---- property: this._xLimit ----
            plotClass.prototype.xLimit = function (value) {
                if (arguments.length == 0) {
                    return this._xLimit;
                }

                if (arguments.length > 1) {
                    this._xLimit = vp.argumentsAsArray(arguments);
                } else {
                    this._xLimit = value;
                }

                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._yLimit ----
            plotClass.prototype.yLimit = function (value) {
                if (arguments.length == 0) {
                    return this._yLimit;
                }

                if (arguments.length > 1) {
                    this._yLimit = vp.argumentsAsArray(arguments);
                } else {
                    this._yLimit = value;
                }

                this.markRebuildNeeded();

                return this;
            };

            ////---- property: this._xLabel ----
            //xLabel(value?: string)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._xLabel;
            //    }
            //    this._xLabel = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ////---- property: this._yLabel ----
            //yLabel(value?: string)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._yLabel;
            //    }
            //    this._yLabel = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            //---- property: this._isXAxisVisible ----
            plotClass.prototype.isXAxisVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isXAxisVisible;
                }

                this._isXAxisVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._isYAxisVisible ----
            plotClass.prototype.isYAxisVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isYAxisVisible;
                }

                this._isYAxisVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: gridLineType ----
            plotClass.prototype.gridLineType = function (value) {
                if (arguments.length == 0) {
                    return this._gridLineType;
                }

                this._gridLineType = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isXGridVisible ----
            plotClass.prototype.isXGridVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isXGridVisible;
                }

                this._isXGridVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isYGridVisible ----
            plotClass.prototype.isYGridVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isYGridVisible;
                }

                this._isYGridVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._isTitleVisible ----
            plotClass.prototype.isTitleVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isTitleVisible;
                }

                this._isTitleVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            ////---- property: toolTipFormatter ----
            //toolTipFormatter(value?: boolean): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._toolTipFormatter;
            //    }
            //    this._toolTipFormatter = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            //---- property: drawTicksOnInside ----
            plotClass.prototype.drawTicksOnInside = function (value) {
                if (arguments.length == 0) {
                    return this._drawTicksOnInside;
                }

                this._drawTicksOnInside = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: showBoxTicks ----
            plotClass.prototype.showBoxTicks = function (value) {
                if (arguments.length == 0) {
                    return this._showBoxTicks;
                }

                this._showBoxTicks = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isAxisBoxVisible ----
            plotClass.prototype.isAxisBoxVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isAxisBoxVisible;
                }

                this._isAxisBoxVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this.isLegendVisible ----
            plotClass.prototype.isLegendVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isLegendVisible;
                }

                this._isLegendVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this.xLabelFit ----
            plotClass.prototype.xLabelFit = function (value) {
                if (arguments.length == 0) {
                    return this._xLabelFit;
                }

                this._xLabelFit = value;
                this.markRebuildNeeded();

                return this;
            };

            /// public: this._titleSize.
            plotClass.prototype.titleSize = function (value) {
                if (arguments.length == 0) {
                    return this._titleSize;
                }

                this._titleSize = value;
                this.markRebuildNeeded();

                return this;
            };

            //shapeRoot(value)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return shapeRoot;
            //    }
            //    shapeRoot = value;
            //    return this;
            //}
            /// private.
            plotClass.prototype.onShareNameChanged = function () {
                var shareName = vp.select("#tbShareName").value();
                this._uiStateMgr.shareName(shareName);
            };

            /// public: selectByKeys(keys)
            plotClass.prototype.selectByKeys = function (keys) {
                this._uiStateMgr.selectByKeys(keys);
            };

            /// public: onFilterChanged().
            plotClass.prototype.onFilterChanged = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.applyFilter(this._uiStateMgr.filter(), false, true);
                }

                //rebuildScales();
                this.markRebuildNeeded();
            };

            plotClass.prototype.markRebuildNeeded = function () {
                if (!this._timer) {
                    //vp.debug("plot.markBuildNeeded");
                    this._timer = setTimeout(vp.cb(this, this.rebuildChart), 10); // "1" causes too many rebuilds..?
                }
            };

            /// private: initialBuild().
            plotClass.prototype.initialBuild = function () {
                var _this = this;
                //this._mappings = vp.layers.createMappings()
                //    .vvParent(this);
                this._rootDiv.css("position", "relative");

                //---- disable browser menu on right click (in prep for our own local menu) ----
                document.oncontextmenu = function () {
                    return false;
                };

                this._svgDoc = this._rootDiv.append("svg").attr("overflow", "hidden");

                //---- create these 2 early so we can pass them off to this._uiStateMgr here ----
                //this._shapesDoc = this._svgDoc.append("svg")      // make this a nested SVG doc so we can control the "overflow" on it (clip shapes within this rect)
                //            .id("shapesDoc")
                //this._shapesGroup = this._shapesDoc.append("g")
                //            .id("shapesGroup")
                this._shapesGroup = this._svgDoc.append("g").id("shapesGroup");

                //shapesDiv = vp.select(document.body).append("div")
                //    .css("position", "absolute")
                //    .id("shapesDiv")
                //var rubberBandGroup = this._svgDoc.append("g")
                //            .id("rubberBandGroup")
                this._uiStateMgr = vp.uiStateMgr("plotClass", "vuePlot", this._svgDoc, this._shapesGroup, vp.cb(this, this.updateShapeVisuals), vp.cb(this, this.onFilterChanged));

                //---- build dynamic, rich this._tooltip ----
                this._tooltipDiv = vp.select(document.body).append("div").id("vvPlotTooltip").setClass("vpToolTip").css("padding", "5px").css("display", "none");

                //---- build rich tooltips on-demand, using "buildToolTip" function ----
                this._tooltip = new vp.toolTip(this._tooltipDiv[0], vp.cb(this, this.buildToolTipHelper));

                this._chartFrame = vp.createChartFrame();

                //---- when our ROOT DIV is resized using the vuePlot "width()" or "height()" functions, we rebuild the plot ----
                this._rootDiv.setClass("vpVvPlot").attach("resize", function () {
                    _this.markRebuildNeeded();
                });

                this.markRebuildNeeded();
            };

            // public READONLY property: this._shapesDoc
            plotClass.prototype.shapesDoc = function () {
                //return this._shapesDoc;
                return this._shapesGroup;
            };

            /// public READONLY property: this._shapesGroup
            plotClass.prototype.shapesGroup = function () {
                return this._shapesGroup;
            };

            /// public READONLY property: shapeRoot
            plotClass.prototype.svgRoot = function () {
                return this._svgDoc;
            };

            /// public: updateShapeVisuals().
            plotClass.prototype.updateShapeVisuals = function (selectionCount) {
                var daSelected = vp.currentTheme().getDrawingAttributes("selected");
                var daUnselected = vp.currentTheme().getDrawingAttributes("unselected");
                var daHover = vp.currentTheme().getDrawingAttributes("hover");

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.updateShapeVisuals(selectionCount, daSelected, daUnselected, daHover);
                }
            };

            plotClass.prototype.getUnmappedData = function (attr, length) {
                var value = (attr) ? attr.value() : undefined;
                var data = [];

                if (value !== undefined) {
                    if (vp.isArray(value)) {
                        data = value;
                    } else {
                        data = vp.dataRepeat(value, Math.max(1, length));
                    }
                } else {
                    data = vp.range(1, length); // Math.max(1, length));
                }

                return data;
            };

            /// private: buildRecordDescriptors(layer)
            /// build:
            ///    - xRecords   - array of x data streams
            ///    - yRecords   - array of y data streams
            ///    - plotRecords    - points to xRecords or yRecords (that one that has multiple streams or is non-category)
            ///    - byRecords      - points to the other (a single stream of category/numeric/date data)
            plotClass.prototype.buildRecordDescriptors = function (layer) {
                var dataRecords = layer.data();

                //var xScaleOverride = null;
                //var yScaleOverride = null;
                //---- filter records ----
                //var filteredData = this._uiStateMgr.filterData(dataRecords, keyFunc);
                var filteredData = dataRecords;

                var xColList = layer.xAfterStat();
                var yColList = layer.yAfterStat();

                //---- extract X data streams from records ----
                var xRecords = [];

                if ((!xColList) || (!xColList.length) || (!xColList[0])) {
                    //---- experiment: try supplying "index" as the x stream ----
                    var colName = "x";
                    var xData = this.getUnmappedData(layer.x(), dataRecords.length);
                    xRecords.push({ data: xData, name: colName, title: colName, tooltip: colName, autoGenerated: true });

                    //xScaleOverride = "category";
                    xColList = [];
                } else {
                    for (var i = 0; i < xColList.length; i++) {
                        var colName = xColList[i];
                        var xxData = vp.dataSelect(filteredData, colName);
                        xRecords.push({ data: xxData, name: colName, title: colName, tooltip: colName });
                    }
                }

                if (!yColList) {
                    yColList = [];
                }

                //---- extract Y data arrays from records ----
                var yRecords = [];

                if ((!yColList) || (yColList.length == 0)) {
                    //---- experiment: try supplying "index" as the x stream ----
                    var colName = "y";
                    var yData = this.getUnmappedData(layer.y(), dataRecords.length);
                    yRecords.push({ data: yData, name: colName, title: colName, tooltip: colName, autoGenerated: true });
                    // yScaleOverride = "category";
                } else {
                    for (var i = 0; i < yColList.length; i++) {
                        var colName = yColList[i];
                        var yyData = vp.dataSelect(filteredData, colName);
                        yRecords.push({ data: yyData, name: colName, title: colName, tooltip: colName });
                    }
                }

                var seriesCount = Math.max(1, Math.max(xColList.length, yColList.length));
                var layerType = layer.layerType();

                if ((layerType == "boxPlot") || (layerType == "graph")) {
                    //---- these are not real series ----
                    seriesCount = 1;
                }

                var yScaleType = this.getScaleTypeForData(yRecords[0].data);
                var byRecords = xRecords;
                var plotRecords = yRecords;

                var xIsSeriesAxis = ((xColList.length > 1) || (yScaleType == "category") || (byRecords.length == 0) || (byRecords[0].data == null));

                if (xIsSeriesAxis) {
                    byRecords = yRecords;
                    plotRecords = xRecords;
                }

                if (filteredData.length == 0) {
                    //---- use primary data records (created from axis value) as the filteredData ----
                    filteredData = (plotRecords && plotRecords.length && plotRecords[0].data.length) ? plotRecords[0].data : byRecords[0].data;

                    //---- tell layer's DAM that data changed ----
                    layer.dataAnimMgr().setData(filteredData);
                }

                var keyFunc = layer.key();
                if (!keyFunc) {
                    //---- fallback: use index as the primary key ----
                    keyFunc = vp.indexKeyFunc;
                }

                //---- store chart options together ----
                //var options =
                //    {
                //zeroAxes: true,       // moved to vvAxisInfo closure class
                //xScaleOverride: xScaleOverride,
                ////yScaleOverride: yScaleOverride,
                //showXAxis: true,
                //showYAxis: true,
                //showXTitle: true,
                //showYTitle: true,
                //showGridLines: true,
                //showXGridLines: true,
                //showYGridLines: true,
                //shapesEnterFromBottom: false,
                //showLegend: (seriesCount > 1),
                //xUseOnlyIntBreaks: undefined,
                //yUseOnlyIntBreaks: undefined,
                //xMinOverride: undefined,
                //xMaxOverride: undefined
                // }
                //---- store info on layer ----
                layer.info = {
                    xSeriesCount: xColList.length,
                    ySeriesCount: yColList.length,
                    seriesNames: (xIsSeriesAxis) ? xColList : yColList,
                    dataRecords: dataRecords,
                    seriesCount: seriesCount,
                    filteredData: filteredData,
                    keyFunc: keyFunc,
                    stackType: this.getStackType(layer),
                    //options: options,
                    xRecords: xRecords,
                    yRecords: yRecords,
                    byRecords: byRecords,
                    plotRecords: plotRecords
                };
            };

            plotClass.prototype.calcByRange = function (descRecords, scaleName, stat, layer) {
                if (descRecords.length > 0) {
                    var descRecord = descRecords[0];
                    var dd = descRecord.data;

                    //---- start with category-style min/max ---
                    var thisMin = 0;
                    var thisMax = dd.length;

                    //---- give STAT the option of calculating this layer's min/max for this scale ----
                    var result = null;
                    if (scaleName == "x") {
                        result = (layer.calcXScaleForLayer) ? layer.calcXScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcXScaleForLayer) ? stat.calcXScaleForLayer(layer) : null;
                        }
                    } else {
                        result = (layer.calcYScaleForLayer) ? layer.calcYScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcYScaleForLayer) ? stat.calcYScaleForLayer(layer) : null;
                        }
                    }

                    if (result) {
                        thisMin = result.min;
                        thisMax = result.max;
                    } else {
                        var dataIsNumeric = vp.isDataNumeric(dd);

                        if (dataIsNumeric) {
                            for (var a = 0; a < descRecords.length; a++) {
                                var dd = descRecords[a].data;
                                if ((dd) && (dd.length > 0)) {
                                    //---- min/max for this series ----
                                    var smin = dd.min();
                                    var smax = dd.max();

                                    //---- combine with previous series ----
                                    if (!isNaN(smin)) {
                                        thisMin = (a == 0) ? smin : Math.min(smin, thisMin);
                                    }

                                    if (!isNaN(smax)) {
                                        thisMax = (a == 0) ? smax : Math.min(smax, thisMax);
                                    }
                                }
                            }
                        }
                    }
                }

                return { min: thisMin, max: thisMax };
            };

            plotClass.prototype.calcPlotRange = function (descRecords, scaleName, stat, stackType, layer) {
                if (descRecords.length > 0) {
                    var descRecord = descRecords[0];

                    var thisMin = +9999999;
                    var thisMax = -9999999;

                    //---- give LAYER/STAT the option of calculating this layer's this._yMin/this._yMax ----
                    var result = null;
                    if (scaleName == "x") {
                        result = (layer.calcXScaleForLayer) ? layer.calcXScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcXScaleForLayer) ? stat.calcXScaleForLayer(layer) : null;
                        }
                    } else {
                        result = (layer.calcYScaleForLayer) ? layer.calcYScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcYScaleForLayer) ? stat.calcYScaleForLayer(layer) : null;
                        }
                    }

                    if (result) {
                        thisMin = result.min;
                        thisMax = result.max;
                    } else if (stackType == "fill") {
                        thisMin = 0;
                        thisMax = 1;
                        //options.addYScaleMaxHeadroom = false;
                    } else if (stackType == "stack") {
                        //---- find min/max of each ITEM (as summed across all series) ----
                        var itemCount = descRecord.data.length;

                        for (var i = 0; i < itemCount; i++) {
                            var itemTotal = 0;

                            for (var a = 0; a < descRecords.length; a++) {
                                var dd = descRecords[a].data;
                                itemTotal += dd[i];
                            }

                            //---- combine with running min/max from previous items ----
                            thisMin = Math.min(thisMin, itemTotal);
                            thisMax = Math.max(thisMax, itemTotal);
                        }
                    } else {
                        for (var a = 0; a < descRecords.length; a++) {
                            var dd = descRecords[a].data;
                            if ((dd) && (dd.length > 0)) {
                                //---- min/max for this series ----
                                var smin = dd.min();
                                var smax = dd.max();

                                //---- combine with previous series ----
                                if (!isNaN(smin)) {
                                    thisMin = Math.min(smin, thisMin);
                                }

                                if (!isNaN(smax)) {
                                    thisMax = Math.max(smax, thisMax);
                                }
                            }
                        }
                    }
                }

                return { min: thisMin, max: thisMax };
            };

            /// private: calculate the range of X and Y data (which might involve multiple series).
            plotClass.prototype.calcXYRanges = function () {
                this._xMin = +9999999;
                this._xMax = -9999999;

                this._yMin = +9999999;
                this._yMax = -9999999;

                for (var j = 0; j < this._layers.length; j++) {
                    var layer = this._layers[j];
                    var stackType = this.getStackType(layer);
                    var stat = layer.stat();

                    //---- find X and Y min/max over this._layers ----
                    this.buildRecordDescriptors(layer);

                    var layInfo = layer.info;
                    var seriesCount = layInfo.seriesCount;

                    var xRecords = layInfo.xRecords;
                    var yRecords = layInfo.yRecords;
                    var byRecords = layInfo.byRecords;
                    var plotRecords = layInfo.plotRecords;

                    layInfo.chartType = layer.chartName();

                    //---- allow layer (layer) to make adjustments to chart options ----
                    if (layer.adjustChartOptions) {
                        layer.adjustChartOptions();
                    }

                    //---- CALC X ----
                    var xRange = null;
                    if (xRecords == byRecords) {
                        xRange = this.calcByRange(xRecords, "x", stat, layer);
                    } else {
                        xRange = this.calcPlotRange(xRecords, "x", stat, stackType, layer);
                    }

                    //---- merge with prev layer ----
                    this._xMin = Math.min(this._xMin, xRange.min);
                    this._xMax = Math.max(this._xMax, xRange.max);

                    //---- CALC Y ----
                    var yRange = null;
                    if (yRecords == byRecords) {
                        yRange = this.calcByRange(yRecords, "y", stat, layer);
                    } else {
                        yRange = this.calcPlotRange(yRecords, "y", stat, stackType, layer);
                    }

                    //---- merge with prev layer ----
                    this._yMin = Math.min(this._yMin, yRange.min);
                    this._yMax = Math.max(this._yMax, yRange.max);
                }
            };

            plotClass.prototype.getScaleTypeForData = function (dd) {
                var scaleType = undefined;

                if ((dd) && (dd.length > 0)) {
                    var value = dd[0];

                    //---- issue: Date.parse(216828) ==> NAN on IE9, but Date on Chrome ----
                    //---- so for now, never do auto date detection - let user specify it ----
                    if (false) {
                        scaleType = "date";
                    } else if (isNaN(Number(value))) {
                        scaleType = "category";
                    } else {
                        scaleType = "numeric";
                    }
                }

                return scaleType;
            };

            plotClass.prototype.adjustScale = function (attribute, myData, limit, dataMin, dataMax, seriesCount, scaleName) {
                var defaults = attribute.layerDefaults;
                var scale = attribute.scale();

                attribute.plotDefaults.isDiscrete = undefined;

                var isDiscrete = attribute.isDiscrete();
                if (isDiscrete === undefined) {
                    isDiscrete = attribute.layerDefaults.isDiscrete;
                    if (isDiscrete === undefined) {
                        var scaleType = this.getScaleTypeForData(myData);
                        if (scaleType !== undefined) {
                            isDiscrete = (scaleType == "category");
                            attribute.plotDefaults.isDiscrete = isDiscrete;
                        }
                    }
                }

                var callerMin = undefined;
                var callerMax = undefined;
                var callerTicks = undefined;

                //---- set min/max of all layer's scales according to the primary layer? ----
                attribute.layerDefaults.dataMin = dataMin;
                attribute.layerDefaults.dataMax = dataMax;
                attribute.layerDefaults.isMinMaxSoft = true;

                attribute.needsSetUp(true);

                //---- attribute should really have 2 level system for breaks but it doesn't ----
                //---- so for now, let the LAYER options take priority (to fix histogram gridlines) ----
                //var breaks = attribute.defaults.breaks;
                //if ((!breaks) || (!breaks.length))
                //{
                //    breaks = attribute.breaks();
                //}
                //if (breaks && breaks.length)
                //{
                //    //attribute.breaks(breaks);
                //    attribute.useNiceNumbers(false);
                //}
                //---- note: "limit" is a USER setting ----
                if ((limit) && (limit.length > 0)) {
                    if (limit[0] != Infinity && limit[0] != -Infinity && limit[0] !== undefined) {
                        callerMin = limit[0];
                        attribute.domainMin(callerMin);
                    } else {
                        attribute.domainMin(undefined);
                    }
                }

                if ((limit) && (limit.length > 1)) {
                    if (limit[1] != Infinity && limit[1] != -Infinity && limit[1] !== undefined) {
                        callerMax = limit[1];
                        attribute.domainMax(callerMax);
                    } else {
                        attribute.domainMax(undefined);
                    }
                }

                if ((limit) && (limit.length > 2)) {
                    if (limit[2] != Infinity && limit[2] != -Infinity && limit[2] !== undefined) {
                        callerTicks = limit[2];
                        attribute.tickCount(callerTicks);
                    } else {
                        attribute.tickCount(undefined);
                    }
                }

                if (isDiscrete) {
                    //---- create CATEGORY scale ----
                    attribute;
                    //.isDiscrete(true)
                    //.treatInputAsDates(false)
                    //.dataOverride(myData)
                    //.values(myData)
                    //.data(myData)
                    //.seriesCount(seriesCount)
                    //.callerTickCount(callerTicks)
                } else {
                    //attribute
                    //.isDiscrete(false)
                    if (false) {
                        //attribute
                        //    .useNiceNumbers(false);
                        //attribute
                        //    .treatInputAsDates(true)
                        //    .useNiceNumbers(false)
                        //    .useZeroForDomainMin(false)
                        //scale = vp.scales.date()
                    } else {
                        //attribute
                        //    .treatInputAsDates(false)
                        //    .useNiceNumbers(addMaxHeadroom)
                        //scale = vp.scales.linear()
                        //.snapResult(true)
                    }
                    //if (! breaks)
                    //{
                    //    if (callerMin !== undefined)
                    //    {
                    //        dataMin = callerMin;
                    //    }
                    //    if (callerMax !== undefined)
                    //    {
                    //        dataMax = callerMax;
                    //    }
                    //    if (callerTicks)
                    //    {
                    //        attribute.tickCount(callerTicks);
                    //    }
                    //}
                }

                return scale;
            };

            plotClass.prototype.updateAutoRangeScale = function (scale, scaleName) {
                //---- set the WIDTH / HEIGHT of the scale, if needed ----
                var spaceScale = scale;

                if (spaceScale.autoRange()) {
                    var size = 0;

                    if (scaleName == "x") {
                        size = this._rcShapes.width;
                    } else {
                        size = this._rcShapes.height;
                    }

                    spaceScale.rangeMin(0).rangeMax(size);
                }
            };

            /// private: adjustScales()
            plotClass.prototype.adjustScales = function (layer) {
                var layInfo = layer.info;

                var xRecords = layInfo.xRecords;
                var yRecords = layInfo.yRecords;
                var byRecords = layInfo.byRecords;
                var plotRecords = layInfo.plotRecords;

                var seriesCount = layInfo.seriesCount;

                if (layInfo.stackType == "fill") {
                    var ai = (plotRecords == xRecords) ? layer._xDefaults : layer._yDefaults;
                    ai.addMaxHeadroom = false;
                }

                var xAttr = layer.x();
                var yAttr = layer.y();

                //---- adjust X-SCALE -----
                var xData1 = (xAttr.layerDefaults.dataOverride) ? xAttr.layerDefaults.dataOverride : xRecords[0].data;

                this.adjustScale(xAttr, xData1, this._xLimit, this._xMin, this._xMax, seriesCount, "x");

                //---- adjust Y-SCALE -----
                var yData1 = (yAttr.layerDefaults.dataOverride) ? yAttr.layerDefaults.dataOverride : yRecords[0].data;

                this.adjustScale(yAttr, yData1, this._yLimit, this._yMin, this._yMax, seriesCount, "y");
            };

            /// private: getStackType()
            plotClass.prototype.getStackType = function (layer) {
                var stackType = layer.stackType();

                if (!stackType) {
                    stackType = layer.defaultStackType();
                }

                return stackType;
            };

            /// structure of plotClass
            ///     div             this._rootDiv
            ///       - div         ribbonDiv
            ///       - svg         this._svgDoc
            ///         - g         this._chartFrameGroup
            ///           - g       titleGroup
            ///           - g       legendGroup
            ///           - g       xaxisGroup
            ///           - g       yaxisGroup
            ///           - g       plotAreaGroup
            ///         - svg      this._shapesDoc   (this has been obsoleted and removed)
            ///         - g        this._shapesGroup
            /// private: rebuildChart()
            plotClass.prototype.rebuildChart = function () {
                //vp.debug("plot.rebuildChart: width=" + this._rootDiv.width() + ", height=" + this._rootDiv.height());
                var start = +Date.now();
                var startTime = start;

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onPlotDataChanged(false);
                }

                //---- clearing the this._timer must happen AFTER the layer.onPlotDataChanged() because it triggers a rebuild ----
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }

                this._rootDiv.clear();
                this._svgDoc.clear();

                //---- do NOT clear "shapesGroup" (since we animate changes using existing shapes) ----
                //this._shapesGroup.clear();
                //---- todo: hook when this._isUiEnabled changes and reflect into this._uiStateMgr ----
                this._uiStateMgr.isUiEnabled(this._isUiEnabled);
                this._uiStateMgr.isSelectionEnabled(this._isSelectionEnabled);

                var prelimElapsed = +Date.now() - start;
                start = +Date.now();

                if (this._layers.length > 0) {
                    var hideRibbon = (!this._showRibbon);

                    this.calcXYRanges();

                    var calcRangesElapsed = +Date.now() - start;
                    start = +Date.now();

                    //---- for now, base some building on the first layer ----
                    var primaryLayer = this._layers[0];
                    var layInfo = primaryLayer.info;
                    var seriesCount = layInfo.seriesCount;

                    this._xScale = primaryLayer._xAttr.scale();
                    this._yScale = primaryLayer._yAttr.scale();

                    var xRecords = layInfo.xRecords;
                    var yRecords = layInfo.yRecords;
                    var byRecords = layInfo.byRecords;
                    var plotRecords = layInfo.plotRecords;

                    var xRecord = xRecords[0];
                    var yRecord = yRecords[0];

                    var xAttr = primaryLayer.x();
                    var yAttr = primaryLayer.y();

                    var plotDefaults = primaryLayer._plotDefaults;

                    if (plotDefaults.shapesEnterFromBottom) {
                        this.shapesEnterFromBottom(true);
                    }

                    //---- add RIBBON at top ----
                    this._ribbonBar = null;

                    if (!hideRibbon) {
                        this.buildRibbon(this._chartType);
                    }

                    //---- now that we know height of ribbon, position this._svgDoc correctly ----
                    var height = this._rootDiv.height();

                    //---- we can't rely on HTML to set the height of this._svgDoc correctly ----
                    if (this._ribbonBar) {
                        height -= this._ribbonBar.height();
                    }

                    this._svgDoc.css("height", height);

                    //---- add SVG DOC below ribbon ----
                    this._rootDiv.append(this._svgDoc).css("width", "100%");

                    this._htmlShapesGroup = this._rootDiv.append("div").id("htmlShapesGroup").css("position", "absolute").css("display", "none");

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        this.adjustScales(layer);
                    }

                    var mytitle = (this._isTitleVisible) ? this._title : null;

                    //var fontSize = this._titleSize;
                    //buildAxisTitles(options, xRecord, yRecord);
                    var showXAxis = ((this._isXAxisVisible) && (plotDefaults.showXAxis));
                    var showYAxis = ((this._isYAxisVisible) && (plotDefaults.showYAxis));

                    //buildAxes(primaryLayer, options, xRecord, yRecord);
                    //---- build this._xLabel ----
                    var myxLabel = xAttr.title();
                    var showXLabel = ((plotDefaults.showXTitle) && (myxLabel) && (myxLabel != ""));

                    //this._xScale.scaleName(myxLabel);
                    primaryLayer.x().title(myxLabel);

                    //---- build this._yLabel ----
                    var myyLabel = yAttr.title();
                    var showYLabel = ((plotDefaults.showYTitle) && (myyLabel) && (myyLabel != ""));

                    //this._yScale.scaleName(myyLabel);
                    primaryLayer.y().title(myyLabel);

                    var showXGrid = (this._isXGridVisible && plotDefaults.showXGridLines);
                    var showYGrid = (this._isYGridVisible && plotDefaults.showYGridLines);

                    var showBoxTicks = this._showBoxTicks;
                    var drawTicksOnInside = this._drawTicksOnInside;

                    var beforeFrameElapsed = +Date.now() - start;
                    start = +Date.now();

                    if (!this._isAxisBoxVisible) {
                        showXAxis = false;
                        showXLabel = false;
                        showXGrid = false;

                        showYAxis = false;
                        showYLabel = false;
                        showYGrid = false;

                        showBoxTicks = false;
                    }

                    //---- build the chart frame and its group parts ----
                    this._chartFrame.xAttribute(primaryLayer.x()).yAttribute(primaryLayer.y()).showLeftAxis(showYAxis).showBottomAxis(showXAxis).showLeftLabel(showYLabel).showBottomLabel(showXLabel).showXGridLines(showXGrid).showYGridLines(showYGrid).showBoxTicks(showBoxTicks).drawTicksOnInside(drawTicksOnInside).gridLineType(this._gridLineType).xLabelFit(this._xLabelFit).isLegendVisible(this._isLegendVisible).title(mytitle).titleSize(this._titleSize);

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        var attrs = layer.getActiveAttributes();

                        if (i == 0) {
                            this._chartFrame.attributes(attrs);
                        }
                    }

                    //---- this may change the scales (which will effect the legends), so call ----
                    //---- before we draw the frame. ----
                    if (this._rebuildCallback) {
                        this._rebuildCallback();
                    }

                    //---- add margins together for frame ----
                    var margins = vp.currentTheme().getDrawingAttributes("chartFrame.margins");
                    var fm = this._frameMargins;

                    if ((fm) && (fm.left !== undefined)) {
                        margins.left += fm.left;
                        margins.top += fm.top;
                        margins.right += fm.right;
                        margins.bottom += fm.bottom;
                    }

                    //---- build the chart FRAME now ----
                    this._chartFrame.build(this._svgDoc, margins, 0, primaryLayer, seriesCount); // this will add this._title, legend, axes, and this._shapesGroup

                    var afterFrameElapsed = +Date.now() - start;
                    start = +Date.now();

                    this._rcShapes = this._chartFrame.plotAreaRect();

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        var xScale = layer.x().scale();
                        var yScale = layer.y().scale();

                        this.updateAutoRangeScale(xScale, "x");
                        this.updateAutoRangeScale(yScale, "y");
                    }

                    this._svgDoc.append(this._shapesGroup);

                    //this._svgDoc.append(this._shapesDoc)
                    if (plotDefaults.gridLinesOnTop) {
                        //--- move SVG group of gridLines from this._chartFrame group to be on top of shapes ----
                        var glGroup = this._chartFrame.gridLinesGroup();
                        glGroup.remove(); // from parent

                        this._svgDoc.append(glGroup);
                    }

                    this._shapesGroup.translate(this._rcShapes.left, this._rcShapes.top).prop("assignedWidth", this._rcShapes.width).prop("assignedHeight", this._rcShapes.height);

                    //this._shapesDoc
                    //    .attr("x", this._rcShapes.left)
                    //    .attr("y", this._rcShapes.top)
                    //    .attr("width", this._rcShapes.width)
                    //    .attr("height", this._rcShapes.height)
                    /// write the WIDTH/HEIGHT also to ShapesGroup so layer's can get this info.
                    this._shapesGroup.attr("width", this._rcShapes.width).attr("height", this._rcShapes.height);

                    //vp.debug("plotId=" + this._nextPlotId + ", shapesGroup.width set to: " + this._rcShapes.width);
                    //---- create clipPath with correct bounds ----
                    this.addOrUpdateClipPath(this._shapesGroup, this._rcShapes.width, this._rcShapes.height);

                    ////---- clipPath debugging ----
                    //this._shapesGroup.append("rect")
                    //    .attr("fill", "yellow")
                    //    .bounds(0, 0, this._rcShapes.width, this._rcShapes.height)
                    this._uiStateMgr.dragToKidsOffset({ left: -this._rcShapes.left, top: -this._rcShapes.top });

                    //---- position our drag surface ----
                    var off = vp.docOffset(this._svgDoc[0]);

                    var beforeDrawLayersElapsed = +Date.now() - start;
                    start = +Date.now();

                    //shapesDiv
                    //    .css("left", off.left + this._rcShapes.left)
                    //    .css("top", off.top + this._rcShapes.top)
                    //    .css("width", this._rcShapes.width)
                    //    .css("height", this._rcShapes.height)
                    //---- draw SHAPES now ----
                    this.drawLayers();

                    var afterDrawLayersElapsed = +Date.now() - start;
                    start = +Date.now();
                }

                var selCount = this._uiStateMgr.selectionCount();
                if (selCount) {
                    //---- this is needed to update selection/hover/filter settings after chart redraw ----
                    //updateShapeVisuals(selCount);
                    this._uiStateMgr.onSelectionChanged(true);
                }

                var selectionElapsed = +Date.now() - start;

                var elapsed = +Date.now() - startTime;
                var a = 9;
                //alert("Elapsed=" + elapsed + " ms");
            };

            plotClass.prototype.attachClipPathToShapesGroup = function () {
                ////---- attach a clip path to "shapesGroup" to keep shapes within their boundary (without having to do scale-level clipping, which looks wrong) ----
            };

            plotClass.prototype.addOrUpdateClipPath = function (group, width, height) {
                var clipId = "shapesClipPath_" + this._plotId;
                var clipPath = document.getElementById(clipId);

                if (clipPath) {
                    //---- already created - just update bounds of child RECT ----
                    vp.select(clipPath.firstChild).bounds(0, 0, width, height);
                } else {
                    //---- define a CLIPPING PATH for use by shapes group ----
                    var defs = group.append("defs");

                    clipPath = defs.append("clipPath").attr("id", clipId).attr("clipPathUnits", "userSpaceOnUse").append("rect").bounds(0, 0, width, height);

                    group.attr("clip-path", "url(#" + clipId + ")");
                }
            };

            /// public: drawLayers()
            plotClass.prototype.drawLayers = function () {
                var start = +Date.now();

                //shapeRoot.clear();
                this._plotShapes = vp.select();

                this._htmlShapesGroup.width(this._rcShapes.width).height(this._rcShapes.height).top(this._rcShapes.top).left(this._rcShapes.left);

                var beforeDrawLayersElapsed = +Date.now() - start;
                start = +Date.now();

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.info.width = this._rcShapes.width;
                    layer.info.height = this._rcShapes.height;
                    layer.info.htmlShapesGroup = this._htmlShapesGroup;

                    this.drawLayer(layer);
                }

                var afterDrawLayersElapsed = +Date.now() - start;
                start = +Date.now();

                if (this._postCreateCallback) {
                    this._postCreateCallback();
                }

                var afterPostCreateElapsed = +Date.now() - start;
                start = +Date.now();
            };

            /// private: drawLayer()
            plotClass.prototype.drawLayer = function (layer) {
                var start = +Date.now();

                var layInfo = layer.info;

                var xRecords = layInfo.xRecords;
                var yRecords = layInfo.yRecords;
                var byRecords = layInfo.byRecords;
                var plotRecords = layInfo.plotRecords;

                var allShapes = vp.select();
                var stackType = layInfo.stackType;
                var itemTotals = [];
                var byRecord = byRecords[0];

                //---- build position info ----
                var pi = { stackType: stackType, itemAccums: [], itemTotals: [] };

                if ((pi.stackType == "stack") || (pi.stackType == "fill")) {
                    pi.itemAccums = [];

                    for (var i = 0; i < byRecord.data.length; i++) {
                        pi.itemAccums[i] = 0;
                    }
                }

                var layerNeedsTotals = (layer.layerType() == "streamGraph");

                if ((pi.stackType == "fill") || (layerNeedsTotals)) {
                    var itemCount = plotRecords[0].data.length;
                    pi.itemTotals = [];

                    for (var i = 0; i < itemCount; i++) {
                        var itemTotal = 0;

                        for (var s = 0; s < plotRecords.length; s++) {
                            var plotData = plotRecords[s].data;
                            itemTotal += plotData[i];
                        }

                        //---- todo: make sure shapes do not overwrite axis lines ----
                        pi.itemTotals[i] = 1.0025 * itemTotal; // fudge factor (temp workaround)
                    }
                }

                layer.container(this._shapesGroup);

                var beforeLayerDrawElapsed = +Date.now() - start;
                var start = +Date.now();

                if (yRecords.length == 0) {
                    //---- draw by-only data ----
                    var yRecord = null;
                    var seriesIndex = 0;

                    //--- draw series and return a selected set of shapes ----
                    var shapes = layer.drawShapes(this._shapesGroup, xRecords[0], yRecord, seriesIndex, pi, layer, this._xScale, this._yScale, this);

                    if (shapes) {
                        this.addDrawnShapes(layer, shapes, seriesIndex);
                    }
                } else {
                    for (var s = 0; s < plotRecords.length; s++) {
                        var xRecord = xRecords[0];
                        var yRecord = yRecords[0];

                        //---- allow both X and Y to have multiple series (pointLayer, barLayer, etc) ----
                        if (yRecords.length > 1) {
                            yRecord = yRecords[s];
                        }

                        if (xRecords.length > 1) {
                            xRecord = xRecords[s];
                        }

                        //--- draw series and return a selected set of shapes ----
                        var shapes = layer.drawShapes(this._shapesGroup, xRecord, yRecord, s, pi, layer, this._xScale, this._yScale, this);

                        var afterLayerDrawElapsed = +Date.now() - start;
                        var start = +Date.now();

                        if (shapes) {
                            this.addDrawnShapes(layer, shapes, s);
                        }

                        var afterAddShapesElapsed = +Date.now() - start;
                        var start = +Date.now();
                    }
                }
            };

            /// public: addDrawnShapes()
            plotClass.prototype.addDrawnShapes = function (layer, shapes, seriesIndex) {
                var ttCols = layer.toolTipCols();
                if ((ttCols === true) && (layer.info.seriesCount > 1)) {
                    if (layer.ctr != "vp.layerGraph") {
                        var byRecords = layer.info.byRecords;
                        var plotRecords = layer.info.plotRecords;

                        var plotRecord = plotRecords[seriesIndex];
                        var byRecord = (seriesIndex < byRecords.length) ? byRecords[seriesIndex] : byRecords[0];

                        ttCols = plotRecord.name + "," + byRecord.name;
                    }
                }

                //---- add chart properties to each shape ----
                shapes.prop("isSelected", false).prop("isFilteredOut", false).prop("isHighlighted", false).attach("mouseover", vp.cb(this, this.onMouseOver)).attach("mouseout", vp.cb(this, this.onMouseOut));

                //.attach("click", onClick)
                shapes.customAttr("toolTipContext", ttCols).toolTipEnabled(true);

                var postCreateFunc = layer.postCreate();
                if (postCreateFunc) {
                    for (var i = 0; i < shapes.length; i++) {
                        postCreateFunc(shapes[i]);
                    }
                }

                //---- store shapes so we can remove them later if this shape is removed ----
                layer.drawnShapes = shapes;

                if ((this._isTooltipEnabled) && (this._useStdTooltips)) {
                    for (var i = 0; i < shapes.length; i++) {
                        this.buildToolTip(shapes[i], layer, seriesIndex);
                    }
                }

                this._plotShapes = this._plotShapes.merge(shapes);

                this._uiStateMgr.plotShapes(this._plotShapes);
            };

            /// private: buildChartTypeCombo()
            plotClass.prototype.buildChartTypeCombo = function (group) {
                this._chartType = "Column";
                if (this._layers.length > 0) {
                    var layer = this._layers[0];
                    this._chartType = layer.chartName();
                }

                var cbChartType = group.append("select").setClass("groupCombo").attach("change", vp.cb(this, this.onChartTypeChanged));

                var chartTypes = ["Bar", "BoxPlot", "Column", "Scatter"];

                chartTypes.selectWithFunc(function (data, index) {
                    cbChartType.append("option").value(data).text(data);
                });

                //---- set this AFTER adding options ----
                var index = chartTypes.indexOf(this._chartType);

                cbChartType.prop("selectedIndex", index);

                if (this._title === undefined) {
                    this._title = this._chartType + " Chart";
                }
            };

            plotClass.prototype.makeGroupCheckbox = function (group, text, isEnabled, clickFunc) {
                var cb = group.append("span").addClass("groupCheckbox").text(text).attach("click", function (e) {
                    var cb = e.target;
                    vp.toggleClass(cb, "groupCheckboxChecked");

                    clickFunc(e);
                });

                if (isEnabled) {
                    cb.addClass("groupCheckboxChecked");
                }

                return cb;
            };

            /// private: buildRibbon()
            plotClass.prototype.buildRibbon = function (chartType) {
                var _this = this;
                this._ribbonBar = this._rootDiv.append(vp.visuals.ribbonBar());

                //---- CHART TYPE group ----
                var group = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Chart type");

                //--- CHARTTYPE COMBO ----
                this.buildChartTypeCombo(group);

                //---- FILTER group ----
                var group1 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Filter");

                //--- ISOLATE button ----
                group1.append("span").setClass("groupButton").text("Isolate").attach("click", vp.cb(this, this._uiStateMgr.isolateFilter));

                //--- HIDE button ----
                group1.append("span").setClass("groupButton").text("Hide").attach("click", vp.cb(this, this._uiStateMgr.hideFilter));

                //group.startNewRow();
                //--- RESET button ----
                group1.append("span").setClass("groupButton").text("Reset").attach("click", vp.cb(this, this._uiStateMgr.resetFilter));

                //--- INVERT button ----
                group1.append("span").setClass("groupButton").text("Invert").attach("click", vp.cb(this, this._uiStateMgr.invertFilter));

                //---- SELECTION group ----
                var group2 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Selection");

                //--- RESET button ----
                group2.append("span").setClass("groupButton").text("Reset").attach("click", function (e) {
                    _this._uiStateMgr.resetSelection();
                });

                //---- INVERT button ----
                group2.append("span").setClass("groupButton").text("Invert").attach("click", vp.cb(this, this._uiStateMgr.toggleSelection));

                ////---- ZOOM group ----
                //var group3 = this._ribbonBar.append(vp.visuals.ribbonGroup())
                //    .name("Zoom");
                ////--- RESET button ----
                //group3.append("span")
                //  .setClass("groupButton")
                //  .text("Zoom");
                ////---- INVERT button ----
                //group3.append("span")
                //  .setClass("groupButton")
                //  .text("Reset");
                //---- SHARING group ----
                var group3 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Sharing");

                //--- CHANNEL text input ----
                var shareName = this._uiStateMgr.shareName();

                group3.append("input").attr("type", "text").setClass("groupText").width(50).id("tbShareName").attr("title", "Channel name").value(shareName).attach("keydown", function (e) {
                    if (e.keyCode == vp.keyCodes.enter) {
                        //plotBox.focus();
                        _this.onShareNameChanged();
                    }
                });

                //---- OPTIONS group ----
                var group4 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Options");

                //---- ANIMATION button ----
                this.makeGroupCheckbox(group4, "Animation", this._isAnimEnabled, function () {
                    var toggle = (!_this._isAnimEnabled);
                    _this.isAnimEnabled(toggle);
                });

                //--- TOOLTIPS button ----
                this.makeGroupCheckbox(group4, "Tooltips", this._isTooltipEnabled, function () {
                    var toggle = (!_this._isTooltipEnabled);
                    _this.isTooltipEnabled(toggle);
                });

                //---- HOVER button ----
                this.makeGroupCheckbox(group4, "Hover", this._isHoverEnabled, function () {
                    var toggle = (!_this._isHoverEnabled);
                    _this.isHoverEnabled(toggle);
                });

                //---- ACTIONS group ----
                var group5 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Actions");

                //--- RESET button ----
                group5.append("span").setClass("groupButton").text("Print").attach("click", function () {
                    _this.printChart(false);
                });
            };

            plotClass.prototype.printChart = function (includeRibbon) {
                var _this = this;
                this._ribbonBar = vp.select(".vpRibbonBar");
                var saveAll = document.body.innerHTML;

                if ((!includeRibbon) && (this._ribbonBar.length > 0)) {
                    //---- so far, no good way to remove this._ribbonBar from layout... ----
                    this.showRibbon(false);
                    this.isAnimEnabled(false);
                    this.isHoverEnabled(false);

                    this.rebuildChart();

                    setTimeout(function () {
                        try  {
                            document.body.innerHTML = _this._rootElement.innerHTML;
                            window.print();
                        } finally {
                            document.body.innerHTML = saveAll;
                            _this.rebuildChart();
                        }
                    }, 500); // wait 500 ms for layout to complete
                } else {
                    try  {
                        document.body.innerHTML = this._rootElement.innerHTML;
                        window.print();
                    } finally {
                        document.body.innerHTML = saveAll;
                        this.rebuildChart();
                    }
                }
            };

            /// private: onChartTypeChanged()
            plotClass.prototype.onChartTypeChanged = function (e) {
                this._chartType = e.currentTarget.value;

                //---- CAREFULLY modify plot to match requested this._chartType (keep all this._mappings) ----
                this.clearLayers();
                this.shapesEnterFromBottom(false);

                if (this._chartType == "Column") {
                    this.append(vp.layers.createColumn());
                } else if (this._chartType == "Bar") {
                    this.shapesEnterFromBottom(true);
                    this.append(vp.layers.createBar());
                } else if (this._chartType == "Scatter") {
                    this.append(vp.layers.createPoint());
                } else if (this._chartType == "BoxPlot") {
                    this.append(vp.layers.createBoxPlot());
                }

                this.rebuildChart();
            };

            /// private: onMouseOver(e)
            plotClass.prototype.onMouseOver = function (e) {
                if (this._isHoverEnabled) {
                    var elem = e.target;
                    this._uiStateMgr.highlightShape(elem);

                    if (this._hoverCallback) {
                        var shapeId = elem.dataItem.key;
                        this._hoverCallback(shapeId);
                    }
                }
            };

            /// private: onMouseOut(e)
            plotClass.prototype.onMouseOut = function (e) {
                if (this._isHoverEnabled) {
                    this._uiStateMgr.resetHighlight();

                    if (this._hoverCallback) {
                        this._hoverCallback(-1);
                    }
                }
            };

            plotClass.prototype.onKeyChanged = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onKeyChanged();
                }
            };

            plotClass.prototype.onKey2Changed = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onKey2Changed();
                }
            };

            plotClass.prototype.formatCol = function (record, colName, layer, seriesIndex) {
                //---- if "colName" is not a category-related column, apply default formatting ----
                var value = record[colName];

                if (layer) {
                    value = layer.formatValue(value, colName, seriesIndex);
                }

                return value;
            };

            //---- expand substrings of the form "@xxx@" (where "xxx" is a colName) using "record" ----
            plotClass.prototype.expandColumns = function (str, record, layer, seriesIndex) {
                var newStr = "";
                var startIndex = 0;

                var index = str.indexOf("@", startIndex);
                while (index > -1) {
                    //---- find end of symbol ----
                    var index2 = str.indexOf("@", index + 1);
                    if (index2 == -1) {
                        break;
                    }

                    var colName = str.substr(index + 1, index2 - (index + 1));
                    var value = record[colName];

                    var value = this.formatCol(record, colName, layer, seriesIndex);

                    //---- copy string between startIndex and index ----
                    var beforeStr = str.substr(startIndex, index - startIndex);

                    newStr += beforeStr;
                    newStr += value;

                    startIndex = index2 + 1;
                    index = str.indexOf("@", startIndex);
                }

                //---- copy remainder of string ----
                newStr += str.substr(startIndex);

                return newStr;
            };

            plotClass.prototype.buildToolTipHelper = function (elem) {
                var layer = (this._layers.length) ? this._layers[0] : null;
                var seriesIndex = vp.shapeId(elem);

                return this.buildToolTip(elem, layer, seriesIndex);
            };

            /// private: buildToolTip(elem, layer, seriesIndex)
            ///
            /// this builds a this._tooltip for the plot by interpreting "tooltipContext" in one of the following forms:
            ///     undefined    => no this._tooltip content to be shown
            ///     null         => build a list of all name/value pairs for each column
            ///     string (comma separate list of col names)   => build list of name/value pairs
            ///     array of name/value objects   => build list of name/value pairs (expanding @xxx@ as values of a colName)
            ///
            /// the column names correspond to the record in elem.dataItem.record
            ///
            /// TOOLTIP DESIGN:
            ///     "tooltipContext" is built by plotClass from the layer's "toolTipCols" property.  Most this._layers default
            ///     this value to "undefined".  The caller can set this property on the layer
            ///     to explictly control the name/value content of the this._tooltip.
            ///
            ///     Note that this name/value formatting of the information in a dataGrid visual component
            ///     cannot currently be overridden (caller can control the content but not the format).
            ///
            ///     TODO: we should allow the caller to specify a callback function that completely
            ///     builds the HTML content to be shown.
            ///
            ///     The this._tooltip processing code looks for an element (or one of its parents) with the property
            ///     "toolTipContext" defined.  This context (see above) is used with the element's data
            ///     (defined in elem.dataItem), to build the contents of the this._tooltip.
            ///
            ///     note that "elem.dataItem" is normally set by the dataAnimMgr component, when it creates each element.
            ///
            plotClass.prototype.buildToolTip = function (elem, layer, seriesIndex) {
                var showIt = false;

                if (this._isUiEnabled) {
                    if (vp.isDefined(elem.toolTipContext)) {
                        //---- in new scheme, we look for a string of column numbers to display ----
                        //---- empty string means, display all columns.  data comes from elem.dataItem ----
                        if ((elem.dataItem) && (elem.dataItem.data)) {
                            var context = elem.toolTipContext;
                            var record = elem.dataItem.data;
                            var rows = [];

                            if (false) {
                                ////---- caller takes over the complete tooltip contents ----
                                //var str = this._toolTipFormatter(record, layer, seriesIndex);
                                //vp.title(elem, str);
                            } else if ((context === null) || (context == true) || (vp.isString(context))) {
                                var parts = (vp.isString(context)) ? context.split(",") : vp.keys(record);

                                for (var p = 0; p < parts.length; p++) {
                                    var part = parts[p].trim();

                                    if (vp.isDefined(record[part])) {
                                        //---- include this field ----
                                        var value = this.formatCol(record, part, layer, seriesIndex);

                                        rows.push({ name: part + ":", value: value });
                                    }
                                }
                            } else if (vp.isArray(context)) {
                                for (var i = 0; i < context.length; i++) {
                                    var pair = context[i];

                                    var newName = this.expandColumns(pair.name, record, layer, seriesIndex);
                                    var newValue = this.expandColumns(pair.value, record, layer, seriesIndex);

                                    var newPair = { name: newName, value: newValue };
                                    rows.push(newPair);
                                }
                            }

                            if (true) {
                                if (this._useStdTooltips) {
                                    //---- build the element's TITLE (STD this._tooltip)
                                    var str = "";
                                    for (var i = 0; i < rows.length; i++) {
                                        var pair = rows[i];

                                        if (str != "") {
                                            if ((vp.isIE) && (vp.isSvgElement(elem))) {
                                                str += ", "; // IE doesn't support line breaks for SVG elements
                                            } else {
                                                str += "\n"; // add a line break between each pair
                                            }
                                        }
                                        str += pair.name + " " + pair.value;
                                    }

                                    vp.title(elem, str);
                                } else {
                                    //---- build the dataGrid (RICH this._tooltip) ----
                                    var dataGrid = this._tooltipDiv.clear().append(vp.visuals.createDataGrid());

                                    dataGrid.data(rows).showHdr(false).showDividers(false).showAltLines(false).boldFirstCol(true);
                                }
                            }

                            showIt = (!this._useStdTooltips);
                        }
                    }
                }

                return showIt;
            };

            ///// READONLY property: plotCanvas
            //plotCanvas()
            //{
            //    return vp.select(shapesDiv);
            //}
            /// public: this._frameMargins
            plotClass.prototype.frameMargins = function (value) {
                if (arguments.length == 0) {
                    return this._frameMargins;
                }

                this._frameMargins = value;
                this.markRebuildNeeded();

                return this;
            };

            /// public: this._selectCallback
            plotClass.prototype.selectCallback = function (value) {
                if (arguments.length == 0) {
                    return this._selectCallback;
                }

                this._selectCallback = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.selectCallback(value);
                }

                return this;
            };

            /// public: hoverCallback
            plotClass.prototype.hoverCallback = function (value) {
                if (arguments.length == 0) {
                    return this._hoverCallback;
                }

                this._hoverCallback = value;

                return this;
            };

            /// public: this._rebuildCallback
            plotClass.prototype.rebuildCallback = function (value) {
                if (arguments.length == 0) {
                    return this._rebuildCallback;
                }

                this._rebuildCallback = value;

                return this;
            };
            return plotClass;
        })(vp.visuals.singleWrapperClass);
        visuals.plotClass = plotClass;

        function createPlot() {
            return new plotClass();
        }
        visuals.createPlot = createPlot;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));

var LabelFit;
(function (LabelFit) {
    /** Just draw all labels and let any overlaps happen */
    LabelFit[LabelFit["drawAll"] = 0] = "drawAll";

    /** Skip 0-N labels, as needed, to make the others fit without overlap */
    LabelFit[LabelFit["skip"] = 1] = "skip";

    /** Truncate labels, as needed, so that they don't exceed their available space. */
    LabelFit[LabelFit["truncate"] = 2] = "truncate";

    /** If all labels cannot be drawn without overlap, rotate the labels 45 degrees to allow them to fit better. */
    LabelFit[LabelFit["rotate45"] = 3] = "rotate45";

    /** If all labels cannot be drawn without overlap, rotate the labels 90 degrees to allow them to fit better. */
    LabelFit[LabelFit["rotate90"] = 4] = "rotate90";

    /** If all labels cannot be drawn without overlap, rotate the labels 45 or 90 degrees to allow them to fit better. */
    LabelFit[LabelFit["rotateAuto"] = 5] = "rotateAuto";

    /** If all labels cannot be drawn without overlap, hide them all. */
    LabelFit[LabelFit["hideAll"] = 6] = "hideAll";
})(LabelFit || (LabelFit = {}));
;
///-----------------------------------------------------------------------------------------------------------------
/// slider.ts.  Copyright (c) 2012 Microsoft Corporation.
///             Part of the vuePlot library - a slider control.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see slider.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** A slider control.  The slider slides between min and max values, by increment. */
        var sliderClass = (function (_super) {
            __extends(sliderClass, _super);
            function sliderClass(isVertical) {
                _super.call(this, null);
                this.ctr = "vp.visuals.slider";
                //---- private state ----
                this._min = 0;
                this._max = 100;
                this._increment = undefined;
                //_actualIncrement = undefined;
                this._value = undefined;
                this._domElement = null;
                this._sliderTrack = null;
                this._sliderThumb = null;
                this._isVertical = false;
                //---- proxies for capture/release ----
                this._cbMouseUp = null;
                this._cbMouseMove = null;
                this._changeListeners = [];
                this._toggleListeners = [];
                this._mouseDownX = 0;
                this._mouseDownY = 0;
                this._isMovingThumb = false;
                this._isMouseDown = false;
                this._mouseDownTime = 0;
                this._lastMouseDoc = { x: 0, y: 0 };
                this._movedByUser = false;
                this._valueChangedDuringTouch = null;
                this._trackHeight = 0;
                this._trackWidth = 0;
                this._thumbWidth = 0;
                this._thumbHeight = 0;
                this._timer = null;
                this._changingSizes = false;
                this._isEnabled = true;

                this._isVertical = isVertical;

                this.build();
            }
            sliderClass.prototype.update = function () {
                if (this._timer != null) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }

                this.setValue(this._value, true);
            };

            //---- private: build() ----
            sliderClass.prototype.build = function () {
                var _this = this;
                if (!this._domElement) {
                    this._domElement = vp.createSvg("svg");
                    this.elem = this._domElement;

                    //---- add a property on element to get access to control (closure object) ----
                    this._domElement.control = this;

                    vp.attach(this._domElement, "resize", vp.cb(this, this.onBoundariesChanged));
                }

                /// Note: non-IE browsers don't like SVG elements that go outside the boundaries of the SVG document
                /// (they get chopped off), so make sure we layout everything WITHIN the {0, 0, width, height} bounds.
                if (this._value === undefined) {
                    this._value = this._min;
                }

                var root = vp.select(this._domElement).clear();

                this._sliderTrack = root.append("rect").addClass("sliderTrack").id("sliderTrack").bounds(0, 0, 50, 4).attr("rx", 3).attr("ry", 3);

                this._sliderThumb = root.append("rect").addClass("sliderThumb").id("sliderThumb").bounds(0, 0, 8, 16).attr("rx", 2).attr("ry", 2);

                if (this._isVertical) {
                    this.setThumbSize(16, 8);
                    this.setTrackHeight(50);
                    this.setTrackWidth(4);
                } else {
                    this.setThumbSize(8, 16);
                    this.setTrackHeight(4);
                }

                //---- event strategy: hook mouseenter/exit to know when to enable the "mousedown" event handler, using
                //---- the "capture" flag of event listener to get priority access (during capture phase) to event.  ----
                root.attach("mouseover", function (e) {
                    if (_this._isEnabled) {
                        root.attach("mousedown", vp.cb(_this, _this.onMouseDown), true);
                    }
                });

                root.attach("mouseout", function (e) {
                    if (_this._isEnabled) {
                        root.detach("mousedown", vp.cb(_this, _this.onMouseDown), true);
                    }
                });
                //if (this._increment === undefined)
                //{
                //    var diff = this._max - this._min;
                //    this._actualIncrement = (diff == 0) ? 0 : diff / 100;
                //}
                //else
                //{
                //    this._actualIncrement = this._increment;
                //}
                //---- use "touch" instead of "mouse" events (works better across devices) ----
                //---- in order to approximate "capture" behavior, we hook the document & ensure mousedown is on sliderThumb ----
                //vp.touchEventHandler(document.body, onMouseDown, onMouseMove, onMouseUp);
                //vp.touchEventHandler(domElement, onMouseDown, null, null);
            };

            sliderClass.prototype.element = function () {
                return this._domElement;
            };

            sliderClass.prototype.sliderThumb = function () {
                return this._sliderThumb;
            };

            sliderClass.prototype.sliderTrack = function () {
                return this._sliderTrack;
            };

            /// private: setValue().
            sliderClass.prototype.setValue = function (newValue, force) {
                //---- round value to nearest increment ----
                if (this._increment !== undefined) {
                    newValue = this._increment * Math.round(newValue / this._increment);
                }

                //---- adjust value so its within limits ----
                if (this._min < this._max) {
                    if (newValue < this._min) {
                        newValue = this._min;
                    } else if (newValue > this._max) {
                        newValue = this._max;
                    }
                } else {
                    if (newValue > this._min) {
                        newValue = this._min;
                    } else if (newValue < this._max) {
                        newValue = this._max;
                    }
                }

                if ((force) || (newValue != this._value)) {
                    //vp.debug("sliderValue=" + newValue);
                    this._value = newValue;

                    if (force) {
                        if (this._isVertical) {
                            var top = 0;
                            var trackHeight = this._sliderTrack.height();
                            var bottom = trackHeight - this._thumbHeight;

                            var yValue = vp.mapValue(this._value, this._min, this._max, top, bottom);

                            //---- move thumb ----
                            this._sliderThumb.attr("y", yValue);
                        } else {
                            var left = 0;
                            var trackWidth = this._sliderTrack.width();
                            var right = trackWidth - this._thumbWidth;

                            var xValue = vp.mapValue(this._value, this._min, this._max, left, right);

                            //---- move thumb ----
                            this._sliderThumb.attr("x", xValue);
                        }
                    }

                    //---- call event listeners ----
                    this.onChange();
                }
            };

            /// private: markUpdateNeeded().
            sliderClass.prototype.markUpdateNeeded = function () {
                if (this._timer == null) {
                    setTimeout(vp.cb(this, this.update), 1);
                }
            };

            /// private: onChange().
            sliderClass.prototype.onChange = function () {
                //---- create a simplified event object ----
                var evt = { src: this, value: this._value };

                for (var i = 0; i < this._changeListeners.length; i++) {
                    var callback = this._changeListeners[i];

                    callback(evt);
                }
            };

            /// private: onToggle().
            sliderClass.prototype.onToggle = function () {
                //---- create a simplified event object ----
                var evt = { src: this, value: this._value };

                for (var i = 0; i < this._toggleListeners.length; i++) {
                    var callback = this._toggleListeners[i];

                    callback(evt);
                }
            };

            //---- function: attach() ----
            sliderClass.prototype.attach = function (eventName, callback) {
                if (eventName.toLowerCase() == "change") {
                    this._changeListeners.push(callback);
                } else if (eventName.toLowerCase() == "toggle") {
                    this._toggleListeners.push(callback);
                } else {
                    //---- defer to the domElement for other events ----
                    // CHW: delegate to global attach function
                    vp.attach(this._domElement, eventName, callback);
                }

                return this;
            };

            //---- function: detach() ----
            sliderClass.prototype.detach = function (eventName, callback) {
                if (eventName.toLowerCase() == "change") {
                    this._changeListeners.remove(callback);
                } else if (eventName.toLowerCase() == "toggle") {
                    this._toggleListeners.remove(callback);
                } else {
                    //---- defer to the domElement for other events ----
                    // CHW: delegate to global deattach function
                    vp.detach(this._domElement, eventName, callback);
                }

                return this;
            };

            /// private: onMouseMove().
            sliderClass.prototype.onMouseMove = function (e) {
                //vp.debug("vpslider.onMouseMove: e.type=" + e.type);
                //vp.debug("onMouseMove: isMouseDown=" + isMouseDown);
                var mouseDoc = vp.mousePosition(e);

                if (this._isMouseDown) {
                    if (!this._isMovingThumb) {
                        //---- have we gone far enough or waited long enough? ----
                        var delta = Date.now() - this._mouseDownTime;
                        if (delta > 100) {
                            this._isMovingThumb = true;
                        } else {
                            var xdiff = Math.abs(mouseDoc.x - this._lastMouseDoc.x);
                            var ydiff = Math.abs(mouseDoc.y - this._lastMouseDoc.y);

                            if ((xdiff >= 4) || (ydiff >= 4)) {
                                this._isMovingThumb = true;
                            }
                        }
                    }

                    if (this._isMovingThumb) {
                        this._movedByUser = true;
                        this._valueChangedDuringTouch = true;

                        //---- goal is to set new X location for THUMB (relative to our local svg document) ----
                        //---- "doc" variables here refer to coordinates relative to main document origin ----
                        //---- "svg" variables here refer to coordinates relative to local svg document ----
                        //---- compute mouse location relative to my svg document ----
                        var newValue = 0;

                        if (this._isVertical) {
                            var mouseYDoc = mouseDoc.y;

                            var newYDoc = mouseYDoc - this._mouseDownY;
                            var newYSvg = newYDoc - vp.docOffset(this._sliderTrack[0]).top;

                            var topSvg = 0;
                            var trackHeighth = this._sliderTrack.height();
                            var bottomSvg = topSvg + this._trackHeight - this._thumbHeight;

                            if (newYSvg < topSvg) {
                                newYSvg = topSvg;
                            } else if (newYSvg > bottomSvg) {
                                newYSvg = bottomSvg;
                            }

                            //---- move thumb ----
                            this._sliderThumb.attr("y", newYSvg);

                            newValue = vp.mapValue(newYSvg, topSvg, bottomSvg, this._min, this._max);
                        } else {
                            var mouseXDoc = mouseDoc.x;

                            var newXDoc = mouseXDoc - this._mouseDownX;
                            var newXSvg = newXDoc - vp.docOffset(this._sliderTrack[0]).left;

                            var leftSvg = 0;
                            var trackWidth = this._sliderTrack.width();
                            var rightSvg = leftSvg + trackWidth - this._thumbWidth;

                            if (newXSvg < leftSvg) {
                                newXSvg = leftSvg;
                            } else if (newXSvg > rightSvg) {
                                newXSvg = rightSvg;
                            }

                            //---- move thumb ----
                            this._sliderThumb.attr("x", newXSvg);

                            newValue = vp.mapValue(newXSvg, leftSvg, rightSvg, this._min, this._max);
                        }

                        this.setValue(newValue, false);
                        //                e.cancelBubble = true;
                        //                e.stopPropagation();
                        //                e.returnValue = false;
                    }
                }

                this._lastMouseDoc = mouseDoc;
            };

            /// private: onMouseUp().
            sliderClass.prototype.onMouseUp = function (e) {
                this._isMovingThumb = false;
                this._isMouseDown = false;

                vp.releaseCapture(document.body, e, this._cbMouseMove, this._cbMouseUp);

                if (this._valueChangedDuringTouch === false) {
                    //---- trigger the TOGGLE event ----
                    this.onToggle();
                }
            };

            /// private: onMouseDown().
            sliderClass.prototype.onMouseDown = function (e) {
                var pos = vp.mousePosition(e);
                var elem = vp.elementFromPoint(pos.x, pos.y);
                var captureMouseForMove = false;

                if (elem === this._sliderThumb[0]) {
                    this._isMouseDown = true;
                    this._mouseDownTime = Date.now();

                    vp.debug("onMouseDown: isMouseDown=" + this._isMouseDown);

                    //---- compute mouse location relative to my the THUMB ----
                    var thumbXRelToDoc = vp.docOffset(elem).left;
                    var thumbYRelToDoc = vp.docOffset(elem).top;

                    var mouseXRelToDoc = vp.mousePosition(e).x;
                    var mouseYRelToDoc = vp.mousePosition(e).y;

                    this._mouseDownX = mouseXRelToDoc - thumbXRelToDoc;
                    this._mouseDownY = mouseYRelToDoc - thumbYRelToDoc;

                    this._valueChangedDuringTouch = false;

                    this._cbMouseMove = vp.cb(this, this.onMouseMove);
                    this._cbMouseUp = vp.cb(this, this.onMouseUp);

                    vp.setCapture(document.body, e, this._cbMouseMove, this._cbMouseUp);
                } else if (elem == this._sliderTrack) {
                    this._valueChangedDuringTouch = false;
                } else {
                    //---- do not trigger a TOGGLE event if outside of our slider ----
                    this._valueChangedDuringTouch = true;
                }

                return false;
            };

            /// private: setThumbSize().
            sliderClass.prototype.setThumbSize = function (width, height) {
                this._thumbWidth = width;
                this._thumbHeight = height;

                this._sliderThumb.width(width).height(height);

                this.onSizesChanged();
            };

            /// private setTrackHeight().
            sliderClass.prototype.setTrackHeight = function (value) {
                this._trackHeight = value;
                this._sliderTrack.attr("height", value);
                this._domElement.setAttribute("height", value + 4); // for Safari (wants width/height)

                this.onSizesChanged();
            };

            /// private setTrackWidth().
            sliderClass.prototype.setTrackWidth = function (value) {
                this._trackWidth = value;
                this._sliderTrack.attr("width", value);
                this._domElement.setAttribute("width", value + 4); // for Safari (wants width/height)

                this.onSizesChanged();
            };

            sliderClass.prototype.onBoundariesChanged = function () {
                if (!this._changingSizes) {
                    if (this._isVertical) {
                        var height = vp.height(this._domElement);
                        this.setTrackHeight(height);
                    } else {
                        var width = vp.width(this._domElement);
                        this.setTrackWidth(width);
                    }
                }
            };

            //---- private: onSizesChanged().
            sliderClass.prototype.onSizesChanged = function () {
                this._changingSizes = true;

                if (this._isVertical) {
                    this._sliderTrack.attr("x", this._thumbWidth / 2 - this._trackWidth / 2);

                    this._sliderThumb.attr("x", 0);
                } else {
                    this._sliderTrack.attr("y", this._thumbHeight / 2 - this._trackHeight / 2);

                    this._sliderThumb.attr("y", 0);
                }

                if (this._isVertical) {
                    var w = Math.max(this._trackWidth, this._thumbWidth);

                    //---- add +1 to avoid truncation due to pixel misalignment ----
                    vp.width(this._domElement, w + 1);
                    vp.height(this._domElement, this._trackHeight + 1);
                } else {
                    var h = Math.max(this._trackHeight, this._thumbHeight);

                    //---- add +1 to avoid truncation due to pixel misalignment ----
                    vp.width(this._domElement, this._trackWidth + 1);
                    vp.height(this._domElement, h + 1);
                }

                this._changingSizes = false;
            };

            //---- property: min ----
            sliderClass.prototype.min = function (value) {
                if (value === undefined) {
                    return this._min;
                }

                this._min = value;
                this.markUpdateNeeded();
                return this;
            };

            //---- property: max ----
            sliderClass.prototype.max = function (value) {
                if (value === undefined) {
                    return this._max;
                }

                this._max = value;
                this.markUpdateNeeded();
                return this;
            };

            //---- property: value ----
            sliderClass.prototype.value = function (actualValue) {
                if (actualValue === undefined) {
                    return this._value;
                }

                //value = actualValue;
                //markUpdateNeeded();
                this.setValue(actualValue, true);
                return this;
            };

            //---- property: increment ----
            sliderClass.prototype.increment = function (value) {
                if (value === undefined) {
                    return this._increment;
                }

                this._increment = value;
                this.markUpdateNeeded();
                return this;
            };

            //---- property: isEnabled ----
            sliderClass.prototype.isEnabled = function (value) {
                if (value === undefined) {
                    return this._isEnabled;
                }

                this._isEnabled = value;

                if (this._isEnabled) {
                    this._domElement.style.opacity = "1";
                } else {
                    this._domElement.style.opacity = ".5";
                }

                this.markUpdateNeeded();
                return this;
            };

            //---- property: trackHeight ----
            sliderClass.prototype.trackHeight = function (value) {
                if (value === undefined) {
                    return this._trackHeight;
                }

                this.setTrackHeight(value);
                return this;
            };

            //---- property: trackWidth ----
            sliderClass.prototype.trackWidth = function (value) {
                if (value === undefined) {
                    return this._trackWidth;
                }

                this.setTrackWidth(value);
                return this;
            };

            //---- property: thumbWidth ----
            sliderClass.prototype.thumbWidth = function (value) {
                if (value === undefined) {
                    return this._thumbWidth;
                }

                this.setThumbSize(value, this._thumbHeight);
                return this;
            };

            //---- property: thumbHeight ----
            sliderClass.prototype.thumbHeight = function (value) {
                if (value === undefined) {
                    return this._thumbHeight;
                }

                this.setThumbSize(this._thumbWidth, value);
                return this;
            };
            return sliderClass;
        })(vp.visuals.singleWrapperClass);
        visuals.sliderClass = sliderClass;

        function createVerticalSlider() {
            return new sliderClass(true);
        }
        visuals.createVerticalSlider = createVerticalSlider;

        function createHorizontalSlider() {
            return new sliderClass(false);
        }
        visuals.createHorizontalSlider = createHorizontalSlider;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// timeSlicer.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates a control to cut data into "slices" that can be scrolled thru or played back.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Creates a control to cut data into "slices" that can be scrolled thru or played back. */
        var timeSlicerClass = (function (_super) {
            __extends(timeSlicerClass, _super);
            function timeSlicerClass() {
                var _this = this;
                _super.call(this, null);
                this.ctr = "vp.visuals.timeSlicerClass";
                //---- other variables ----
                this._buildNeeded = false;
                this._buildTimer = null;
                this._padding = 2;
                this._sliceIndex = -1;
                this._ignoreSliderChanges = true;
                this._sliceDuration = 1000;
                this._playTimer = null;
                //---- constants ----
                this._stoppedImage = "../images/RightArrowFilled.png";
                this._playingImage = "../images/RightArrowEmpty.png";
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    //if (this._buildNeeded)
                    //{
                    //    this.build();
                    //}
                    return this._rootElement;
                };
                //---- property: data ----
                this.data = function (value) {
                    if (value === undefined) {
                        return this._data;
                    }

                    this._data = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: timeColumn ----
                this.timeColumn = function (value) {
                    if (value === undefined) {
                        return this._timeColumn;
                    }

                    this._timeColumn = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: sliceDuration ----
                this.sliceDuration = function (value) {
                    if (value === undefined) {
                        return this._timeSlice;
                    }

                    this._timeSlice = value;
                    this.markBuildNeeded();

                    return this;
                };

                //---- create CONTROLS ----
                var rootElem = vp.createHtml("div");
                this._rootElement = rootElem;

                this._root = vp.select(this._rootElement).setClass("timeSlicer").css("position", "relative");

                rootElem.control = this;
                this.element(rootElem); // set wrapper root element

                vp.attach(rootElem, "resize", function (e) {
                    return _this.markBuildNeeded();
                });

                this._image = this._root.append("img").attach("click", function (e) {
                    return _this.togglePlay();
                });

                this._image.setClass("timeSlicerPlay").attr("src", this._stoppedImage);

                this._slider = this._root.append(vp.visuals.createHorizontalSlider()).setClass("timeSlicerSlider").width(120).thumbHeight(26).thumbWidth(16).trackHeight(4).attach("change", function (e) {
                    return _this.onSliderChanged();
                });

                this._keySpan = this._root.append("span").setClass("timeSlicerLabel");

                //---- get initial size, etc. ----
                this.markBuildNeeded();
            }
            timeSlicerClass.prototype.onSliderChanged = function () {
                if (!this._ignoreSliderChanges) {
                    var index = this._slider.value();
                    this.setDataSlice(index);
                }
            };

            timeSlicerClass.prototype.togglePlay = function () {
                if (this._slices) {
                    if (this._playTimer) {
                        this.stop();
                    } else {
                        if (this._sliceIndex == this._slices.length - 1) {
                            this._sliceIndex = -1;
                        }

                        this.play();
                    }
                }
            };

            timeSlicerClass.prototype.play = function () {
                var _this = this;
                if (this._slices && this._slices.length) {
                    var index = this._sliceIndex + 1;
                    if (index < this._slices.length) {
                        this.setDataSlice(index);

                        this._playTimer = setTimeout(function (e) {
                            return _this.play();
                        }, this._sliceDuration);
                        this._image.attr("src", this._playingImage);
                    }
                }

                return this;
            };

            timeSlicerClass.prototype.stop = function () {
                if (this._playTimer) {
                    clearTimeout(this._playTimer);
                    this._playTimer = null;

                    this._image.attr("src", this._stoppedImage);
                }

                return this;
            };

            timeSlicerClass.prototype.markBuildNeeded = function () {
                var _this = this;
                if (this._buildTimer) {
                    clearTimeout(this._buildTimer);
                }

                this._buildTimer = setTimeout(function (e) {
                    return _this.build();
                }, 25);
            };

            timeSlicerClass.prototype.hookOnChange = function (callback) {
                this._onChangeCallback = callback;
                return this;
            };

            timeSlicerClass.prototype.getDataSlice = function () {
                return this._dataSlice;
            };

            timeSlicerClass.prototype.getDataKey = function () {
                return this._sliceKey;
            };

            /** Called primarily after RESIZE of dataGrid control has occured. */
            timeSlicerClass.prototype.build = function () {
                this._buildTimer = null;
                this._slices = null;
                this._sliceIndex = -1;
                this._dataSlice = null;

                var data = this._data;
                var colName = this._timeColumn;

                if (data && data.length && colName && colName.length) {
                    this._slices = data.groupBy(colName);
                    var sliceCount = this._slices.length;

                    this._slider.min(0).max(sliceCount - 1).increment(1);
                }

                this.setDataSlice(0);
            };

            timeSlicerClass.prototype.setDataSlice = function (index) {
                this._ignoreSliderChanges = true;

                this._sliceIndex = index;
                this._dataSlice = this._slices[index].values;
                this._sliceKey = this._slices[index].key;

                this._keySpan.text(this._sliceKey);

                if (this._onChangeCallback) {
                    this._onChangeCallback(this);
                }

                if (this._playTimer) {
                    //---- move the slider ----
                    this._slider.value(index);
                }

                this._ignoreSliderChanges = false;
            };
            return timeSlicerClass;
        })(vp.visuals.singleWrapperClass);
        visuals.timeSlicerClass = timeSlicerClass;

        function createTimeSlicer() {
            return new timeSlicerClass();
        }
        visuals.createTimeSlicer = createTimeSlicer;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// alignBox.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It aligns and rotate its child correctly (vs. HTML)
///    according to these custom properties:
///
///         - halign
///         - valign
///         - rotation
///-----------------------------------------------------------------------------------------------------------------
/// testing: see alignBox.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.alignBox = function ()
{
    //---- private state ----
    var halign = "center";
    var valign = "center";
    var rotation = 0;
    var applyChildWidth = false;

    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;
    var firstChild = null;

    //---- closure ----
    var closure = function()
    {
    }

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        var kids = root.kids();
        var rootWidth = root.width();
        var rootHeight = root.height();
        
        //---- layout single child ----
        if (kids.length > 0)
        {
            var unwrappedElem = kids[0];
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            var paddingWidth = sizes.paddingWidth;
            var paddingHeight = sizes.paddingHeight;

            var marginWidth = sizes.marginWidth;
            var marginHeighth = sizes.marginHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var elemWidth = sizes.width;        // + borderWidth;
            var elemHeight = sizes.height;  //  + borderHeight;

            //---- calc LEFT ----
            var left = 0;
            if ((halign == "center") || (halign == "middle"))
            {
                left = rootWidth / 2 - elemWidth / 2;
            }
            else if (halign == "right")
            {
                left = rootWidth - elemWidth;
            }

            //---- calc TOP ----
            var top = 0;
            if ((valign == "center") || (valign == "middle"))
            {
                top = rootHeight / 2 - elemHeight / 2;
            }
            else if (valign == "bottom")
            {
                top = rootHeight - elemHeight;
            }

            //---- set LEFT, TOP ----
            elem.absPosition(left, top);

            //---- pass rotation thru to elem ----
            elem.transform("rotate(" + rotation + "deg)");
        }

        //applyChildWidthNow();

    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "valign");
        vp.makeControlProperty(wrapper, "halign");
        vp.makeControlProperty(wrapper, "rotation");
        vp.makeControlProperty(wrapper, "applyChildWidth");
    };

    var initFirstChild = function ()
    {
        var elem = null;

        var kids = root.kids();
        if (kids.length > 0)
        {
            elem = kids[0];
        }

        if (elem != firstChild)     // changed
        {
            if (firstChild)
            {
                vp.detach(firstChild, "resize", applyChildWidthNow);
            }

            firstChild = elem;

            if (firstChild)
            {
                vp.attach(firstChild, "resize", applyChildWidthNow);
            }
        }
    }

    var applyChildWidthNow = function()
    {
        initFirstChild();

        if ((applyChildWidth) && (firstChild))
        {
            var sizes = vp.elementSizes(firstChild);

            //---- include marginWidth + border + padding ----
            var width =  sizes.width + sizes.borderWidth + sizes.paddingWidth;        // + marginWidth);

            //---- set width of alignBox to width of first child ----
            root.width(width);
        }
    };

    var initialBuild = function()
    {
        root
            .setClass("alignBox")
            .css("position", "relative")    // so it can hold absolute position elements
            .attach("resize", markLayoutNeeded)
            .attach("DOMNodeInserted", nodeAddOrDelete)
            .attach("DOMNodeRemoved", nodeAddOrDelete);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.alignBox";
    rootElement.control = closure;

    var nodeAddOrDelete = function (e)
    {
        applyChildWidthNow();

        markLayoutNeeded();
    };

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }

        closure.layout();
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (timer)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: halign ----
    closure.halign = function (value)
    {
        if (value === undefined)
        {
            return halign;
        }

        halign = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: valign ----
    closure.valign = function (value)
    {
        if (value === undefined)
        {
            return valign;
        }

        valign = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: rotation ----
    closure.rotation = function (value)
    {
        if (value === undefined)
        {
            return rotation;
        }

        rotation = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: applyChildWidth ----
    closure.applyChildWidth = function (value)
    {
        if (value === undefined)
        {
            return applyChildWidth;
        }

        applyChildWidth = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// categoryAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///                  Part of the vuePlot library - a category axis.  Can be used for left, top, right, bottom of plot.
///-----------------------------------------------------------------------------------------------------------------
/// create an SVG-based category axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see categoryAxis.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.categoryAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label
    var labelSizes = [];
    var labelStrings = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var scale = vp.scales.createCategory();    // default
    var values = [];
    var changingSize = false;
    var formatter = undefined;

    //---- HTML elements ----
    var rootElem = null;
    var axisLine = null;
    var tickMarks = null;
    var labels = null;


    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.categoryAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "values");
        vp.makeControlProperty(wrapper, "formatter");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(closure.build, 1);
        }
    };

    /// private.
    var pixelAlign = function (value)
    {
        //return Math.round(value);
        return value;   
    };

    /// private.
    var buildLabelStringsAndSizes = function (data)
    {
        labelSizes = [];
        labelStrings = [];
        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;

        //---- create a TEXT element for measuring strings ----
        var fakeLabel = vp.select(document.body)
            .append("span")
            .setClass("vpCategoryAxis_label");
            
        data.selectWithFunc(function (value, index)
        {
            var formatFunc = (formatter === undefined) ? vp.formatters.string : formatter;

            var labelStr = formatFunc(value);

            labelStrings.push(labelStr);

            //---- set up for measuring "labelStr" ----
            fakeLabel.text(labelStr);

            var width = Math.ceil(fakeLabel.width());
            var height = Math.ceil(fakeLabel.height());

            if (width > maxStringWidth)
            {
                maxStringWidth = width;
            }

            if (height > maxStringHeight)
            {
                maxStringHeight = height;
            }

            var sz = { width: width, height: height };
            labelSizes.push(sz);

            dataCount++;
        });

        totalLabelWidths = maxStringWidth * dataCount;
        totalLabelHeights = maxStringHeight * dataCount;

        //---- remove temp label created above ----
        fakeLabel.remove();
    }

    //---- private: build() ----
    closure.build = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        if (rootElem == null)
        {
            rootElem = vp.createHtml("div");
            rootElem.control = closure;

            vp.setClass(rootElem, "vpCategoryAxis");
            vp.attach(rootElem, "resize", elementResized);
        }

        var root = vp.select(rootElem)
            .clear();

        if ((isAxisVisible) && (scale != null) && (scale.count))
        {
            var min = 0;
            var max = scale.count();            // note this is count+1 for extra tick at the end
            var tickData = vp.range(min, max, 1);

            var values = scale.values();
            var labelData = (values) ? values : vp.range(min + 1, max, 1);     // labels have 1 less than ticks

            buildLabelStringsAndSizes(labelData);

            if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                buildLeftElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                buildRightElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                buildTopElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
            {
                buildBottomElements(root, min, max, tickData);
            }
        }
    };

    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            updateAutoRangeScale();
        }
    };

    var updateAutoRangeScale = function ()
    {
        var root = vp.select(rootElem);

        if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
        {
            calcWidthFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
        {
            calcWidthFromScale(root);
        }

        markRebuildNeeded();
    };

    var setRootWidth = function (value)
    {
        changingSize = true;

        vp.width(rootElem, value);

        changingSize = false;
    };

    var setRootHeight = function (value)
    {
        changingSize = true;

        vp.height(rootElem, value);

        changingSize = false;
    };

    var calcHeightFromScale = function (root)
    {
        var height = 0;
        if (scale.autoRange())
        {
            height = root.height();

            scale.rangeMin(0);
            scale.rangeMax(height - 1);
        }
        else
        {
            height = scale.rangeMax() - scale.rangeMin();
        }

        return height;
    }

    var calcWidthFromScale = function (root)
    {
        var width = 0;
        if (scale.autoRange())
        {
            width = root.width();

            scale.rangeMin(0);
            scale.rangeMax(width - 1);
        }
        else
        {
            width = scale.rangeMax() - scale.rangeMin();
        }

        return width;
    }

    /// private: buildLeftElements()
    var buildLeftElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (scale.count() * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var perHeight = (height-1) / scale.count();

        var x = pixelAlign(width - 1);
        var y1 = 0;
        var y2 = height - 1;

        //---- create the vertical axis line (for LEFT CATEGORY axis) ----
        axisLine = root.append("span")
                .absPosition(x, y1)
                .width(1)
                .height(y2 - y1 + 1)
                .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var y = scale.tickOffset(index);

                var x1 = pixelAlign(width - tickLength - 1);
                var x2 = pixelAlign(width - 1);

                var tm = root.append("span")
                         .absPosition(x1, y)
                         .height(1)
                         .width(Math.abs(x2 - x1 + 1))
                         .setClass("vpCategoryAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = labelStrings.selectWithFunc(function (data, index)
            {
                var labelWidth = labelSizes[index].width;

                var x = pixelAlign(width - tickLength - labelSpace - 1 - labelWidth);
                var y = scale.flipScale(index, -1);
                var dy = (scale.itemWidth() - maxStringHeight)/2 - 1;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                         .absPosition(x, y + dy)
                         .text(labelStr)
                         .setClass("vpCategoryAxis_label");

                y += perHeight;

                return span;
            });
        }
    };

    /// private: buildRightElements()
    var buildRightElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (scale.count() * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var perHeight = (height - 1) / scale.count();

        //---- create the vertical axis line ----
        axisLine = root.append("span")
                 .absPosition(0, 0)
                 .width(1)
                 .height(height)
                 .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var y = scale.tickOffset(index);

                var x1 = pixelAlign(0);
                var x2 = pixelAlign(tickLength);

                var tm = root.append("span")
                         .absPosition(x1, y)
                         .height(1)
                         .width(Math.abs(x2 - x1 + 1))
                         .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = labelStrings.selectWithFunc(function (data, index)
            {
                var x = tickLength + labelSpace;
                var y = scale.flipScale(index, -1);
                var dy = (scale.itemWidth() - maxStringHeight) / 2 - 1;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x, y + dy)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                return span;
            });
        }
    };

    /// private: buildTopElements()
    var buildTopElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (scale.count() * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        var perWidth = (width-1) / scale.count();

        //---- create the horizontal axis line ----
        var x1 = 0;
        var x2 = width - 1;
        var y = height - 1;

        axisLine = root.append("span")
                .absPosition(x1, y)
                .height(1)
                .width(x2 - x1 + 1)
                .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var x = scale.tickOffset(index);

                var y = height - 1;
                var y2 = height - tickLength - 1;

                var tm = root.append("span")
                        .absPosition(x, y2)
                        .width(1)
                        .height(y - y2 + 1)
                        .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            var x = perWidth / 2;
            labels = labelStrings.selectWithFunc(function (data, index)
            {
                var y = 0;
                var dx = labelSizes[index].width / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                x += perWidth;

                return span;
            });
        }
    };

    /// private: buildBottomElements()
    var buildBottomElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (scale.count() * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        var perWidth = (width - 1) / scale.count();

        //---- create the horizontal axis line ----
        var x1 = 0;
        var x2 = width - 1;
        var y = 0;

        axisLine = root.append("span")
               .absPosition(x1, y)
               .height(1)
               .width(x2 - x1 + 1)
               .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var x = scale.tickOffset(index);

                var y = 0;
                var y2 = tickLength;

                var tm = root.append("span")
                    .absPosition(x, y)
                    .width(1)
                    .height(y2 - y + 1)
                    .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            var x = perWidth / 2;
            labels = labelStrings.selectWithFunc(function (data, index)
            {
                var y = 0 + tickLength + 2;
                var dx = labelSizes[index].width / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 2)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                x += perWidth;

                return span;
            });
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: scale ----
    closure.scale = function (value)
    {
        if (value === undefined)
        {
            return scale;
        }

        scale = value;
        updateAutoRangeScale();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: values ----
    closure.values = function (value)
    {
        if (value === undefined)
        {
            return values;
        }

        values = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: formatter ----
    closure.formatter = function (value)
    {
        if (value === undefined)
        {
            return formatter;
        }

        formatter = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        markRebuildNeeded();

        return this;
    };

    closure.build();            // create "rootElem" now so we have something to return

    return rootElem;
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// dockPanel.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a docking container.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see colorPalette.html
///-----------------------------------------------------------------------------------------------------------------

/// dockPanel - a container whose children have a docType (top/left/right/bottom/fill) attribute.
vp.visuals.dockPanelFactory = function ()
{
    //---- private state ----
    var data = null;
    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var layoutNeeded = false;
    var dockLayout = null;
    var legendData = [];
    var timer = null;
    var layoutListeners = [];
    var conseqLayoutCount = 0;
    var isLayingOut = false;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: layout()
    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
        layoutNeeded = false;
        isLayingOut = true;

        var kids = root.kids();

        var width = root.width();
        var height = root.height();

        dockLayout = vp.layouts.createDock()
             .width(width)
             .height(height)

        vp.debug("dockPanel: layout of children");

        //---- FIRST PASS - add each child to layout ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var totalWidth = sizes.width + borderWidth;
            var totalHeight = sizes.height + borderHeight;

            var dockType = elem.attr("dockType");
            var isAxis = elem.attr("isAxis");

            var isVisible = (elem.css("display") != "none");

            //dockLayout.addChild(totalWidth, totalHeight, dockType, isAxis, isVisible);
        //});

        ////---- SECOND PASS: now get and APPLY layout bounds for each child ----
        //kids.each(function (index, unwrappedElem)
        //{
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            //---- skip the invisible elements ----
            var isVisible = (elem.css("display") != "none");
            if (isVisible)
            {
                //var bounds = dockLayout.getBoundsByIndex(index);
                var bounds = dockLayout.getBounds(totalWidth, totalHeight, dockType);
                var sizes = elem.elementSizes();

                var borderWidth = sizes.borderWidth;
                var borderHeight = sizes.borderHeight;

                var paddingWidth = sizes.paddingWidth;
                var paddingHeight = sizes.paddingHeight;

                //---- mark as absolute positioning ----
                elem.css("position", "absolute");

                elem.css("left", bounds.x);
                elem.css("top", bounds.y);

                //---- SETTING size does not include padding or border ----

                //---- don't change the width/height to zero (will "erase" intended size early in layout) ----
                if (bounds.width != 0)
                {
                    elem.width(bounds.width - borderWidth - paddingWidth);
                }

                if (bounds.height != 0)
                {
                    elem.height(bounds.height - borderHeight - paddingHeight);
                }

                //elem.show();
            }
            else
            {
                //elem.hide();
            }
        });

        if (!layoutNeeded)
        {
            closure.triggerOnLayout();

            //---- normally, our layout stabilizes after 3-4 iterations ----
            root.show();
        }
        else
        {
            conseqLayoutCount++;

            if (conseqLayoutCount > 5)
            {
                //---- something is wrong - workaround is to force it to stop ----
                //---- at certain sizes, this can be caused by "battling x/y axes" that gain/lose their labels in vicious cycle ----
                if (timer)
                {
                    clearTimeout(timer);
                    timer = null;
                }
                layoutNeeded = false;
                conseqLayoutCount = 0;

                closure.triggerOnLayout();

                root.show();
            }
        }

        isLayingOut = false;
    };

    closure.triggerOnLayout = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure };

        for (var i = 0; i < layoutListeners.length; i++)
        {
            var listener = layoutListeners[i];

            listener.call(null, evt);
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "layout");
    };

    var initialBuild = function ()
    {
        root
            .setClass("vpdockPanel")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .attach("resize", dockPanelResized)
            .attach("DOMNodeInserted", nodeAdded)
            .attach("DOMNodeRemoved", nodeRemoved);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.dockPanel";
    rootElement.control = closure;

    var dockPanelResized = function (e)
    {
        markLayoutNeeded();
    };

    var nodeAdded = function (e)
    {
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vp.attach(elem, "resize", function ()
            {
                if (!isLayingOut)
                {
                    markLayoutNeeded();
                }
            });
        }
    };


    var nodeRemoved = function (e)
    {
        //---- todo: verify that parent is still set when this event is called ----
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vp.detach(elem, "resize", markLayoutNeeded);
        }
    };

    var markLayoutNeeded = function ()
    {
        if (!layoutNeeded)
        {
            layoutNeeded = true;
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (layoutNeeded)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return data;
        }

        data = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: legendData ----
    closure.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    closure.attach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.push(callBack);
        }
        else
        {
            vp.attach(rootElement, eventName, callBack);
        }
    };

    closure.detach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.remove(callBack);
        }
        else
        {
            vp.detach(rootElement, eventName, callBack);
        }
    };

    //---- init code ----
    initialBuild();

    return closure;
};

vp.visuals.dockPanel = function ()
{
    //---- closures must return their closure to work correctly, we we want to return the HTML ----
    //---- element to the caller, so we use this wrapper on the factory ----
    var control = vp.visuals.dockPanelFactory();
    return control.element();
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// gridContainer.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a visual control that contains HTML and SVG elements and lays them out in a fixed M x N grid
///-----------------------------------------------------------------------------------------------------------------
/// testing: see gridContainer.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.gridContainerClass = function ()
{
    //---- private state ----
    var layout = null;
    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;
    var colCount = undefined;
    var rowCount = undefined;
    var cellMargin = undefined;

    //---- closure ----
    var closure = function()
    {
    }

    closure.layout = function ()
    {
        //vp.debug("gridContainer.layout: width=" + root.width() + ", height=" + root.height());

        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        var kids = root.kids();
        var width = root.width();
        var height = root.height(); 

        var cm = cellMargin;
        if (cm === undefined)
        {
            cm = [0, 0, 0, 0];
        }
        else if (vp.isNumber(cm))
        {
            cm = [cm, cm, cm, cm];
        }

        var gridLayout = vp.layouts.createGrid()
            .width(width)
            .height(height)
            .count(kids.length)
            .colCount(colCount)
            .rowCount(rowCount)

        //---- layout children ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            var paddingWidth = sizes.paddingWidth;
            var paddingHeight = sizes.paddingHeight;

            var marginWidth = sizes.marginWidth;
            var marginHeight = sizes.marginHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var elemWidth = sizes.width;        // + borderWidth;
            var elemHeight = sizes.height;  //  + borderHeight;

            //---- get BOUNDS from layout for this item (by index) ----
            var bounds = gridLayout.getBoundsByIndex(index);

            //---- set BOUNDS ----
            //---- SETTING size does not include padding or border ----
            var x = bounds.x + cm[0];        // left margin
            var y = bounds.y + cm[1];        // top margin
            var w = (bounds.width - paddingWidth - borderWidth - marginWidth) - (cm[0] + cm[2]);
            var h = (bounds.height - paddingHeight - borderHeight - marginHeight) - (cm[1] + cm[3]);

            elem
                .absPosition(x, y)
                .width(w)
                .height(h);
        });

    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "colCount");
        vp.makeControlProperty(wrapper, "rowCount");
        vp.makeControlProperty(wrapper, "cellMargin");
    };

    var initialBuild = function()
    {
        root
            .setClass("gridContainer")
            .css("position", "relative")    // so it can hold absolute position elements
            .attach("resize", markLayoutNeeded)
            .attach("DOMNodeInserted", nodeAddOrDelete)
            .attach("DOMNodeRemoved", nodeAddOrDelete);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.gridContainer";
    rootElement.control = closure;

    var nodeAddOrDelete = function (e)
    {
        if (e.relatedNode == rootElement)
        {
            markLayoutNeeded();
        }
    };

    var markLayoutNeeded = function()
    {
        //vp.debug("gridContainer.markLayoutNeeded");

        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }
    }

    /// readonly property: element
    closure.element = function ()
    {
        return rootElement;
    };

    /// property: colCount
    closure.colCount = function (value)
    {
        if (arguments.length === 0)
        {
            return colCount;
        }
        else
        {
            colCount = value;
            return closure;
        }
    };

    /// property: rowCount
    closure.rowCount = function (value)
    {
        if (arguments.length === 0)
        {
            return rowCount;
        }
        else
        {
            rowCount = value;
            return closure;
        }
    };


    /// property: cellMargin
    closure.cellMargin = function (value)
    {
        if (arguments.length === 0)
        {
            return cellMargin;
        }
        else
        {
            cellMargin = value;
            return closure;
        }
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}

vp.visuals.createGridContainer = function ()
{
    return vp.visuals.gridContainerClass();
}

vp.visuals.createGridContainerWrapped = function ()
{
    var elem = vp.visuals.gridContainerClass();
    var wrap = vp.select(elem);         // now it supports IGridContainer

    return wrap;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// gridLines.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements 2D gridlines for a plot.
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.gridLines = function ()
{
    //---- private state ----
    var verticalScale = null;
    var horizontalScale = null;

    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        root.clear();

        var width = root.width();
        var height = root.height();

        if (horizontalScale)
        {
            //---- draw horizontal lines ----
            var count = horizontalScale.tickCount();

            if (count < height)          // don't draw if too close together
            {
                vp.range(count).generate(root, "span", function (elem, dataItem, index)
                {
                    if ((index > 0) && (index < count - 1))     // don't overwrite axes
                    {
                        var y = horizontalScale.tickOffset(index);

                        //---- adjust for the fact we are undersized by 1 on all 4 sides ----
                        elem
                            .setClass("vpHorizontalGridLine")
                            .absPosition(0, y - 1)
                            .width(width)
                            .height(1)
                    }
                });
            }
        }

        if (verticalScale)
        {
            //---- draw vertical lines ----
            var count = verticalScale.tickCount();

            if (count < width)          // don't draw if too close together
            {

                vp.range(count).generate(root, "span", function (elem, dataItem, index)
                {
                    if ((index > 0) && (index < count - 1))     // don't overwrite axes
                    {
                        var x = verticalScale.tickOffset(index);

                        //---- adjust for the fact we are undersized by 1 on all 4 sides ----
                        elem
                            .setClass("vpVerticalGridLine")
                            .absPosition(x - 1, 0)
                            .height(height)
                            .width(1)
                    }
                });
            }
        }

    };

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "verticalScale");
        vp.makeControlProperty(wrapper, "horizontalScale");
    };

    var initialBuild = function()
    {
        root
            .setClass("vpGridLines")
            .css("background", "yellow")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")   
            .attach("resize", markLayoutNeeded)

        markLayoutNeeded();
    }

    layout.ctr = "vp.visuals.gridLines";
    rootElement.control = layout;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(layout, 1);
        }
    }

    layout.element = function ()
    {
        return rootElement;
    };

    //---- property: verticalScale ----
    layout.verticalScale = function (value)
    {
        if (value === undefined)
        {
            return verticalScale;
        }

        verticalScale = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: horizontalScale ----
    layout.horizontalScale = function (value)
    {
        if (value === undefined)
        {
            return horizontalScale;
        }

        horizontalScale = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// legend.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a simple chart legend.
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.legend = function ()
{
    //---- private state ----
    var legendData = null;

    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        root.clear();

        var width = root.width();
        var height = root.height();

        if (legendData)
        {
            var table = root.append("table")
                .setClass("legendTable")

            for (var i = 0; i < legendData.length; i++)
            {
                var legendRecord = legendData[i];

                var row = table.append("tr");
                
                //---- color sample ----
                row.append("td")
                    .append("div")
                        .setClass("legendEntryColor")
                        .background(legendRecord.color)

                //---- name ----
                row.append("td")
                     .append("span")
                        .setClass("legendEntryName")
                        .text(legendRecord.name)
                        .attr("title", legendRecord.toolTip);

            }
        }

    };

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");
    };

    var initialBuild = function()
    {
        root
            .setClass("legend")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .css("display", "inline-table")
            .attach("resize", markLayoutNeeded)

        markLayoutNeeded();
    }

    layout.ctr = "vp.visuals.legend";
    rootElement.control = layout;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(layout, 1);
        }
    }

    layout.element = function ()
    {
        return rootElement;
    };

    //---- property: legendData ----
    layout.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// numericAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///                  Part of the vuePlot library - a numeric axis.  Can be used for left, top, right, bottom of plot.
///-----------------------------------------------------------------------------------------------------------------
/// create an HTML-based numeric axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see numericAxis.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.numericAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label
    var labelStrings = [];
    var labelWidths = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var myScale = vp.scales.createSpace();        // linear();     // default
    var formatter = undefined;
    var changingSize = false;

    //---- HTML elements ----
    var rootElem = null;
    var axisLine = null;
    var tickMarks = null;
    var labels = null;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.numericAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "formatter");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(build, 1);
        }
    };

    /// private.
    var pixelAlign = function (value)
    {
        return Math.round(value);
    };

    /// private.
    var buildLabelStringsAndSizes = function (data)
    {
        labelStrings = [];
        labelWidths = [];

        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;

        //---- create a TEXT element for measuring strings ----
        var fakeLabel = vp.select(document.body)
            .append("span")
            .setClass("vpNumericAxis_label");

        data.selectWithFunc(function (value, index)
        {
            var formatFunc = (formatter === undefined) ? vp.formatters.comma : formatter;

            var labelStr = formatFunc(value);
            labelStrings.push(labelStr);

            //---- set up for measuring "labelStr" ----
            fakeLabel.text(labelStr);

            var width = Math.ceil(fakeLabel.width());
            var height = Math.ceil(fakeLabel.height());

            if (width > maxStringWidth)
            {
                maxStringWidth = width;
            }

            if (height > maxStringHeight)
            {
                maxStringHeight = height;
            }

            labelWidths.push(width);
            dataCount++;
        });

        totalLabelWidths = maxStringWidth * dataCount;
        totalLabelHeights = maxStringHeight * dataCount;

        //---- remove temp label created above ----
        fakeLabel.remove();
    }

    //---- private: build() ----
    var build = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        if (rootElem == null)
        {
            //---- first build ----
            rootElem = vp.createHtml("div");
            vp.setClass(rootElem, "numericAxis");
            vp.attach(rootElem, "resize", elementResized);
            vp.css(rootElem, "position", "relative")
            vp.css(rootElem, "overflow", "visible");            // let labels overlap the boundaries of the axis

            rootElem.control = closure;
        }

        var root = vp.select(rootElem)
            .clear();

        if ((isAxisVisible) && (myScale != null))
        {
            var min = myScale.domainMin();
            var max = myScale.domainMax();
            var tickCount = myScale.tickCount();

            var incr = (max - min) / (tickCount - 1);
            var data = vp.range(min, max, incr);

            buildLabelStringsAndSizes(data);

            if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                buildLeftElements(root, min, max, data);
            } 
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                buildRightElements(root, min, max, data);
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                buildTopElements(root, min, max, data);
            }
            else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
            {
                buildBottomElements(root, min, max, data);
            }
        }
    };
    
    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            updateAutoRangeScale();
        }
    };

    var updateAutoRangeScale = function ()
    {
        var root = vp.select(rootElem);

        if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
        {
            calcWidthFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
        {
            calcWidthFromScale(root);
        }

        markRebuildNeeded();
    };

    var setRootWidth = function (value)
    {
        changingSize = true;

        vp.width(rootElem, value);

        changingSize = false;
    };

    var setRootHeight = function (value)
    {
        changingSize = true;

        vp.height(rootElem, value);

        changingSize = false;
    };

    var calcHeightFromScale = function (root)
    {
        var height = 0;
        if (myScale.autoRange())
        {
            height = root.height();

            myScale.rangeMin(0);
            myScale.rangeMax(height - 1);
        }
        else
        {
            height = myScale.rangeMax() - myScale.rangeMin();
        }

        return height;
    }

    var calcWidthFromScale = function (root)
    {
        var width = 0;
        if (myScale.autoRange())
        {
            width = root.width();

            myScale.rangeMin(0);
            myScale.rangeMax(width - 1);
        }
        else
        {
            width = myScale.rangeMax() - myScale.rangeMin();
        }

        return width;
    }

    /// private: buildLeftElements()
    var buildLeftElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (dataCount * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var x = pixelAlign(width - 1);
        var y1 = pixelAlign(myScale.flipScale(min));
        var y2 = pixelAlign(myScale.flipScale(max));

        //---- create the vertical axis line ----
        axisLine = root.append("span")
                .absPosition(x, y2)
                .width(1)
                .height(y1 - y2 + 1)
                .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var x1 = pixelAlign(width - tickLength - 1);
                var x2 = pixelAlign(width - 1);

                var y = myScale.tickOffset(index);

                var tm = root.append("span")
                        .absPosition(x1, y)
                        .height(1)
                        .width(Math.abs(x2 - x1 + 1))
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.selectWithFunc(function (data, index)
            {
                var labelSize = labelWidths[index];
                var x = pixelAlign(width - tickLength - labelSpace - 1 - labelSize);

                var y = pixelAlign(myScale.flipScale(data));
                var dy = pixelAlign(maxStringHeight / 2);

                var labelStr = labelStrings[index];

                var span = root.append("span")
                        .absPosition(x + 1, y - dy)
                        .text(labelStr)
                        .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildRightElements()
    var buildRightElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (dataCount * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        //---- create the vertical axis line ----
        var y1 = myScale.flipScale(min);
        var y2 = myScale.flipScale(max);

        axisLine = root.append("span")
                .absPosition(0, y2)
                .width(1)
                .height(y1 - y2 + 1)
                .setClass("vpNumericAxis");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var y = myScale.tickOffset(index);

                var x1 = pixelAlign(0);
                var x2 = pixelAlign(tickLength);

                var tm = root.append("span")
                        .absPosition(x1, y)
                        .height(1)
                        .width(Math.abs(x2 - x1 + 1))
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.selectWithFunc(function (data, index)
            {
                var y = myScale.flipScale(data);
                var x = tickLength + labelSpace;
                var dy = pixelAlign(maxStringHeight / 2);

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x, y - dy)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildTopElements()
    var buildTopElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (dataCount * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        //---- create the horizontal axis line ----
        var x1 = myScale.scale(min);
        var x2 = myScale.scale(max);
        var y = height-1;

        axisLine = root.append("span")
                .absPosition(x1, y)
                .height(1)
                .width(x2 - x1 + 1)
                .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var x = myScale.tickOffset(index);

                var y = height - 1;
                var y2 = height - tickLength - 1;

                var tm = root.append("span")
                        .absPosition(x, y2)
                        .width(1)
                        .height(y - y2 + 1)
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.selectWithFunc(function (data, index)
            {
                var x = myScale.scale(data);
                var y = 0;
                var dx = labelWidths[index] / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 1)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildBottomElements()
    var buildBottomElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (dataCount * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        //---- create the horizontal axis line ----
        //---- y coordinates here are SVG std (grow from top) ----
        var x1 = myScale.scale(min);
        var x2 = myScale.scale(max);
        var y = 0;

        axisLine = root.append("span")
               .absPosition(x1, y)
               .height(1)
               .width(x2 - x1 + 1)
               .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.selectWithFunc(function (data, index)
            {
                var x = myScale.tickOffset(index);

                var y = 0;
                var y2 = tickLength;

                var tm = root.append("span")
                        .absPosition(x, y)
                        .width(1)
                        .height(y2 - y + 1)
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.selectWithFunc(function (data, index)
            {
                var x = myScale.scale(data);
                var y = tickLength + 1;
                var dx = labelWidths[index] / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 2)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: scale ----
    closure.scale = function (value)
    {
        if (value === undefined)
        {
            return myScale;
        }

        myScale = value;
        updateAutoRangeScale();

        if (formatter === undefined)
        {
            if ((myScale) && (myScale.scaleType == "date"))
            {
                formatter = vp.formatters.date;
            }
            else
            {
                formatter = vp.formatters.comma;
            }
        }

        markRebuildNeeded();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: formatter ----
    closure.formatter = function (value)
    {
        if (value === undefined)
        {
            return formatter;
        }

        formatter = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        markRebuildNeeded();

        return closure;
    };

    build();        // so "rootElem" is set before we return

    return rootElem;
};

//---- enum: axisLocation ----
vp.axisLocation = { left: 0, top: 1, right: 2, bottom: 3 };
﻿///-----------------------------------------------------------------------------------------------------------------
/// plotBox.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a docking container that can be used to build a variety of plots.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see plotBox.html
///-----------------------------------------------------------------------------------------------------------------

/// plotBox is basically a DOCK layout container with the special ability to properly size contiguous axes.
vp.visuals.plotBoxFactory = function ()
{
    //---- private state ----
    var data = null;
    var rootElement = vq.createHtml("div");
    var root = vq.select(rootElement);
    var layoutNeeded = false;
    var dockLayout = null;
    var legendData = [];
    var timer = null;
    var layoutListeners = [];
    var conseqLayoutCount = 0;
    var isLayingOut = false;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: layout()
    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
        layoutNeeded = false;
        isLayingOut = true;

        var kids = root.kids();

        var width = root.width();
        var height = root.height();

        dockLayout = vp.layouts.dockForAxes()
             .width(width)
             .height(height)

        vq.debug("plotBox: layout of children");

        //---- FIRST PASS - add each child to layout ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vq.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var totalWidth = sizes.width + borderWidth;
            var totalHeight = sizes.height + borderHeight;

            var dockType = elem.attr("dockType");
            var isAxis = elem.attr("isAxis");

            var isVisible = (elem.css("display") != "none");

            dockLayout.addChild(totalWidth, totalHeight, dockType, isAxis, isVisible);
        });

        //---- SECOND PASS: now get and APPLY layout bounds for each child ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vq.select(unwrappedElem);

            //---- skip the invisible elements ----
            var isVisible = (elem.css("display") != "none");
            if (isVisible)
            {
                var bounds = dockLayout.getBounds(index);
                var sizes = elem.elementSizes();

                var borderWidth = sizes.borderWidth;
                var borderHeight = sizes.borderHeight;

                var paddingWidth = sizes.paddingWidth;
                var paddingHeight = sizes.paddingHeight;

                //---- mark as absolute positioning ----
                elem.css("position", "absolute");

                elem.css("left", bounds.x);
                elem.css("top", bounds.y);

                //---- SETTING size does not include padding or border ----

                //---- don't change the width/height to zero (will "erase" intended size early in layout) ----
                if (bounds.width != 0)
                {
                    elem.width(bounds.width - borderWidth - paddingWidth);
                }

                if (bounds.height != 0)
                {
                    elem.height(bounds.height - borderHeight - paddingHeight);
                }

                //elem.show();
            }
            else
            {
                //elem.hide();
            }
        });

        if (!layoutNeeded)
        {
            closure.triggerOnLayout();

            //---- normally, our layout stabilizes after 3-4 iterations ----
            root.show();
        }
        else
        {
            conseqLayoutCount++;

            if (conseqLayoutCount > 5)
            {
                //---- something is wrong - workaround is to force it to stop ----
                //---- at certain sizes, this can be caused by "battling x/y axes" that gain/lose their labels in vicious cycle ----
                if (timer)
                {
                    clearTimeout(timer);
                    timer = null;
                }
                layoutNeeded = false;
                conseqLayoutCount = 0;

                closure.triggerOnLayout();

                root.show();
            }
        }

        isLayingOut = false;
    };

    closure.triggerOnLayout = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure };

        for (var i = 0; i < layoutListeners.length; i++)
        {
            var listener = layoutListeners[i];

            listener.call(null, evt);
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "layout");
    };

    var initialBuild = function ()
    {
        root
            .setClass("vpPlotBox")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .attach("resize", plotBoxResized)
            .attach("DOMNodeInserted", nodeAdded)
            .attach("DOMNodeRemoved", nodeRemoved);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.plotBox";
    rootElement.control = closure;

    var plotBoxResized = function (e)
    {
        markLayoutNeeded();
    };

    var nodeAdded = function (e)
    {
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vq.attach(elem, "resize", function ()
            {
                if (!isLayingOut)
                {
                    markLayoutNeeded();
                }
            });
        }
    };


    var nodeRemoved = function (e)
    {
        //---- todo: verify that parent is still set when this event is called ----
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vq.detach(elem, "resize", markLayoutNeeded);
        }
    };

    var markLayoutNeeded = function ()
    {
        if (!layoutNeeded)
        {
            layoutNeeded = true;
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (layoutNeeded)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return data;
        }

        data = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: legendData ----
    closure.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    closure.attach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.push(callBack);
        }
        else
        {
            vq.attach(rootElement, eventName, callBack);
        }
    };

    closure.detach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.remove(callBack);
        }
        else
        {
            vq.detach(rootElement, eventName, callBack);
        }
    };

    //---- init code ----
    initialBuild();

    return closure;
};

vp.visuals.plotBox = function ()
{
    //---- closures must return their closure to work correctly, we we want to return the HTML ----
    //---- element to the caller, so we use this wrapper on the factory ----
    var control = vp.visuals.plotBoxFactory();
    return control.element();
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// ribbonBar.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a ribbon-like toolbar for containing controls (buttons, checkboxes, textboxes, etc).
///-----------------------------------------------------------------------------------------------------------------
/// testing: ribbonBar.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.ribbonBar = function ()
{
    //---- private state ----
    var rootElement = vp.createHtml("div");     // vp.visuals.createGridContainer();
    var root = vp.select(rootElement);
    var timer = null;
    var groups = [];

    //---- closure ----
    var closure = function()
    {
    }

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "name");
        //vp.makeControlProperty(wrapper, "halign");
        //vp.makeControlProperty(wrapper, "rotation");
    };

    var initialBuild = function()
    {
        root
            .setClass("vpRibbonBar")
            .css("overflow", "hidden") 
    }

    closure.ctr = "vp.visuals.ribbonBar";
    rootElement.control = closure;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        return rootElement;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// ribbonGroup.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a ribbon-like group containing controls (buttons, checkboxes, textboxes, etc).
///     - typically, is appended to a ribbonBar container.
///-----------------------------------------------------------------------------------------------------------------
/// testing: ribbonBar.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.ribbonGroup = function ()
{
    //---- private state ----
    var rootElement = vp.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;
    var rows = [];
    var nextRow = 0;
    var nameElem = null;
    var text = "Group";
    var rowCount = 2;       // for controls

    //---- closure ----
    var closure = function()
    {
    }

    /// add the content as a new "td" element in either row[0] or row[1].
    closure.append = function (content)
    {
        if (nextRow >= rowCount)
        {
            nextRow = 0;
        }

        var row = rows[nextRow++];
        var td = row.append("td")
            .setClass("ribbonGroupEntry")

        var elem = vp.append(td[0], content);
        return elem;
    };

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        //vp.makeControlProperty(wrapper, "valign");

        vp.makeControlProperty(wrapper, "text");
        vp.makeControlFunc(wrapper, "startNewRow");
        vp.makeControlFuncWithReturnValue(wrapper, "append");
    };

    closure.startNewRow = function ()
    {
        nextRow = 0;
    };

    var initialBuild = function()
    {
        root
            .setClass("ribbonGroup")
        //.css("position", "relative")    // so it can hold absolute position elements
            //.attach("resize", markLayoutNeeded)
            //.attach("DOMNodeInserted", nodeAddOrDelete)
            //.attach("DOMNodeRemoved", nodeAddOrDelete);

        var table = root.append("table")
            .attr("cellspacing", 0)
            .attr("cellpadding", 0)
            .setClass("ribbonGroupTable");

        rows = [];      // for row1-row3

        for (var j = 0; j < rowCount; j++)
        {
            var row = table.append("tr")
                .setClass("ribbonBarRow");

            rows.push(row);
        }

        //---- add the group name in a 3rd row, spanning all columns defined for the group ----
        nameElem = table.append("tr")
            .append("td")
                .attr("colSpan", "999")
                .setClass("ribbonGroupNameTd")
                .append("span")
                .setClass("ribbonGroupName")
                    .text("Group");

        nextRow = 0;
    }

    closure.ctr = "vp.visuals.ribbonGroup";
    rootElement.control = closure;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        return rootElement;
    };

    //---- property: text ----
    closure.text = function (value)
    {
        if (arguments.length == 0)
        {
            return text;
        }

        text = value;
        nameElem.text(value);

        return closure;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}


﻿///-----------------------------------------------------------------------------------------------------------------
/// routeFuncCalls.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------

vp.makeControlProperty = function (wrapper, propName)
{
    var propFunc = function (value)
    {
        //---- GET value ----
        if (arguments.length == 0)
        {
            var value = null;
            if (wrapper.length > 0)
            {
                var f = wrapper[0].control[propName];
                value = f.call();
            }

            return value;
        }
        else
        {
            var args = arguments; 

            //---- SET value ----
            return wrapper.each(function (index, element)
            {
                //---- control stored on actual element, not wrapper ----
                var f = element[0].control[propName];
                f.apply(null, args);
            });
        }
    };

    wrapper[propName] = propFunc;
};

vp.makeControlFunc = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;

        return wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            f.apply(control, args);
        });
    };

    wrapper[funcName] = func;
};

vp.makeControlFuncWithReturnValue = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;
        var returnValue = undefined;

        wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            returnValue = f.apply(control, args);
        });

        return returnValue;
    };

    wrapper[funcName] = func;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// scrollbar.js.  Copyright (c) 2012 Microsoft Corporation.
///      - part of the vuePlot library.
///      - implements a horizontal or vertical scrollbar.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see scrollBars.html
///-----------------------------------------------------------------------------------------------------------------

/// create a customizable scrollbar control.
vp.scrollBarFactory = function (isVertical)
{
    //---- private state ----
    var min = 0;
    var max = 100;
    var value = 0;
    var domElement = null;
    var svgElement = null;
    var root = null;
    var scrollTrack = null;
    var scrollThumb = null;
    var box1 = null;
    var box2 = null;
    var smallChange = 1;
    var largeChange = 10;
    var isProportional = false;
    var contentSize = 0;
    var scrollBarId = vp.nextScrollBarId++;     // unique id for all scrollbars (helps debugging)

    var changeListeners = [];
    var toggleListeners = [];
    var mouseDownX = 0;
    var mouseDownY = 0;
    var isMovingThumb = false;
    var isMouseDown = false;
    var mouseDownTime = 0;
    var lastMouseDoc = { x: 0, y: 0 };
    var movedByUser = false;
    var valueChangedDuringTouch = null;
    var trackHeight = 0;
    var trackWidth = 0;
    var thumbWidth = 0;
    var thumbHeight = 0;
    var timer = null;
    var autoRepeatTimer = null;
    var autoRepeatCmd = null;
    var defaultScrollBarSize = 16;
    var thumbMargin = 1;            // for hsb, space on top/bottom of thumb; for vsb, space on left/right

    var closure = function ()
    {
    };

    //---- public: update() ----
    closure.update = function ()
    {
        setValue(value, true);
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scrollThumb");
        vp.makeControlProperty(wrapper, "scrollTrack");
        vp.makeControlProperty(wrapper, "min");
        vp.makeControlProperty(wrapper, "max");
        vp.makeControlProperty(wrapper, "value");
        vp.makeControlProperty(wrapper, "box1");
        vp.makeControlProperty(wrapper, "box2");
        vp.makeControlProperty(wrapper, "isProportional");
        vp.makeControlProperty(wrapper, "smallChange");
        vp.makeControlProperty(wrapper, "largeChange");
        vp.makeControlProperty(wrapper, "contentSize");
        vp.makeControlProperty(wrapper, "getTrackWidth");
        vp.makeControlProperty(wrapper, "getTrackHeight");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "scrollTo");
        vp.makeControlFunc(wrapper, "layout");
        vp.makeControlFunc(wrapper, "processMouseWheelEvent");
    };

    //---- private: build() ----
    var build = function ()
    {
        /// Note: non-IE browsers don't like SVG elements with negative coordinates (they get chopped off), so make sure
        /// we layout everything at >= 0,0.
        value = min;

        if (domElement == null)
        {
            //---- create a DIV to hold the SVG so that we can hook keyboard events thru the DIV ----
            domElement = vp.createHtml("div");
            vp.setClass(domElement, "scrollBar");

            svgElement = vp.append(domElement, "svg")[0];

            root = vp.select(svgElement)
                .css("display", "block")
                .css("cursor", "default");

            if (isVertical)
            {
                closure.ctr = "vp.visuals.verticalScrollbar";
            }
            else
            {
                closure.ctr = "vp.visuals.horizontalScrollbar";
            }

            //---- add a property on element to get access to control (closure object) ----
            domElement.control = closure;
        }

        root.clear();

        scrollTrack = root.append("rect")
            .addClass("scrollTrack")
            .id("scrollTrack")
            .bounds(0, 0, 50, defaultScrollBarSize);

        scrollThumb = root.append("rect")
            .addClass("scrollThumb")
            .id("scrollThumb")
            .bounds(0, 0, 8, 16)
            //.attr("rx", 2)
            //.attr("ry", 2);

        box1 = appendBox(root, defaultScrollBarSize, true)
            .addClass("scrollBox")
            .id("box1")

        box2 = appendBox(root, defaultScrollBarSize, false)
            .addClass("scrollBox")
            .id("box2")

        if (isVertical)
        {
            setTrackHeight(50);
            setTrackWidth(defaultScrollBarSize);
        }
        else
        {
            setTrackHeight(defaultScrollBarSize);
            setTrackWidth(50);
        }

        //---- set up RESIZE, MOUSE, KEYBOARD, and TOUCH event handling ----
        vp.attach(domElement, "resize", function (e)
        {
            var width = vp.width(domElement);
            var height = vp.height(domElement);

            setTrackWidth(width);
            setTrackHeight(height);
        });

        vp.attach(domElement, "keyup", function (e)
        {
            cancelAutoRepeat();
        });

        vp.attach(domElement, "mousewheel", function (e)
        {
            closure.processMouseWheelEvent(e);
        });

        vp.attach(domElement, "keydown", function (e)
        {
            if (isVertical)
            {
                if (e.keyCode == vp.keyCodes.up)
                {
                    closure.scrollTo(vp.scrollCmds.smallDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.keyCodes.down)
                {
                    closure.scrollTo(vp.scrollCmds.smallIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                else if (e.keyCode == vp.keyCodes.pageUp)
                {
                    closure.scrollTo(vp.scrollCmds.largeDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.keyCodes.pageDown)
                {
                    closure.scrollTo(vp.scrollCmds.largeIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                    // CHW: two extra cases
                else if (e.keyCode == vp.keyCodes.home)
                {
                    closure.scrollTo(vp.scrollCmds.home);
                }
                else if (e.keyCode == vp.keyCodes.end)
                {
                    closure.scrollTo(vp.scrollCmds.end);
                }
            }
            else
            {
                if (e.keyCode == vp.keyCodes.left)
                {
                    closure.scrollTo(vp.scrollCmds.smallDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.keyCodes.right)
                {
                    closure.scrollTo(vp.scrollCmds.smallIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                else if (e.keyCode == vp.keyCodes.pageUp)
                {
                    closure.scrollTo(vp.scrollCmds.largeDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.keyCodes.pageDown)
                {
                    closure.scrollTo(vp.scrollCmds.largeIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
            }
        });

        //---- event strategy: hook mouseenter/exit to know when to enable the "mousedown" event handler, using
        //---- the "capture" flag of event listener to get priority access (during capture phase) to event.  ----
        root.attach("mouseover", function (e)
        {
            root.attach("mousedown", onMouseDown, true);
        });

        root.attach("mouseout", function (e)
        {
            root.detach("mousedown", onMouseDown, true);
        });

        //---- use "touch" instead of "mouse" events (works better across devices) ----
        //---- in order to approximate "capture" behavior, we hook the document & ensure mousedown is on scrollThumb ----
        //vp.touchEventHandler(document.body, onTouchDown, onTouchMove, onTouchUp);
    };

    /// private.
    closure.processMouseWheelEvent = function (e)
    {
        if (vp.visibility(domElement) == "visible")
        {
            if (e.wheelDelta < 0)
            {
                closure.scrollTo(vp.scrollCmds.smallIncrement, 3);
            }
            else
            {
                closure.scrollTo(vp.scrollCmds.smallDecrement, 3);
            }
        }
    };

    /// private.
    var appendBox = function (root, size, isFirst)
    {
        //---- create a compound shape: triangle within a rect ----
        var group = root.append("g")

        //---- create a background rect to easily detect box vs. track mousedown ----
        group
            .append("rect")
                .bounds(0, 0, size, size)

        var path = group.append("path")

        setBoxUpClass(group);

        if (isFirst)
        {
            if (isVertical)
            {
                //---- down pointing triangle ----
                path.attr("d", "M 4 12 L 12 12 L 8 4 z");
            }
            else
            {
                //---- right pointing triangle ----
                path.attr("d", "M 12 4 L 12 12 L 4 8 z");
            }
        }
        else
        {
            if (isVertical)
            {
                //---- up pointing triangle ----
                path.attr("d", "M 4 4 L 12 4 L 8 12 z");
            }
            else
            {
                //---- left pointing triangle ----
                path.attr("d", "M 4 4 L 4 12 L 12 8 z");
            }
        }

        return group;
    };

    closure.element = function ()
    {
        return domElement;
    };

    closure.scrollThumb = function ()
    {
        return scrollThumb;
    };

    closure.scrollTrack = function ()
    {
        return scrollTrack;
    };

    closure.box1 = function ()
    {
        return box1;
    };

    closure.box2 = function ()
    {
        return box2;
    };

    /// private: setValue().
    var setValue = function (newValue, force)
    {
        //---- round value to nearest "smallChange" ----
        //newValue = smallChange * Math.round(newValue / smallChange);

        newValue = Math.round(newValue);        // round to whole pixel

        //---- adjust value so its within limits ----
        if (newValue < min)
        {
            newValue = min;
        }
        else if (newValue > max)
        {
            newValue = max;
        }

        if ((force) || (newValue != value))
        {
            value = newValue;

            if (force)
            {
                if (isVertical)
                {
                    var top = 0 + trackWidth;;
                    var bottom = trackHeight - (trackWidth + thumbHeight);

                    var yValue = vp.mapValue(value, min, max, top, bottom);

                    //---- move thumb ----
                    scrollThumb.attr("y", yValue);
                }
                else
                {
                    var left = 0 + trackHeight;
                    var right = trackWidth - (trackHeight + thumbWidth);

                    var xValue = vp.mapValue(value, min, max, left, right);

                    //---- move thumb ----
                    scrollThumb.attr("x", xValue);
                }
            }

            //---- call event listeners ----
            onChange();
        }
    };

    /// private: markLayoutNeeded().
    var markLayoutNeeded = function ()
    {
        if (timer == null)
        {
            //---- caution: do not use an inline function here - causes us to call the wrong closure instance ----
            //---- under certain (unknown) conditions. ----
            timer = setTimeout(closure.layout, 1);
        }
    };

    /// private: onChange().
    var onChange = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure, value: value };

        for (var i = 0; i < changeListeners.length; i++)
        {
            var callback = changeListeners[i];

            callback(evt);
        }
    };

    /// private: onToggle().
    var onToggle = function ()
    {
        //---- create a simplified event object ----
        var evt = { src: closure, value: value };

        for (var i = 0; i < toggleListeners.length; i++)
        {
            var callback = toggleListeners[i];

            callback(evt);
        }
    };

    //---- function: attach() ----
    closure.attach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.push(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.push(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global attach function
            vp.attach(domElement, eventName, callback);
        }

        return this;
    };

    //---- function: detach() ----
    closure.detach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.remove(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.remove(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global deattach function
            vp.detach(domElement, eventName, callback);
        }

        return closure;
    };

    /// private: onMouseMove().
    var onMouseMove = function (e)
    {
        document.body.style.cursor = "default";

        //vp.debug("vpslider.onTouchMove: e.type=" + e.type);
        //vp.debug("onTouchMove: isMouseDown=" + isMouseDown);

        var mouseDoc = vp.mousePosition(e);

        if (isMouseDown)
        {
            if (!isMovingThumb)
            {
                //---- have we gone far enough or waited long enough? ----
                var delta = new Date() - mouseDownTime;
                if (delta > 100)
                {
                    isMovingThumb = true;
                }
                else
                {
                    var xdiff = Math.abs(mouseDoc.x - lastMouseDoc.x);
                    var ydiff = Math.abs(mouseDoc.y - lastMouseDoc.y);

                    if ((xdiff >= 4) || (ydiff >= 4))
                    {
                        isMovingThumb = true;
                    }
                }
            }

            if (isMovingThumb)
            {
                movedByUser = true;
                valueChangedDuringTouch = true;

                //---- goal is to set new X location for THUMB (relative to our local svg document) ----
                //---- "doc" variables here refer to coordinates relative to main document origin ----
                //---- "svg" variables here refer to coordinates relative to local svg document ----

                //---- compute mouse location relative to my svg document ----
                var newValue = 0;

                //var trackHeighth = scrollTrack.height();
                //var trackWidth = scrollTrack.width();

                if (isVertical)
                {
                    var mouseYDoc = mouseDoc.y;

                    var newYDoc = mouseYDoc - mouseDownY;
                    var newYSvg = newYDoc - vp.docOffset(scrollTrack[0]).top;

                    var topSvg = 0 + trackWidth;
                    var bottomSvg = trackHeight - (trackWidth + thumbHeight);

                    if (newYSvg < topSvg)
                    {
                        newYSvg = topSvg;
                    }
                    else if (newYSvg > bottomSvg)
                    {
                        newYSvg = bottomSvg;
                    }

                    //---- move thumb ----
                    scrollThumb.attr("y", newYSvg);

                    newValue = vp.mapValue(newYSvg, topSvg, bottomSvg, min, max);
                }
                else
                {
                    var mouseXDoc = mouseDoc.x;

                    var newXDoc = mouseXDoc - mouseDownX;
                    var newXSvg = newXDoc - vp.docOffset(scrollTrack[0]).left;

                    var leftSvg = 0 + trackHeight;
                    var rightSvg = trackWidth - (trackHeight + thumbWidth);

                    if (newXSvg < leftSvg)
                    {
                        newXSvg = leftSvg;
                    }
                    else if (newXSvg > rightSvg)
                    {
                        newXSvg = rightSvg;
                    }

                    //---- move thumb ----
                    scrollThumb.attr("x", newXSvg);

                    newValue = vp.mapValue(newXSvg, leftSvg, rightSvg, min, max);
                }

                setValue(newValue, false);

                //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
                e.cancelBubble = true;
                e.stopPropagation();
                e.returnValue = false;
            }
        }

        lastMouseDoc = mouseDoc;
    };

    /// private.
    var setBoxUpClass = function (box)
    {
        var kids = box[0].childNodes;

        vp.setClass(kids[0], "scrollBox");
        vp.setClass(kids[1], "scrollBoxShape");
    };

    /// private.
    var setBoxDownClass = function (box)
    {
        var kids = box[0].childNodes;

        vp.setClass(kids[0], "scrollBoxDown");
        vp.setClass(kids[1], "scrollBoxShapeDown");
    };

    /// private: onMouseUp().
    var onMouseUp = function (e)
    {
        cancelAutoRepeat();

        isMovingThumb = false;
        isMouseDown = false;

        setBoxUpClass(box1);
        setBoxUpClass(box2);

        vp.releaseCapture(document.body, e, onMouseMove, onMouseUp);

        if (valueChangedDuringTouch === false)
        {
            //---- trigger the TOGGLE event ----
            onToggle();
        }
    };

    /// private: cancelAutoRepeat()
    var cancelAutoRepeat = function ()
    {
        if (autoRepeatTimer)
        {
            clearTimeout(autoRepeatTimer);
            autoRepeatTimer = null;
        }
    };

    /// private: autoRepeat()
    var autoRepeat = function ()
    {
        closure.scrollTo(autoRepeatCmd);

        //---- set up next timer ----
        autoRepeatTimer = setTimeout(autoRepeat, 80);      // 12.5 per second
    };

    /// private: initAutoRepeat()
    var initAutoRepeat = function (cmd)
    {
        //---- cancel existing auto repeat, if any ----
        cancelAutoRepeat();

        autoRepeatTimer = setTimeout(autoRepeat, 500);      // initial delay
        autoRepeatCmd = cmd;
    };

    /// private: onMouseDown().
    var onMouseDown = function (e)
    {
        var pos = vp.mousePosition(e);
        var elem = vp.elementFromPoint(pos.x, pos.y);

        var captureMouseForMove = true;         // default value
        valueChangedDuringTouch = false;        // default value

        if (elem === scrollThumb[0])
        {
            isMouseDown = true;
            mouseDownTime = new Date();

            //---- save mouse location relative to my the THUMB ----
            var relPos = vp.mousePosition(e, elem);
            mouseDownX = relPos.x;
            mouseDownY = relPos.y;

            // CHW: do below: vp.setCapture(document.body, e, onMouseMove, onMouseUp);

        }
        else if (elem == scrollTrack[0])
        {
            //---- did we click BEFORE or AFTER the thumb? ----
            var relPos = vp.mousePosition(e, domElement);
            var before = false;

            if (isVertical)
            {
                var y = scrollThumb.attr("y");
                before = (relPos.y <= y);
            }
            else
            {
                var x = scrollThumb.attr("x");
                before = (relPos.x <= x);
            }

            if (before)
            {
                closure.scrollTo(vp.scrollCmds.largeDecrement);
                initAutoRepeat(vp.scrollCmds.largeDecrement);
            }
            else
            {
                closure.scrollTo(vp.scrollCmds.largeIncrement);
                initAutoRepeat(vp.scrollCmds.largeIncrement);
            }
        }
        else if (elemInBox(elem, box1))
        {
            setBoxDownClass(box1);

            closure.scrollTo(vp.scrollCmds.smallDecrement);
            initAutoRepeat(vp.scrollCmds.smallDecrement);
        }
        else if (elemInBox(elem, box2))
        {
            setBoxDownClass(box2);

            closure.scrollTo(vp.scrollCmds.smallIncrement);
            initAutoRepeat(vp.scrollCmds.smallIncrement);
        }
        else
        {
            captureMouseForMove = false;

            //---- do not trigger a TOGGLE event if outside of our slider ----
            valueChangedDuringTouch = true;
        }

        if (captureMouseForMove)
        {
            // CHW: must capture mouse up even if not scrolling thumb
            vp.setCapture(document.body, e, isMouseDown ? onMouseMove : null, onMouseUp);

            vp.setFocus(domElement);
        }

        return false;
    };

    /// private.
    var elemInBox = function (elem, box)
    {
        var kids = box[0].childNodes;
        var inBox = ((elem == kids[0]) || (elem == kids[1]));

        return inBox;
    }

    /// public: scrollTo()
    closure.scrollTo = function (cmd, cmdValue)
    {
        if (cmdValue === undefined)
        {
            cmdValue = 1;
        }

        if (cmd == vp.scrollCmds.home)
        {
            setValue(min, true);
        }
        else if (cmd == vp.scrollCmds.smallIncrement)
        {
            setValue(value + (cmdValue * smallChange), true);
        }
        else if (cmd == vp.scrollCmds.smallDecrement)
        {
            setValue(value - (cmdValue * smallChange), true);
        }
        else if (cmd == vp.scrollCmds.largeIncrement)
        {
            setValue(value + (cmdValue * largeChange), true);
        }
        else if (cmd == vp.scrollCmds.largeDecrement)
        {
            setValue(value - (cmdValue * largeChange), true);
        }
        else if (cmd == vp.scrollCmds.thumbPosition)
        {
            setValue(thumbValue, true);
        }
        else if (cmd == vp.scrollCmds.end)
        {
            setValue(max, true);
        }
    };

    /// private setTrackHeight().
    var setTrackHeight = function (value)
    {
        trackHeight = value;
        scrollTrack.attr("height", value);
        svgElement.setAttribute("height", value);       // for Safari (wants width/height set on SVG doc)

        markLayoutNeeded();
    }

    /// private setTrackWidth().
    var setTrackWidth = function (value)
    {
        if (value == 0)
        {
            var breakPointDummy = 0;
        }

        trackWidth = value;
        scrollTrack.attr("width", value);
        svgElement.setAttribute("width", value);       // for Safari (wants width/height set on SVG doc)

        markLayoutNeeded();
    }

    /// private.
    var calcProportionalSize = function (viewSize)
    {
        //---- size of "buttons" on each end of scrollbar ----
        var boxSize = (isVertical) ? trackWidth : trackHeight;
        var ps = 0;

        if (!isProportional)
        {
            ps = boxSize;
        }
        else
        {
            ps = (viewSize / contentSize) * viewSize;
        }

        var maxSize = viewSize - (2 * boxSize);

        if (ps < 12)
        {
            ps = 12;
        }
        else if (ps >= maxSize)
        {
            ps = .95 * maxSize;
        }

        return ps;
    };

    //---- public: layout().
    closure.layout = function ()
    {
        //---- cancel and clear timer ----
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        //---- calc thumb size ----
        if ((trackWidth) && (trackHeight))
        {
            // CHW: adjusted thumb sizing

            if (isVertical)
            {
                thumbWidth = trackWidth - 2*thumbMargin;
                thumbHeight = calcProportionalSize(trackHeight);
            }
            else
            {
                thumbWidth = calcProportionalSize(trackWidth);
                thumbHeight = trackHeight - 2*thumbMargin;
            }

            //---- apply thumb size ----
            scrollThumb
                .width(thumbWidth)
                .height(thumbHeight);

            //---- layout rest of parts ----
            if (isVertical)
            {
                //scrollTrack
                //    .attr("x", 0);

                scrollThumb
                    .attr("x", thumbMargin);

                //box1.transform("offset(0px, 0px");

                var y2 = trackHeight - trackWidth;
                var scale = trackWidth / defaultScrollBarSize;

                setBoxTransform(box1, 0, 0, scale);
                setBoxTransform(box2, 0, y2, scale);
            }
            else
            {
                scrollTrack
                    .attr("y", 0);

                scrollThumb
                    .attr("y", thumbMargin);

                var x2 = trackWidth - trackHeight;
                var scale = trackHeight / defaultScrollBarSize;

                setBoxTransform(box1, 0, 0, scale);
                setBoxTransform(box2, x2, 0, scale);
            }
        }

        closure.update();
    };

    /// private.
    var setBoxTransform = function (box, x, y, scale)
    {
        var str = "translate(" + x + ", " + y + ") scale(" + scale + ")";        // no "px" allowed for SVG transforms
        box.transform(str);
    }

    //---- property: min ----
    closure.min = function (value)
    {
        if (value === undefined)
        {
            return min;
        }

        min = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: max ----
    closure.max = function (value)
    {
        if (value === undefined)
        {
            return max;
        }

        max = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: isProportional ----
    closure.isProportional = function (value)
    {
        if (value === undefined)
        {
            return isProportional;
        }

        isProportional = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: value ----
    closure.value = function (actualValue)
    {
        if (actualValue === undefined)
        {
            return value;
        }

        setValue(actualValue, true);
        return closure;
    };

    //---- property: smallChange ----
    closure.smallChange = function (value)
    {
        if (value === undefined)
        {
            return smallChange;
        }

        smallChange = value;
        return closure;
    };

    //---- property: largeChange ----
    closure.largeChange = function (value)
    {
        if (value === undefined)
        {
            return largeChange;
        }

        largeChange = value;
        return closure;
    };

    //---- property: contentSize ----
    /// used to calculate proportional scrollbar thumb length.
    closure.contentSize = function (value)
    {
        if (value === undefined)
        {
            return contentSize;
        }

        contentSize = value;
        markLayoutNeeded();

        return closure;
    };

    closure.getTrackWidth = function ()
    {
        return trackWidth;
    };

    closure.getTrackHeight = function ()
    {
        return trackHeight;
    };

    build();    // build now

    return domElement;

};

vp.nextScrollBarId = 1;

vp.visuals.verticalScrollBar = function ()
{
    return vp.scrollBarFactory(true);
};

vp.visuals.horizontalScrollBar = function ()
{
    return vp.scrollBarFactory(false);
};

vp.scrollCmds = { home: 0, smallIncrement: 1, largeIncrement: 2, smallDecrement: 3, largeDecrement: 4, thumpPosition: 5, end: 6 };

﻿///-----------------------------------------------------------------------------------------------------------------
/// scrollViewer.js.  Copyright (c) 2012 Microsoft Corporation.
///      - part of the vuePlot library.
///      - implements a customizable scrollViewer control.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see scrollViewer.html
///-----------------------------------------------------------------------------------------------------------------

/// create a customizable scrollbar control.
vp.scrollViewer = function ()
{
    //---- private state ----
    var hsbVisibility = vp.scrollVisiblity.visible;
    var vsbVisibility = vp.scrollVisiblity.visible;
    var domElement = null;
    var hsb = null;
    var vsb = null;
    var lowerRightBox = null;           // for when both hsb and vsb are visible

    var timer = null;
    var scrollListeners = [];
    var content = null;
    var root = null;
    var preContentCount = 0;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        var hsbVis = false;
        var vsbVis = false;

        var width = root.width();
        var height = root.height();

        if (domElement.childNodes.length > preContentCount)
        {
            var newContent = vp.select(domElement.childNodes[preContentCount]);

            if (!compareWrapperContent(content, newContent))
            {
                //---- content changed ----
                if (content)
                {
                    //---- detach our event handler on previous content ----
                    vp.detach(content, "resize", markLayoutNeeded);
                }

                content = newContent;

                if (content)
                {
                    //---- attach new event handler ----
                    content.attach("resize", markLayoutNeeded);

                    //---- set position to "absolute" to prevent the content from changing our size ----
                    content.css("position", "absolute");
                    content.css("zIndex", "1");
                }
            }
        }

        var contentHeight = (content) ? content.totalHeight() : 0;
        var contentWidth = (content) ? content.totalWidth() : 0;

        if (hsbVisibility == vp.scrollVisiblity.visible)
        {
            hsbVis = true;
        }
        else if (hsbVisibility == vp.scrollVisiblity.auto)
        {
            hsbVis = ((content) && (contentWidth > width));
        }

        if (vsbVisibility == vp.scrollVisiblity.visible)
        {
            vsbVis = true;
        }
        else if (vsbVisibility == vp.scrollVisiblity.auto)
        {
            vsbVis = ((content) && (contentHeight > height));
        }

        hsb.show(hsbVis);
        vsb.show(vsbVis);

        // CHW: move layout later and make sure bounds height and width don't go to 0
        // When hsb or vsb is invisible, the only change below is in the ?sbVis???? 
        // variables which simply determines the length of the scroll bar.  

        var hsbTrackHeight = hsb.getTrackHeight();
        var hsbVisHeight = (hsbVis) ? hsbTrackHeight : 0;
        var vsbTrackWidth = vsb.getTrackWidth();
        var vsbVisWidth = (vsbVis) ? vsbTrackWidth : 0;

        //---- layout hsb ----
        var hsbWidth = width - vsbVisWidth;

        //---- why does content show thru on last row? ----
        //---- it appears the HSB is being drawn on 1/2 pixel boundaries, so it only shades the last row (not covers) ----
        hsb.bounds(0, height - hsbTrackHeight, hsbWidth, hsbTrackHeight);

        var max = (content) ? contentWidth - hsbWidth + 1 : 0;
        max = Math.max(0, max);

        var pageSizeH = Math.round(.9 * hsbWidth);
        var lineSizeH = Math.round(pageSizeH / 15);

        hsb
            .min(0)
            .max(max)
            .smallChange(lineSizeH)
            .largeChange(pageSizeH);

        hsb.contentSize(contentWidth);

        hsb.layout();      // update layout; this will reset the scroll value based on the new content size

        //---- layout vsb ----
        var vsbHeight = height - hsbVisHeight;

        vsb.bounds(width - vsbTrackWidth, 0, vsbTrackWidth, vsbHeight);

        var max = (content) ? contentHeight - vsbHeight + 1 : 0;
        max = Math.max(0, max);

        var pageSize = Math.round(.9 * vsbHeight);
        var lineSize = Math.round(pageSize / 15);

        vsb
            .min(0)
            .max(max)
            .smallChange(lineSize)
            .largeChange(pageSize);

        vsb.contentSize(contentHeight);

        vsb.layout();      // update layout; this will reset the scroll value based on the new content size

        applyScrolling({ target: vsb });        // TODO: the new code only calls applyScrolling once; what should the target be?

        if ((hsbVis) && (vsbVis))
        {
            lowerRightBox
                .bounds(width - vsbVisWidth, height - hsbVisHeight, vsbVisWidth, hsbVisHeight)
                .show();
        }
        else
        {
            lowerRightBox
                .hide();
        }
    };

    layout.ctr = "vp.visuals.scrollViewer";

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "hsb");
        vp.makeControlProperty(wrapper, "vsb");
        vp.makeControlProperty(wrapper, "min");
        vp.makeControlProperty(wrapper, "max");
        vp.makeControlProperty(wrapper, "value");
        vp.makeControlProperty(wrapper, "smallChange");
        vp.makeControlProperty(wrapper, "largeChange");
        vp.makeControlProperty(wrapper, "hsbVisibility");
        vp.makeControlProperty(wrapper, "vsbVisibility");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
    };

    /// private.
    var compareWrapperContent = function (ss1, ss2)
    {
        var e1 = (ss1 != null) ? ss1[0] : null;
        var e2 = (ss2 != null) ? ss2[0] : null;

        return (e1 == e2);
    };

    /// private.
    var applyScrolling = function (e)
    {
        if (content)
        {
            var xOffset = -hsb.value();
            var yOffset = -vsb.value();

            //content.css("left", xOffset);
            //content.css("top", yOffset);

            //---- using a SPAN around text - need to add topBorder offset (not calculated correctly by browser layout) ----
            //var cs = window.getComputedStyle(content[0]);
            //var bs = parseFloat(cs["borderTopWidth"]);
            //yOffset += bs;

            var offset = "translate(" + xOffset + "px, " + yOffset + "px)";

            content.transform(offset);
        }

        onScroll(e);
    };

    //---- private: build() ----
    var build = function ()
    {
        if (!domElement)
        {
            domElement = vp.createHtml("div");

            //---- add a property on element to get access to control (closure object) ----
            domElement.control = layout;

            root = vp.select(domElement)
                //.css("zIndex", -2)     // setting this to -2 breaks elementFromPoint() on Chrome
                .css("position", "relative")
                .css("overflow", "hidden")
                .setClass("scrollViewer")
                .attach("resize", markLayoutNeeded);
        }
        else
        {
            root.clear();
        }

        //---- add a background IMG so that can catch all mouse wheel events ----
        root
            .append("img")
            //.attr("src", "/images/SmallWhiteRect.png")   // don't tie to images dir
            .css("visibility", "hidden")    // will still receive events
            //.css("background", "purple")     // debug
            .css("position", "absolute")
            .css("zIndex", "-3")
            .width("100%")
            .height("100%")
            .attach("mousewheel", function (e)
            {
                if (vsb)
                {
                    vsb.processMouseWheelEvent(e);
                }
            });
        preContentCount++;

        vp.attach(domElement, "mousewheel", function (e)
        {
            if (vsb)
            {
                vsb.processMouseWheelEvent(e);
            }
        });

        // CHW: add isProportional(true)

        //---- add HORIZONTAL SB ----
        hsb = root.append(vp.visuals.horizontalScrollBar())
          .id("horizontalScrollBar")
          .css("zIndex", 2)
          .css("position", "absolute")
          .attach("change", applyScrolling)
          .isProportional(true);

        //---- add VERTICAL SB ----
        vsb = root.append(vp.visuals.verticalScrollBar())
            .id("verticalScrollBar")
            .css("zIndex", 2)
            .css("position", "absolute")
            .attach("change", applyScrolling)
            .isProportional(true);

        //---- add lower/right box to hide content underneath where scrollbars stop ----
        lowerRightBox = root.append("div")
            .setClass("scrollLowerRightBox")
            .css("zIndex", 2)
            .css("position", "absolute");

        preContentCount += 3;

        root.attach("DOMNodeInserted", function (e)
        {
            markLayoutNeeded();
        });
    };

    /// pubilc: element().
    layout.element = function ()
    {
        return domElement;
    };

    /// pubilc: hsb()
    layout.hsb = function ()
    {
        return hsb;
    };

    /// pubilc: vsb().
    layout.vsb = function ()
    {
        return vsb;
    };

    /// private: markLayoutNeeded().
    var markLayoutNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(layout, 1);
        }
    };

    /// private: onScroll().
    var onScroll = function (e)
    {
        //---- create a simplified event object ----
        for (var i = 0; i < scrollListeners.length; i++)
        {
            var callback = scrollListeners[i];

            callback(e);
        }
    };

    //---- function: attach() ----
    layout.attach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "scroll")
        {
            scrollListeners.push(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global attach function
            vp.attach(domElement, eventName, callback);
        }

        return this;
    };

    //---- function: detach() ----
    layout.detach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "scroll")
        {
            scrollListeners.remove(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global deattach function
            vp.detach(domElement, eventName, callback);
        }

        return this;
    };

    //---- private: onSizesChanged().
    var onSizesChanged = function ()
    {
        markLayoutNeeded();
    };

    //---- property: hsbVisibility ----
    layout.hsbVisibility = function (value)
    {
        if (value === undefined)
        {
            return hsbVisibility;
        }

        hsbVisibility = value;
        onSizesChanged();
        markLayoutNeeded();

        return this;
    };

    //---- property: vsbVisibility ----
    layout.vsbVisibility = function (value)
    {
        if (value === undefined)
        {
            return vsbVisibility;
        }

        vsbVisibility = value;
        markLayoutNeeded();
        onSizesChanged();

        return this;
    };

    //---- init code ----
    build();    // build now

    return domElement;

};

vp.scrollVisiblity = { hidden: 0, visible: 1, auto: 2 };
﻿///-----------------------------------------------------------------------------------------------------------------
/// slider.js.  Copyright (c) 2012 Microsoft Corporation.
///             Part of the vuePlot library - a slider control.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see slider.html
///-----------------------------------------------------------------------------------------------------------------

/// create a slider control and return a closure object for it.  The slider slides between min and max values, by increment.
vp.sliderFactory = function (isVertical)
{
    //---- private state ----
    var min = 0;
    var max = 100;
    var increment = 1;
    var value = 0;
    var domElement = null;
    var sliderTrack = null;
    var sliderThumb = null;

    var changeListeners = [];
    var toggleListeners = [];
    var mouseDownX = 0;
    var mouseDownY = 0;
    var isMovingThumb = false;
    var isMouseDown = false;
    var mouseDownTime = 0;
    var lastMouseDoc = { x: 0, y: 0 };
    var movedByUser = false;
    var valueChangedDuringTouch = null;
    var trackHeight = 0;
    var trackWidth = 0;
    var thumbWidth = 0;
    var thumbHeight = 0;
    var timer = null;
    var changingSizes = false;
    var isEnabled = true;

    //---- closure: update() ----
    var update = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        setValue(value, true);
    };

    update.ctr = "vp.visuals.slider";

    //---- private: build() ----
    var build = function ()
    {
        if (!domElement)
        {
            domElement = vp.createSvg("svg");

            //---- add a property on element to get access to control (closure object) ----
            domElement.control = update;

            vp.attach(domElement, "resize", onBoundariesChanged);
         }

        /// Note: non-IE browsers don't like SVG elements that go outside the boundaries of the SVG document
        /// (they get chopped off), so make sure we layout everything WITHIN the {0, 0, width, height} bounds.
        value = min;

        var root = vp.select(domElement)
            .clear();

        sliderTrack = root.append("rect")
            .addClass("sliderTrack")
            .id("sliderTrack")
            .bounds(0, 0, 50, 4)
            .attr("rx", 3)
            .attr("ry", 3);

        sliderThumb = root.append("rect")
            .addClass("sliderThumb")
            .id("sliderThumb")
            .bounds(0, 0, 8, 16)
            .attr("rx", 2)
            .attr("ry", 2);

        if (isVertical)
        {
            setThumbSize(16, 8);
            setTrackHeight(50);
            setTrackWidth(4);
        }
        else
        {
            setThumbSize(8, 16);
            setTrackHeight(4);
        }

        //---- event strategy: hook mouseenter/exit to know when to enable the "mousedown" event handler, using
        //---- the "capture" flag of event listener to get priority access (during capture phase) to event.  ----
        root.attach("mouseover", function (e)
        {
            if (isEnabled)
            {
                root.attach("mousedown", onMouseDown, true);
            }
        });

        root.attach("mouseout", function (e)
        {
            if (isEnabled)
            {
                root.detach("mousedown", onMouseDown, true);
            }
        });


        //---- use "touch" instead of "mouse" events (works better across devices) ----
        //---- in order to approximate "capture" behavior, we hook the document & ensure mousedown is on sliderThumb ----

        //vp.touchEventHandler(document.body, onMouseDown, onMouseMove, onMouseUp);
        //vp.touchEventHandler(domElement, onMouseDown, null, null);
    };

    update.element = function ()
    {
        return domElement;
    };

    update.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "sliderThumb");
        vp.makeControlProperty(wrapper, "sliderTrack");
        vp.makeControlProperty(wrapper, "min");
        vp.makeControlProperty(wrapper, "max");
        vp.makeControlProperty(wrapper, "value");
        vp.makeControlProperty(wrapper, "increment");
        vp.makeControlProperty(wrapper, "trackWidth");
        vp.makeControlProperty(wrapper, "trackHeight");
        vp.makeControlProperty(wrapper, "thumbWidth");
        vp.makeControlProperty(wrapper, "thumbHeight");
        vp.makeControlProperty(wrapper, "isEnabled");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
    };

    update.sliderThumb = function ()
    {
        return sliderThumb;
    };

    update.sliderTrack = function ()
    {
        return sliderTrack;
    };

    /// private: setValue().
    var setValue = function (newValue, force)
    {
        //---- round value to nearest increment ----
        if (increment)
        {
            newValue = increment * Math.round(newValue / increment);
        }

        //---- adjust value so its within limits ----
        if (newValue < min)
        {
            newValue = min;
        }
        else if (newValue > max)
        {
            newValue = max;
        }

        if ((force) || (newValue != value))
        {
            vp.debug("sliderValue=" + newValue);

            value = newValue;

            if (force)
            {
                if (isVertical)
                {
                    var top = 0;
                    var trackHeight = sliderTrack.height();
                    var bottom = trackHeight - thumbHeight;

                    var yValue = vp.mapValue(value, min, max, top, bottom);

                    //---- move thumb ----
                    sliderThumb.attr("y", yValue);
                }
                else
                {
                    var left = 0;
                    var trackWidth = sliderTrack.width();
                    var right = trackWidth - thumbWidth;

                    var xValue = vp.mapValue(value, min, max, left, right);

                    //---- move thumb ----
                    sliderThumb.attr("x", xValue);
                }
            }

            //---- call event listeners ----
            onChange();
        }
    };

    /// private: markUpdateNeeded().
    var markUpdateNeeded = function ()
    {
        if (timer == null)
        {
            setTimeout(update, 1);
        }
    };

    /// private: onChange().
    var onChange = function ()
    {
        //---- create a simplified event object ----
        var evt = { src: update, value: value };

        for (var i = 0; i < changeListeners.length; i++)
        {
            var callback = changeListeners[i];

            callback(evt);
        }
    };

    /// private: onToggle().
    var onToggle = function ()
    {
        //---- create a simplified event object ----
        var evt = { src: update, value: value };

        for (var i = 0; i < toggleListeners.length; i++)
        {
            var callback = toggleListeners[i];

            callback(evt);
        }
    };

    //---- function: attach() ----
    update.attach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.push(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.push(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global attach function
            vp.attach(domElement, eventName, callback);
        }

        return update;
    };

    //---- function: detach() ----
    update.detach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.remove(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.remove(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global deattach function
            vp.detach(domElement, eventName, callback);
        }

        return update;
    };


    /// private: onMouseMove().
    var onMouseMove = function (e)
    {
        //vp.debug("vpslider.onMouseMove: e.type=" + e.type);
        //vp.debug("onMouseMove: isMouseDown=" + isMouseDown);

        var mouseDoc = vp.mousePosition(e);

        if (isMouseDown)
        {
            if (!isMovingThumb)
            {
                //---- have we gone far enough or waited long enough? ----
                var delta = new Date() - mouseDownTime;
                if (delta > 100)
                {
                    isMovingThumb = true;
                }
                else
                {
                    var xdiff = Math.abs(mouseDoc.x - lastMouseDoc.x);
                    var ydiff = Math.abs(mouseDoc.y - lastMouseDoc.y);

                    if ((xdiff >= 4) || (ydiff >= 4))
                    {
                        isMovingThumb = true;
                    }
                }
            }

            if (isMovingThumb)
            {
                movedByUser = true;
                valueChangedDuringTouch = true;

                //---- goal is to set new X location for THUMB (relative to our local svg document) ----
                //---- "doc" variables here refer to coordinates relative to main document origin ----
                //---- "svg" variables here refer to coordinates relative to local svg document ----

                //---- compute mouse location relative to my svg document ----
                var newValue = 0;

                if (isVertical)
                {
                    var mouseYDoc = mouseDoc.y;

                    var newYDoc = mouseYDoc - mouseDownY;
                    var newYSvg = newYDoc - vp.docOffset(sliderTrack[0]).top;

                    var topSvg = 0;
                    var trackHeighth = sliderTrack.height();
                    var bottomSvg = topSvg + trackHeight - thumbHeight;

                    if (newYSvg < topSvg)
                    {
                        newYSvg = topSvg;
                    }
                    else if (newYSvg > bottomSvg)
                    {
                        newYSvg = bottomSvg;
                    }

                    //---- move thumb ----
                    sliderThumb.attr("y", newYSvg);

                    newValue = vp.mapValue(newYSvg, topSvg, bottomSvg, min, max);
                }
                else
                {
                    var mouseXDoc = mouseDoc.x;

                    var newXDoc = mouseXDoc - mouseDownX;
                    var newXSvg = newXDoc - vp.docOffset(sliderTrack[0]).left;

                    var leftSvg = 0;
                    var trackWidth = sliderTrack.width();
                    var rightSvg = leftSvg + trackWidth - thumbWidth;

                    if (newXSvg < leftSvg)
                    {
                        newXSvg = leftSvg;
                    }
                    else if (newXSvg > rightSvg)
                    {
                        newXSvg = rightSvg;
                    }

                    //---- move thumb ----
                    sliderThumb.attr("x", newXSvg);

                    newValue = vp.mapValue(newXSvg, leftSvg, rightSvg, min, max);
                }

                setValue(newValue, false);

                //                e.cancelBubble = true;
                //                e.stopPropagation();
                //                e.returnValue = false;

            }
        }

        lastMouseDoc = mouseDoc;
    };

    /// private: onMouseUp().
    var onMouseUp = function (e)
    {
        isMovingThumb = false;
        isMouseDown = false;

        vp.releaseCapture(document.body, e, onMouseMove, onMouseUp);

        if (valueChangedDuringTouch === false)
        {
            //---- trigger the TOGGLE event ----
            onToggle();
        }
    };

    /// private: onMouseDown().
    var onMouseDown = function (e)
    {
        var pos = vp.mousePosition(e);
        var elem = vp.elementFromPoint(pos.x, pos.y);
        var captureMouseForMove = false;

        if (elem === sliderThumb[0])
        {
            isMouseDown = true;
            mouseDownTime = new Date();

            vp.debug("onMouseDown: isMouseDown=" + isMouseDown);

            //---- compute mouse location relative to my the THUMB ----
            var thumbXRelToDoc = vp.docOffset(elem).left;
            var thumbYRelToDoc = vp.docOffset(elem).top;

            var mouseXRelToDoc = vp.mousePosition(e).x;
            var mouseYRelToDoc = vp.mousePosition(e).y;

            mouseDownX = mouseXRelToDoc - thumbXRelToDoc;
            mouseDownY = mouseYRelToDoc - thumbYRelToDoc;

            valueChangedDuringTouch = false;

            vp.setCapture(document.body, e, onMouseMove, onMouseUp);
        }
        else if (elem == sliderTrack)
        {
            valueChangedDuringTouch = false;
        }
        else
        {
            //---- do not trigger a TOGGLE event if outside of our slider ----
            valueChangedDuringTouch = true;
        }

        return false;
    };

    /// private: setThumbSize().
    var setThumbSize = function (width, height)
    {
        thumbWidth = width;
        thumbHeight = height;

        sliderThumb
            .width(width)
            .height(height);

        onSizesChanged();
    };

    /// private setTrackHeight().
    var setTrackHeight = function (value)
    {
        trackHeight = value;
        sliderTrack.attr("height", value);
        domElement.setAttribute("height", value + 4);       // for Safari (wants width/height)

        onSizesChanged();
    }

    /// private setTrackWidth().
    var setTrackWidth = function (value)
    {
        trackWidth = value;
        sliderTrack.attr("width", value);
        domElement.setAttribute("width", value + 4);       // for Safari (wants width/height)

        onSizesChanged();
    }

    var onBoundariesChanged = function ()
    {
        if (!changingSizes)
        {
            if (isVertical)
            {
                var height = vp.height(domElement);
                setTrackHeight(height);
            }
            else
            {
                var width = vp.width(domElement);
                setTrackWidth(width);
            }
        }
    };

    //---- private: onSizesChanged().
    var onSizesChanged = function ()
    {
        changingSizes = true;

        if (isVertical)
        {
            sliderTrack
                .attr("x", thumbWidth / 2 - trackWidth / 2);

            sliderThumb
                .attr("x", 0);
        }
        else
        {
            sliderTrack
                .attr("y", thumbHeight / 2 - trackHeight / 2);

            sliderThumb
                .attr("y", 0);
        }

        if (isVertical)
        {
            var w = Math.max(trackWidth, thumbWidth);

            //---- add +1 to avoid truncation due to pixel misalignment ----
            vp.width(domElement, w + 1);
            vp.height(domElement, trackHeight + 1);
        }
        else
        {
            var h = Math.max(trackHeight, thumbHeight);

            //---- add +1 to avoid truncation due to pixel misalignment ----
            vp.width(domElement, trackWidth + 1);
            vp.height(domElement, h + 1);
        }

        changingSizes = false;
    };

    //---- property: min ----
    update.min = function (value)
    {
        if (value === undefined)
        {
            return min;
        }

        min = value;
        markUpdateNeeded();
        return update;
    };

    //---- property: max ----
    update.max = function (value)
    {
        if (value === undefined)
        {
            return max;
        }

        max = value;
        markUpdateNeeded();
        return update;
    };

    //---- property: value ----
    update.value = function (actualValue)
    {
        if (actualValue === undefined)
        {
            return value;
        }

        //value = actualValue;
        //markUpdateNeeded();
        setValue(actualValue, true);
        return update;
    };

    //---- property: increment ----
    update.increment = function (value)
    {
        if (value === undefined)
        {
            return increment;
        }

        increment = value;
        markUpdateNeeded();
        return update;
    };

    //---- property: isEnabled ----
    update.isEnabled = function (value)
    {
        if (value === undefined)
        {
            return isEnabled;
        }

        isEnabled = value;

        if (isEnabled)
        {
            domElement.style.opacity = 1;
        }
        else
        {
            domElement.style.opacity = .5;
        }

        markUpdateNeeded();
        return update;
    };

    //---- property: trackHeight ----
    update.trackHeight = function (value)
    {
        if (value === undefined)
        {
            return trackHeight;
        }

        setTrackHeight(value);
        return update;
    };

    //---- property: trackWidth ----
    update.trackWidth = function (value)
    {
        if (value === undefined)
        {
            return trackWidth;
        }

        setTrackWidth(value);
        return update;
    };


    //---- property: thumbWidth ----
    update.thumbWidth = function (value)
    {
        if (value === undefined)
        {
            return thumbWidth;
        }

        setThumbSize(value, thumbHeight);
        return update;
    };

    //---- property: thumbHeight ----
    update.thumbHeight = function (value)
    {
        if (value === undefined)
        {
            return thumbHeight;
        }

        setThumbSize(thumbWidth, value);
        return update;
    };

    build();    // build now

    return domElement;

};


vp.visuals.verticalSlider = function ()
{
    return vp.sliderFactory(true);
};

vp.visuals.horizontalSlider = function ()
{
    return vp.sliderFactory(false);
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// visUtils.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements various 
///    visual utility functions.
///-----------------------------------------------------------------------------------------------------------------

vp.makeControlProperty = function (wrapper, propName)
{
    var propFunc = function (value)
    {
        //---- GET value ----
        if (arguments.length == 0)
        {
            var value = null;
            if (wrapper.length > 0)
            {
                var f = wrapper[0].control[propName];
                value = f.call();
            }

            return value;
        }
        else
        {
            //---- SET value ----
            var origValue = value;

            return wrapper.each(function (index, element)
            {
                //if (vp.isFunction(origValue))
                //{
                //    value = origValue(index, element);
                //}

                //---- control stored on actual element, not wrapper ----
                var f = element[0].control[propName];
                f.call(null, value);
            });
        }
    };

    wrapper[propName] = propFunc;
};

vp.makeControlFunc = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;

        return wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            f.apply(control, args);
        });
    };

    wrapper[funcName] = func;
};

vp.makeControlFuncWithReturnValue = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;
        var returnValue = undefined;

        wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            returnValue = f.apply(control, args);
        });

        return returnValue;
    };

    wrapper[funcName] = func;
};
///-----------------------------------------------------------------------------------------------------------------
/// baseLayer.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - the base class for a plotLayer object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  the base class for a plotLayer object. "T" is the outer layer class. */
        var baseLayerClass = (function () {
            function baseLayerClass() {
                /** public field that gives the name of the class */
                this.ctr = "vp.layers.baseLayerClass";
                /** public field that provides information about drawShapes caller */
                this.info = {};
                //---- private state ----
                //---- todo: combine these 3 properties + KEY so we don't have so much duplication ----
                this._data = undefined;
                this._dataAnimMgr = undefined;
                this._newTagOrFunc = undefined;
                this._data2 = undefined;
                this._dataAnimMgr2 = undefined;
                this._newTagOrFunc2 = undefined;
                //_xAxisInfo = vp.vvAxisInfo();
                //_yAxisInfo = vp.vvAxisInfo();
                //_zAxisInfo = vp.vvAxisInfo();
                //---- for ease of access ----
                this._xAttr = null;
                this._yAttr = null;
                this._xDefaults = null;
                this._yDefaults = null;
                this._plotDefaults = new vp.layers.plotDefaults();
                this._filter = undefined;
                //_mappings = undefined;       // common mapped properties
                this._attributes = undefined;
                //_attributes: any = {};         // properties bound to constants/mappings
                /* should be a function of the form: formatValue(value, colName, seriesIndex). **/
                this._toolTipFormatter = null;
                this._container = undefined;
                this._defaultStackType = "identity";
                this._vvParent = undefined;
                this._stat = undefined;
                this._layerType = undefined;
                //_seriesPalette = undefined;
                this._postCreateFunc = null;
                //---- should these properties be in vvMappings instead? ----
                this._toolTipCols = true;
                this._isAnimEnabled = true;
                this._key = undefined;
                this._key2 = undefined;
                this._chartName = undefined;
                this._xColAfterStat = undefined;
                this._yColsAfterStat = undefined;
                this._xCol2AfterStat = undefined;
                this._yCols2AfterStat = undefined;
                this._layerId = vp.nextLayerId++;
                //---- are drawing attributes currently mapped? ----
                this._isStrokeMapped = false;
                this._isFillMapped = false;
                this._isOpacityMapped = false;
                this._isLineTypeMapped = false;
                this._isShapeTypeMapped = false;
                this._isShapeSizeMapped = false;
                this._isLineSizeMapped = false;
                this._isTextSizeMapped = false;
                this._isTextFillMapped = false;
                this._isTextLabelMapped = false;
                this._attributes = vp.layers.createMappings().vvParent(this);

                //---- make the constant setter function chainable with the layer object ----
                this._attributes.setterReturnValue(this);

                //---- set up ease-of-access variables ----
                this._xAttr = this._attributes._x;
                this._yAttr = this._attributes._y;
                this._xDefaults = this._xAttr.layerDefaults;
                this._yDefaults = this._yAttr.layerDefaults;

                for (var i = 0; i < baseLayerClass.commonProperties.length; i++) {
                    var propName = baseLayerClass.commonProperties[i];
                    var func = this._attributes[propName];

                    if (func === undefined) {
                        var dummy = 9;
                    }

                    this[propName] = vp.cb(this._attributes, func);
                }
                ////---- initial value of this._seriesPalette comes from theme ----
                //var theme = vp.themeMgr.theme();
                //this._seriesPalette = theme.fillPalette();
            }
            /// for typescript compile, make this explicit for X and Y.
            baseLayerClass.prototype.x = function () {
                return this._attributes._x;
            };

            /// for typescript compile, make this explicit for X and Y.
            baseLayerClass.prototype.y = function () {
                return this._attributes._y;
            };

            //---- define in base class for consistent signature among subclasses ----
            baseLayerClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = [];
                return shapes;
            };

            baseLayerClass.prototype.prepScaleIfNeeded = function (attrs, seriesNames, attrName) {
                var attr = this._attributes["_" + attrName];
                if (attr) {
                    //---- always do X and Y (for implicit category charts); only do other attributes if user has mapped a column to them ----
                    if ((attrName == "x") || (attrName == "y") || (attr.isMapped())) {
                        this.prepAttrScaleIfNeeded(attr, seriesNames);
                        attrs.push(attr);
                    }
                }
            };

            baseLayerClass.prototype.prepAttrScaleIfNeeded = function (attr, seriesNames) {
                if (attr.needsSetUp()) {
                    var attrName = attr._attrName;
                    if (attrName.startsWith("_")) {
                        attrName = attrName.substr(1);
                    }

                    layerName = this._layerType;
                    var layerName = "layer" + layerName.substr(0, 1).toUpperCase() + layerName.substr(1);

                    var da = vp.currentTheme().getDrawingAttributes(layerName, 0);
                    var daPropName = (attrName == "fill" || attrName == "stroke") ? (attrName + "Palette") : attrName;
                    var daAttr = da[daPropName];

                    var afterPropName = null;

                    if ((attrName == "x") && (this.info.xRecords.length)) {
                        afterPropName = this.info.xRecords[0].name;
                    } else if ((attrName == "y") && (this.info.yRecords.length)) {
                        afterPropName = this.info.yRecords[0].name;
                    }

                    attr.setupScale(this.info.filteredData, seriesNames, daAttr, this.info.stackType, afterPropName);
                }
            };

            baseLayerClass.prototype.getActiveAttributes = function () {
                var attrs = [];
                var myData = this.data();

                if ((myData) && (myData.length > 0)) {
                    var seriesNames = this.info.seriesNames;

                    this.prepScaleIfNeeded(attrs, seriesNames, "x");
                    this.prepScaleIfNeeded(attrs, seriesNames, "y");
                    this.prepScaleIfNeeded(attrs, seriesNames, "stroke");
                    this.prepScaleIfNeeded(attrs, seriesNames, "fill");
                    this.prepScaleIfNeeded(attrs, seriesNames, "opacity");
                    this.prepScaleIfNeeded(attrs, seriesNames, "lineSize");
                    this.prepScaleIfNeeded(attrs, seriesNames, "lineType");
                    this.prepScaleIfNeeded(attrs, seriesNames, "shapeType");
                    this.prepScaleIfNeeded(attrs, seriesNames, "text");
                }

                return attrs;
            };

            /// chart is being rebuilt, so scales will have to be re-setup.
            baseLayerClass.prototype.onChartRebuild = function () {
                //---- don't trigger a JIT create, if not yet defined ----
                var attr = this._attributes;

                if (attr._x) {
                    attr._x.needsSetUp(true);
                }

                if (attr._y) {
                    attr._y.needsSetUp(true);
                }

                if (attr._fill) {
                    attr._fill.needsSetUp(true);
                }

                if (attr._stroke) {
                    attr._stroke.needsSetUp(true);
                }

                if (attr._opacity) {
                    attr._opacity.needsSetUp(true);
                }

                if (attr._lineSize) {
                    attr._lineSize.needsSetUp(true);
                }

                if (attr._shapeType) {
                    attr._shapeType.needsSetUp(true);
                }

                if (attr._lineType) {
                    attr._lineType.needsSetUp(true);
                }

                if (attr._textSize) {
                    attr._textSize.needsSetUp(true);
                }

                if (attr._textFill) {
                    attr._textFill.needsSetUp(true);
                }

                if (attr._label) {
                    attr._label.needsSetUp(true);
                }
            };

            baseLayerClass.prototype.toolTipFormatter = function (value) {
                if (arguments.length == 0) {
                    return this._toolTipFormatter;
                }

                this._toolTipFormatter = value;

                return this;
            };

            baseLayerClass.prototype.vvParent = function (value) {
                if (arguments.length == 0) {
                    return this._vvParent;
                }

                this._vvParent = value;
                this.markRebuildNeeded();

                return this;
            };

            ///// public property: xAxisInfo
            //xAxisInfo(): any;
            //xAxisInfo(value?: any): T;
            //xAxisInfo(value?: any): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._xAxisInfo;
            //    }
            //    this._xAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ///// public property: yAxisInfo
            //yAxisInfo(): any;
            //yAxisInfo(value?: any): T;
            //yAxisInfo(value?: any): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._yAxisInfo;
            //    }
            //    this._yAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ///// public property: zAxisInfo
            //zAxisInfo(): any;
            //zAxisInfo(value?: any): T;
            //zAxisInfo(value?: any): any        {
            //    if (arguments.length == 0)
            //    {
            //        return this._zAxisInfo;
            //    }
            //    this._zAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            baseLayerClass.prototype.onKeyChanged = function () {
                if (this._dataAnimMgr) {
                    //---- pass on new key value to dataAnimMgr ----
                    this.bindProperties();

                    var key = this._attributes._key;
                    this._dataAnimMgr.keyFunc(key);
                }
            };

            baseLayerClass.prototype.onKey2Changed = function () {
                if (this._dataAnimMgr2) {
                    this.bindProperties();

                    //---- pass on new key value to dataAnimMgr2 ----
                    var key2 = this._attributes._key2;
                    this._dataAnimMgr2.keyFunc(key2);
                }
            };

            baseLayerClass.prototype.layerType = function (value) {
                if (arguments.length == 0) {
                    return this._layerType;
                }

                this._layerType = value;
                this.ctr = "vp.layers." + value;

                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.stat = function (value) {
                if (arguments.length == 0) {
                    return this._stat;
                }

                this._stat = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.statType = function (value) {
                return (this._stat) ? this._stat.statType : undefined;
            };

            baseLayerClass.prototype.toolTipCols = function (value) {
                if (arguments.length == 0) {
                    value = this._toolTipCols;
                    return value;
                }

                this._toolTipCols = value;

                //this.markRebuildNeeded();
                return this;
            };

            baseLayerClass.prototype.getItemStroke = function (seriesIndex, itemIndex, filteredData, daStroke) {
                var binding = this._attributes._stroke;

                if (binding) {
                    this._isStrokeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, daStroke, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getItemFill = function (seriesIndex, itemIndex, filteredData, daFill) {
                var attr = this._attributes._fill;

                if (attr) {
                    this._isFillMapped = attr.isMapped();

                    return attr.getItemValue(seriesIndex, itemIndex, filteredData, daFill, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.formatValue = function (value, colName, seriesIndex) {
                var formatter = this._toolTipFormatter;
                if (!formatter) {
                    formatter = this.defaultFormatValue;
                }

                var newValue = formatter.call(this, value, colName, seriesIndex);
                return newValue;
            };

            baseLayerClass.prototype.defaultFormatValue = function (value, colName, seriesIndex) {
                var xColList = this.xAfterStat();
                var yColList = this.yAfterStat();

                var isDiscrete = null;
                var options = this.info.options;

                if (xColList.indexOf(colName) > -1) {
                    isDiscrete = this._attributes._x.layerDefaults.isDiscrete;
                } else if (yColList.indexOf(colName) > -1) {
                    isDiscrete = this._attributes._y.layerDefaults.isDiscrete;
                }

                if (isDiscrete) {
                    value = vp.formatters.string(value);
                } else {
                    value = vp.format(value);
                }

                //---- use formatter from attribute ----
                var newValue = null;

                var attr = this["_" + colName];
                if (attr) {
                    var formatter = attr.getActualFormatter();
                    newValue = formatter(value);
                } else {
                    newValue = vp.format(value);
                }

                return newValue;
            };

            /** subclass should implement this, if needed */
            baseLayerClass.prototype.adjustChartOptions = function () {
            };

            /// use the "hAlign" and "vAlign" property values to calculate the x/y adjustment
            /// needed for the text. requires the text element with the final text applied to it
            /// (and it should be attached to the document) so that it can be correctly measured.
            ///
            /// return the adjustment as a {x, y} object.
            baseLayerClass.prototype.calculateTextAdjust = function (textElem, hAlign, vAlign) {
                return vp.calculateTextAdjust(textElem, hAlign, vAlign);
            };

            baseLayerClass.prototype.getItemOpacity = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._opacity;

                if (binding) {
                    this._isOpacityMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isOpacityMapped = false;
                ////---- start with constant value ----
                //var opacity = this._attributes.opacity.value;
                //if (opacity === undefined)
                //{
                //    //opacity = 1;
                //}
                //else if ((!this._attributes.opacity.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isOpacityMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this._attributes.opacity.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._opacityScale.needsSetUp())
                //    {
                //        var data = vp.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._opacityScale.setUp(min, max);
                //    }
                //    opacity = this._opacityScale.scale(propValue);       // get opacity from this._opacityScale mapping
                //}
                //return opacity;
            };

            baseLayerClass.prototype.getSizeCore = function (seriesIndex, itemIndex, filteredData, da, sizeName) {
                var binding;
                binding = (sizeName == "shapeSize") ? this._attributes._shapeSize : this._attributes._lineSize;

                if (binding) {
                    if (sizeName == "lineSize") {
                        this._isLineSizeMapped = binding.isMapped();
                    } else if (sizeName == "shapeSize") {
                        this._isShapeSizeMapped = binding.isMapped();
                    } else {
                        this._isLineSizeMapped = binding.isMapped();
                    }

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getTextSize = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._textSize;

                if (binding) {
                    this._isTextSizeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getTextFill = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._textFill;

                if (binding) {
                    this._isTextFillMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getItemLabel = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._label;

                if (binding) {
                    this._isTextLabelMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isTextLabelMapped = false;
                //var bind = this._attributes.label;
                //var value = bind.value;
                //if (value === undefined)
                //{
                //    //value = "";
                //}
                //else if ((!bind.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isTextLabelMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this._attributes.label.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._textScale.needsSetUp())
                //    {
                //        var data = vp.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._textScale.setUp(min, max);
                //    }
                //    value = this._textScale.scale(propValue);
                //}
                //return value;
            };

            /// return object that owns this element
            baseLayerClass.prototype.pop = function () {
                return this._vvParent;
            };

            baseLayerClass.prototype.getLineType = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._lineType;

                if (binding) {
                    this._isLineTypeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isLineTypeMapped = false;
                //var value = this._attributes.lineType.value;
                //if (value === undefined)
                //{
                //    //value = "solid";       // default value
                //}
                //else if ((!this._attributes.lineType.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isLineTypeMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this._attributes.lineType.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._lineTypeScale.needsSetUp())
                //    {
                //        var data = vp.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._lineTypeScale.setUp(min, max);
                //    }
                //    value = this._lineTypeScale.scale(propValue);
                //}
                //else
                //{
                //    value = vp.lineTypeToDashArray(value);
                //}
                //return value;
            };

            /// add CONSTANT VALUED drawing attributes.
            ///
            /// we check for undefined so that we don't overwrite the existing theme values if not
            /// constant value was specified.
            baseLayerClass.prototype.addConstantDrawingAttributes = function (da, seriesIndex, filteredData) {
                var itemIndex = 0;

                this._isTextFillMapped = false;
                this._isLineSizeMapped = false;
                this._isTextSizeMapped = false;

                //---- STROKE ----
                var stroke = this.getItemStroke(seriesIndex, itemIndex, filteredData, da.strokePalette);
                if (stroke !== undefined) {
                    da.stroke = stroke;
                }

                //---- TEXTFILL ----
                var textFill = this.getTextFill(seriesIndex, itemIndex, filteredData, da.textFill);
                if (textFill != undefined) {
                    da.textFill = textFill;
                }

                //---- FILL ----
                var fill = this.getItemFill(seriesIndex, itemIndex, filteredData, da.fillPalette);
                if (fill !== undefined) {
                    da.fill = fill;
                }

                //---- OPACITY ----
                var opacity = this.getItemOpacity(seriesIndex, itemIndex, filteredData, da.opacity);
                if (opacity !== undefined) {
                    da.opacity = opacity;
                }

                //---- LINETYPE ----
                var lineType = this.getLineType(seriesIndex, itemIndex, filteredData, da.lineType);
                if (lineType !== undefined) {
                    da.lineType = lineType;
                }

                //---- SHAPE TYPE ----
                var shapeType = this.getItemShapeType(seriesIndex, itemIndex, filteredData, da.shapeType);
                if (shapeType !== undefined) {
                    da.shapeType = shapeType;
                }

                //---- SHAPESIZE ----
                var shapeSize = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.shapeSize, "shapeSize");
                if (shapeSize != undefined) {
                    da.shapeSize = shapeSize;
                }

                //---- LINESIZE ----
                var lineSize = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.lineSize, "lineSize");
                if (lineSize != undefined) {
                    da.lineSize = lineSize;
                }

                //---- TEXTSIZE ----
                var textSize = this.getTextSize(seriesIndex, itemIndex, filteredData, da.textSize);
                if (textSize != undefined) {
                    da.textSize = textSize;
                }

                ////---- SIZE ----
                //var size = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.size, "size");
                //if (size != undefined)
                //{
                //    da.size = size;
                //}
                //---- LABEL ----
                var label = this.getItemLabel(seriesIndex, itemIndex, filteredData, da.label);
                if (label != undefined) {
                    da.textLabel = label;
                }

                //---- HALIGN ----
                var hAlign = this._attributes._hAlign;
                if (hAlign !== undefined) {
                    da.hAlign = hAlign;
                }

                //---- VALIGN ----
                var vAlign = this._attributes._vAlign;
                if (vAlign !== undefined) {
                    da.vAlign = vAlign;
                }

                return da;
            };

            baseLayerClass.prototype.addToList = function (list, name, value) {
                if (list.length) {
                    for (var i = 0; i < list.length; i++) {
                        var da = list[i];

                        da[name] = value;
                    }
                } else {
                    //---- single da was specified ----
                    list[name] = value;
                }
            };

            /// update the drawing attributes with those that are MAPPED for this itemIndex.
            baseLayerClass.prototype.updateDrawingAttributes = function (daList, seriesIndex, itemIndex, filteredData) {
                //---- STROKE ----
                if (this._isStrokeMapped) {
                    var value = this.getItemStroke(seriesIndex, itemIndex, filteredData, daList.stroke);
                    this.addToList(daList, "stroke", value);
                }

                //---- FILL ----
                if (this._isFillMapped) {
                    var value = this.getItemFill(seriesIndex, itemIndex, filteredData, daList.fill);
                    this.addToList(daList, "fill", value);
                }

                //---- OPACITY ----
                if (this._isOpacityMapped) {
                    var value = this.getItemOpacity(seriesIndex, itemIndex, filteredData, daList.opacity);
                    this.addToList(daList, "opacity", value);
                }

                //---- LINE TYPE ----
                if (this._isLineTypeMapped) {
                    var value = this.getLineType(seriesIndex, itemIndex, filteredData, daList.lineType);
                    this.addToList(daList, "lineType", value);
                }

                //---- SHAPE TYPE ----
                if (this._isShapeTypeMapped) {
                    var value = this.getItemShapeType(seriesIndex, itemIndex, filteredData, daList.shapeType);
                    this.addToList(daList, "shapeType", value);
                }

                //---- LINE SIZE ----
                if (this._isLineSizeMapped) {
                    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.lineSize, "lineSize");
                    this.addToList(daList, "lineSize", value);
                }

                //---- SHAPE SIZE ----
                if (this._isShapeSizeMapped) {
                    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.shapeSize, "shapeSize");
                    this.addToList(daList, "shapeSize", value);
                }

                //---- TEXT SIZE ----
                if (this._isTextSizeMapped) {
                    var value = this.getTextSize(seriesIndex, itemIndex, filteredData, daList.textSize);
                    this.addToList(daList, "textSize", value);
                }

                ////---- SIZE ----
                //if (this._isLineSizeMapped)
                //{
                //    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.shapeSize, "size");
                //    this.addToList(daList, "size", value);
                //}
                //---- TEXT FILL ----
                if (this._isTextFillMapped) {
                    var value = this.getTextFill(seriesIndex, itemIndex, filteredData, daList.textFill);
                    this.addToList(daList, "textFill", value);
                }

                //---- TEXT LABEL ----
                if (this._isTextLabelMapped) {
                    var textLabel = this.getItemLabel(seriesIndex, itemIndex, filteredData, daList.text);
                    this.addToList(daList, "textLabel", textLabel);
                }
            };

            /// public setElementInfo():  a centralized way to set 2 common properties for each shape root element.
            /// NOTE: a layer/layer only needs to set the "dataId" and "seriesIndex" for the OUTER GROUP of its shapes.
            ///
            /// dataId:     id of data source for this shape/group (for layers with > 1 data source)
            /// seriesIndex:  index of associated series for this shape/group
            ///
            /// dataId and seriesIndex are used by dataAnimMgr.  Also used for tooltips?
            ///
            baseLayerClass.prototype.setElementInfo = function (elem, dataId, seriesIndex) {
                this.setElementInfoU(elem[0], dataId, seriesIndex);
                //elem
                //    .dataId(dataId)             // for layers with multiple data sources, this identifies the data source
                //    .shapeId(seriesIndex)       // for layers with multiple series, the is the index of the associated series
            };

            baseLayerClass.prototype.setElementInfoU = function (uelem, dataId, seriesIndex) {
                vp.dataId(uelem, dataId); // for layers with multiple data sources, this identifies the data source

                vp.shapeId(uelem, seriesIndex); // for layers with multiple series, the is the index of the associated series
            };

            /// apply constant/mapped attributes specifed in "da" to line element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyLineAttributes = function (elem, da) {
                return vp.applyLineAttributes(elem, da);
            };

            /// apply constant/mapped attributes specifed in "da" to a shape element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyShapeAttributes = function (elem, da) {
                return vp.applyShapeAttributes(elem, da);
            };

            /// apply constant/mapped attributes specifed in "da" to a text element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyTextAttributes = function (elem, da) {
                return vp.applyTextAttributes(elem, da);
            };

            baseLayerClass.prototype.getItemShapeType = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._attributes._shapeType;

                if (binding) {
                    this._isShapeTypeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            /// public readonly: attributes()
            baseLayerClass.prototype.attributes = function () {
                return this._attributes;
            };

            /// public: xBeforeStat()
            baseLayerClass.prototype.xBeforeStat = function () {
                var attr = this._attributes.x();
                var colName = (attr) ? attr._colName : undefined;
                var isConstant = false;

                if (colName === undefined) {
                    isConstant = false;
                }

                return { value: colName, isConstant: isConstant };
            };

            /// public: yBeforeStat()
            baseLayerClass.prototype.yBeforeStat = function () {
                var attr = this._attributes.y();
                var colName = (attr) ? attr._colName : undefined;
                var isConstant = false;

                if (colName === undefined) {
                    isConstant = false;
                }

                return { value: colName, isConstant: isConstant };
            };

            /// return "x" data col, after processing by stat, if any ----
            baseLayerClass.prototype.xAfterStat = function () {
                return this._xColAfterStat;
            };

            /// return "y" data col, after processing by stat, if any ----
            baseLayerClass.prototype.yAfterStat = function () {
                return this._yColsAfterStat;
            };

            baseLayerClass.prototype.buildFrameFromValue = function (value, name) {
                var data = [];

                if (vp.isArray(value)) {
                    for (var i = 0; i < value.length; i++) {
                        var record = {};
                        record[name] = value[i];

                        data.push(record);
                    }
                } else {
                    //---- create single record for scalar ----
                    var record = {};
                    record[name] = value;

                    data.push(record);
                }

                return data;
            };

            baseLayerClass.prototype.addValueToFrame = function (data, value, name) {
                if (vp.isArray(value)) {
                    //---- add next row of vector to each data row ----
                    var nextVectorRow = 0;

                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        row[name] = value[nextVectorRow++];

                        if (nextVectorRow >= value.length) {
                            nextVectorRow = 0;
                        }
                    }
                } else {
                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        row[name] = value;
                    }
                }

                return data;
            };

            /// private: combineConstantAndMappedData(data)
            ///     - combine the data frame with constant data specified on non-mapped properties
            ///     - and update x/y colnames as needed.
            baseLayerClass.prototype.combineConstantAndMappedData = function (inData, idDataId) {
                var xi = this.xBeforeStat();
                var yi = this.yBeforeStat();

                xi.name = xi.value;
                yi.name = yi.value;

                var data = inData;
                var dataId = idDataId;

                if (xi.isConstant) {
                    //---- add scalar/vector value to "data" ----
                    var xName = "$xvalue";
                    xi.name = [xName];
                    var valueLen = (xi.value.length) ? xi.value.length : 1;

                    if ((data) && (data.length == valueLen)) {
                        data = this.addValueToFrame(data, xi.value, xName);
                    } else {
                        //---- create data from "xi.value" ----
                        data = this.buildFrameFromValue(xi.value, xName);
                        dataId = this._vvParent.getNextDataId();
                    }
                }

                if (yi.isConstant) {
                    var yName = "$yvalue";
                    yi.name = [yName];
                    var valueLen = (yi.value.length) ? yi.value.length : 1;

                    if ((data) && (data.length == valueLen)) {
                        data = this.addValueToFrame(data, yi.value, yName);
                    } else {
                        //---- create data from "xi.value" ----
                        data = this.buildFrameFromValue(yi.value, yName);
                        dataId = this._vvParent.getNextDataId();
                    }
                } else {
                    if (yi.name === undefined) {
                        //---- make this easier for subsequent code to work with ----
                        yi.name = [];
                    }
                }

                return { xInfo: xi, yInfo: yi, dataId: dataId, data: data };
            };

            /// private: runStatOnData(data)
            ///    - combines constant/mapped data, run stats on it, and returns transformed data + colNames
            ////
            baseLayerClass.prototype.runStatOnData = function (inData, inDataId) {
                var combo = this.combineConstantAndMappedData(inData, inDataId);

                if ((combo.data) && (this._stat != null) && (this._stat.ctr != "vp.statIdentity")) {
                    combo = this._stat.runStatOnData(combo.xInfo.name, combo.yInfo.name, combo.data, this);

                    //---- stat generated a temp table; increase the data id ----
                    var dataId = this._vvParent.getNextDataId();
                    combo.dataId = dataId;
                } else {
                    combo = { xCol: combo.xInfo.name, yCols: combo.yInfo.name, dataId: combo.dataId, data: combo.data };
                }

                return combo;
            };

            /// private (but needs this to acess key): buildDam()
            baseLayerClass.prototype.buildDam = function () {
                var keyFunc = this._attributes._key;

                this._dataAnimMgr = new vp.dataAnimMgr(null, keyFunc, this._newTagOrFunc);

                if (this._vvParent.shapesEnterFromBottom()) {
                    this._dataAnimMgr.enterEffect(vp.makeEffects("none", "bottom")).exitEffect(vp.makeEffects("none", "top"));
                }

                //--- inherit from parent ----
                this._isAnimEnabled = this._vvParent.isAnimEnabled();

                this.onAnimChanged();
            };

            /// private (but needs this to acess key): buildDam()
            baseLayerClass.prototype.buildDam2 = function () {
                var keyFunc = this._attributes._key2;

                this._dataAnimMgr2 = new vp.dataAnimMgr(null, keyFunc, this._newTagOrFunc2);

                if (this._vvParent.shapesEnterFromBottom()) {
                    this._dataAnimMgr2.enterEffect(vp.makeEffects("none", "bottom")).exitEffect(vp.makeEffects("none", "top"));
                }

                //--- inherit from parent ----
                this._isAnimEnabled = this._vvParent.isAnimEnabled();
                this.onAnimChanged();
            };

            baseLayerClass.prototype.isAnimEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isAnimEnabled;
                }

                this._isAnimEnabled = value;
                this.onAnimChanged();
            };

            baseLayerClass.prototype.onAnimChanged = function () {
                if (this._dataAnimMgr) {
                    this._dataAnimMgr.animDuration(this._isAnimEnabled ? 700 : 0);
                }

                if (this._dataAnimMgr2) {
                    this._dataAnimMgr2.animDuration(this._isAnimEnabled ? 700 : 0);
                }
            };

            /// public: ensureDataAnimMgrExists()
            baseLayerClass.prototype.ensureDataAnimMgrExists = function () {
                if (!this._dataAnimMgr) {
                    this.buildDam();
                }
            };

            /// public: ensureDataAnimMgr2Exists()
            baseLayerClass.prototype.ensureDataAnimMgr2Exists = function () {
                if (!this._dataAnimMgr2) {
                    this.buildDam2();
                }
            };

            //getKeyFunc()
            //{
            //    var keyFunc = this.key();
            //    if (!keyFunc)
            //    {
            //        //keyFunc = this._vvParent.key();
            //        //if (!keyFunc)
            //        //{
            //        //    keyFunc = vp.indexKeyFunc;
            //        //}
            //    }
            //    return keyFunc;
            //}
            //getKeyFunc2()
            //{
            //    var keyFunc2 = this.key2();
            //    if (!keyFunc2)
            //    {
            //        //keyFunc2 = this._vvParent.key2();
            //        //if (!keyFunc2)
            //        //{
            //        //    keyFunc2 = vp.indexKeyFunc;
            //        //}
            //    }
            //    return keyFunc2;
            //}
            /// public: applyFilter(query)
            baseLayerClass.prototype.applyFilter = function (filterQuery, isNewDataSet, onlySetFilter) {
                var _this = this;
                this._filter = filterQuery;

                if (!onlySetFilter) {
                    this.ensureDataAnimMgrExists();
                    this.ensureDataAnimMgr2Exists();

                    //---- apply to data ----
                    var combo = this.getAllData();
                    if (combo.data && combo.data.length) {
                        var inData = combo.data;
                        if (this._filter) {
                            var keyFunc = this._attributes._key;

                            inData = inData.where(function (dataRecord, index) {
                                var key = keyFunc(dataRecord, index);
                                var dataEx = { dataId: 1, key: key, data: dataRecord };

                                var isIn = (!_this._filter.test(dataEx));
                                return isIn;
                            });
                        }

                        this._dataAnimMgr.setData(inData, isNewDataSet, combo.dataId);
                    }

                    //---- apply to data2, if defined ----
                    combo = this.getAllData2();
                    if (combo.data && combo.data.length) {
                        var inData = combo.data;
                        if (this._filter) {
                            var keyFunc = this._attributes._key;

                            inData = inData.where(function (dataRecord, index) {
                                var key = keyFunc(dataRecord, index);
                                var dataEx = { dataId: 2, key: key, data: dataRecord };

                                var isIn = (!_this._filter.test(dataEx));
                                return isIn;
                            });
                        }

                        this._dataAnimMgr2.setData(inData, isNewDataSet, combo.dataId);
                    }
                }

                //this.markRebuildNeeded();
                return this;
            };

            //---- public: getAllData ----
            baseLayerClass.prototype.getAllData = function () {
                var value = this._data;
                var combo = { data: [], xCol: [], yCols: [], dataId: 0 };

                if (value !== undefined) {
                    combo = this.runStatOnData(value, 1);

                    this._xColAfterStat = (combo.xCol) ? combo.xCol : [];
                    this._yColsAfterStat = (combo.yCols) ? combo.yCols : [];
                }

                return combo;
            };

            /// public: updateShapeVisuals() - default shape shading for UI state changes.
            ///
            /// this is the default implmentation for updating a layer's set of shapes
            /// when the selection or the current hover object has been changed.
            baseLayerClass.prototype.updateShapeVisuals = function (selectionCount, daSelected, daUnselected, daHover) {
                //this.ensureDataAnimMgrExists();
                if (this._dataAnimMgr) {
                    var plotShapes = this._dataAnimMgr.getExistingShapes();

                    for (var i = 0; i < plotShapes.length; i++) {
                        var elem = plotShapes[i];
                        this.updateSingleShapeVisuals(elem, daSelected, daUnselected, daHover, selectionCount, elem.isHighlighted, elem.isSelected);
                    }
                }

                if (this._dataAnimMgr2) {
                    var plotShapes = this._dataAnimMgr2.getExistingShapes();

                    for (var i = 0; i < plotShapes.length; i++) {
                        var elem = plotShapes[i];
                        this.updateSingleShapeVisuals(elem, daSelected, daUnselected, daHover, selectionCount, elem.isHighlighted, elem.isSelected);
                    }
                }
            };

            baseLayerClass.prototype.updateSingleShapeVisuals = function (elem, daSelected, daUnselected, daHover, selectionCount, isHighlighted, isSelected) {
                if (elem.tagName == "g") {
                    var kids = vp.children(elem);

                    for (var i = 0; i < kids.length; i++) {
                        var kid = kids[i];
                        this.updateSingleShapeVisuals(kid, daSelected, daUnselected, daHover, selectionCount, isHighlighted, isSelected);
                    }
                } else if (elem.updateVisualHint != "none") {
                    var hint = elem.updateVisualHint || "both";

                    //---- restore FILL ----
                    var origFill = elem.origFill;
                    if ((origFill !== undefined) && (origFill !== null)) {
                        vp.attr(elem, "fill", origFill);
                    }

                    //---- restore STROKE ----
                    var origStroke = elem.origStroke;
                    if ((origStroke !== undefined) && (origStroke !== null)) {
                        vp.attr(elem, "stroke", origStroke);
                    }

                    //---- restore STROKE WIDTH ----
                    var origStrokeWidth = elem.origStrokeWidth;
                    if ((origStrokeWidth !== undefined) && (origStrokeWidth !== null)) {
                        vp.attr(elem, "stroke-width", origStrokeWidth);
                    }

                    //else
                    //{
                    //    vp.attr(elem, "stroke-width", 1);
                    //}
                    //---- restore OPACITY ----
                    var origOpacity = elem.origOpacity;
                    if ((origOpacity !== undefined) && (origOpacity !== null)) {
                        vp.attr(elem, "opacity", origOpacity);
                    } else {
                        vp.attr(elem, "opacity", 1);
                    }

                    var selectChangedDuringHighlight = ((elem.selectChangedDuringHighlight) || (elem.parentNode.selectChangedDuringHighlight));

                    //---- HOVER / SELECTION ----
                    if ((isHighlighted) && (!selectChangedDuringHighlight)) {
                        if ((hint == "stroke") || (hint == "both")) {
                            vp.attr(elem, "stroke", daHover.stroke);
                        }
                        if ((hint == "fill") || (hint == "both")) {
                            vp.attr(elem, "fill", daHover.fill);
                        }
                    } else if (selectionCount > 0) {
                        //---- SELECTED / UNSELECTED ----
                        if ((hint == "stroke") || (hint == "both")) {
                            var stroke = (isSelected) ? daSelected.stroke : daUnselected.stroke;

                            if (stroke) {
                                vp.attr(elem, "stroke", stroke);
                            }

                            var strokeSize = (isSelected) ? daSelected.lineSize : daUnselected.lineSize;

                            if ((strokeSize !== null) && (strokeSize !== undefined)) {
                                vp.attr(elem, "stroke-width", strokeSize);
                            }
                        }

                        if ((hint == "fill") || (hint == "both")) {
                            var fill = (isSelected) ? daSelected.fill : daUnselected.fill;

                            if (fill) {
                                vp.attr(elem, "fill", fill);
                            }
                        }

                        if (hint == "opacity") {
                            var opacity = (isSelected) ? daSelected.opacity : daUnselected.opacity;

                            if ((opacity !== null) && (opacity !== undefined)) {
                                vp.attr(elem, "opacity", opacity);
                            }
                        }
                    }
                }
            };

            //---- public: getAllData2 ----
            baseLayerClass.prototype.getAllData2 = function () {
                var value = this._data2;
                var combo = { data: [], xCol: [], yCols: [], dataId: 0 };

                if (value !== undefined) {
                    combo = this.runStatOnData(value, 2);

                    this._xCol2AfterStat = combo.xCol;
                    this._yCols2AfterStat = combo.yCols;
                }

                return combo;
            };

            baseLayerClass.prototype.validateData = function (value) {
                if (value.selectWithFunc === undefined) {
                    vp.error("agument passed to 'data()' must be a JavaScript array that is created after loading vuePlot.js");
                }
            };

            baseLayerClass.prototype.data = function (value, isNewDataSet) {
                this.ensureDataAnimMgrExists();

                if (arguments.length == 0) {
                    value = [];

                    if (this._dataAnimMgr) {
                        value = this._dataAnimMgr.getData();
                    }

                    return value;
                }

                this.validateData(value);

                this._data = value;

                //---- don't do this now because rebuildChart() will do it later ----
                //this.onPlotDataChanged(false);
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.data2 = function (value2, isNewDataSet) {
                this.ensureDataAnimMgr2Exists();

                if (arguments.length == 0) {
                    var value = [];

                    if (this._dataAnimMgr2) {
                        value = this._dataAnimMgr2.getData();
                    }

                    return value;
                }

                this._data2 = value2;

                this.markRebuildNeeded();
                return this;
            };

            /// public: onPlotDataChanged() - called when "data" is set on vvPlot
            baseLayerClass.prototype.onPlotDataChanged = function (isNewDataSet) {
                //---- since this is like layer.rebuild(), rebind properties here ----
                this.bindProperties();

                //---- we should NOT make this call; vvParent has just called us to do layer-specific work ----
                //vvParent.onFilterChanged();
                this.applyFilter(this._filter, isNewDataSet);

                this.onChartRebuild();
                //this.markRebuildNeeded();
            };

            baseLayerClass.prototype.getProp = function (la, pa, propName) {
                var value = undefined;

                if ((la) && (la[propName] !== undefined)) {
                    value = la[propName];
                } else if ((pa) && (pa[propName] !== undefined)) {
                    value = pa[propName];
                }

                return value;
            };

            //---- rebind all common properties to constants or mappings ----
            baseLayerClass.prototype.bindProperties = function () {
            };

            /// public: onPlotData2Changed() - called when "data" is set on vvPlot
            baseLayerClass.prototype.onPlotData2Changed = function (isNewDataSet) {
                if (vp.isUndefined(this._data2)) {
                    this.applyFilter(this._filter, isNewDataSet);
                }
            };

            baseLayerClass.prototype.markRebuildNeeded = function () {
                //---- layer checks its parent (vvPlot) ----
                if (this._vvParent) {
                    this._vvParent.markRebuildNeeded();
                }
            };

            baseLayerClass.prototype.defaultStackType = function (value) {
                if (arguments.length == 0) {
                    return this._defaultStackType;
                }

                this._defaultStackType = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.chartName = function (value) {
                if (arguments.length == 0) {
                    return this._chartName;
                }

                this._chartName = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.postCreate = function (value) {
                if (arguments.length == 0) {
                    return this._postCreateFunc;
                }

                this._postCreateFunc = value;
                return this;
            };

            baseLayerClass.prototype.dataAnimMgr = function (value) {
                if (arguments.length == 0) {
                    return this._dataAnimMgr;
                }

                this._dataAnimMgr = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.dataAnimMgr2 = function (value) {
                if (arguments.length == 0) {
                    return this._dataAnimMgr2;
                }

                this._dataAnimMgr2 = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.newTagOrFunc = function (value) {
                if (arguments.length == 0) {
                    return this._newTagOrFunc;
                }

                this._newTagOrFunc = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.newTagOrFunc2 = function (value) {
                if (arguments.length == 0) {
                    return this._newTagOrFunc2;
                }

                this._newTagOrFunc2 = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.container = function (value) {
                if (arguments.length == 0) {
                    return this._container;
                }

                this._container = value;

                this.ensureDataAnimMgrExists();
                this._dataAnimMgr.container(value);

                this.ensureDataAnimMgr2Exists();
                this._dataAnimMgr2.container(value);

                //this.markRebuildNeeded();
                return this;
            };

            baseLayerClass.prototype.remove = function () {
                if (this._vvParent) {
                    this._vvParent.removeLayer((this) ? this : this);
                }
            };
            baseLayerClass.nextLayerId = 1;

            baseLayerClass.commonProperties = [
                "x", "y", "lineSize", "shapeSize", "textSize", "stroke", "fill",
                "textFill", "opacity", "lineType", "stackType",
                "key", "key2", "xIntercept", "yIntercept", "slope", "showOutliers", "label", "hAlign", "vAlign",
                "yMin", "yMax", "yOpen", "yClose", "xEnd", "yEnd", "direction", "fillRule", "shapeType"
            ];
            return baseLayerClass;
        })();
        layers.baseLayerClass = baseLayerClass;

        var baseLayer = (function (_super) {
            __extends(baseLayer, _super);
            function baseLayer() {
                _super.apply(this, arguments);
            }
            return baseLayer;
        })(baseLayerClass);
        layers.baseLayer = baseLayer;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// -line.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a line chart type layer for a plot object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a "line plot" layer */
        var lineSuperClass = (function (_super) {
            __extends(lineSuperClass, _super);
            //---- private state ----
            function lineSuperClass() {
                _super.call(this);

                this.layerType("line").stat(vp.statIdentity()).defaultStackType("dodge").chartName("Line").newTagOrFunc("line");
            }
            lineSuperClass.prototype.adjustChartOptions = function () {
                this._xDefaults.zeroAxis = false;
            };

            lineSuperClass.prototype.getX = function (index, xRecord, xScale, xIsCategoryScale) {
                //---- since this function is shared by other layer's (see layerPath), we support ----
                //---- both CATEGORY and LINEAR scales for X within this function ----
                var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];

                var x = xScale.scale(xValue);
                if (xIsCategoryScale) {
                    var w = Math.max(.25, xScale.itemWidth());
                    x += w / 2;
                }

                return x;
            };

            lineSuperClass.prototype.getY = function (index, yRecord, yScale, pi) {
                var dataValue = yRecord.data[index];

                var y = yScale.flipScale(dataValue);
                var h = Math.max(0, yScale.scaleSize(dataValue));

                if (pi.stackType == "stack") {
                    var adjValue = dataValue + pi.itemAccums[index];

                    //---- starts at dataValue, offset by previous..  height doesn't change ----
                    y = yScale.flipScale(adjValue);

                    pi.itemAccums[index] = adjValue;
                } else if (pi.stackType == "fill") {
                    var newAccum = pi.itemAccums[index] + dataValue;
                    var adjValue2 = newAccum / pi.itemTotals[index];
                    y = yScale.flipScale(adjValue2);

                    var adjHeight = dataValue / pi.itemTotals[index];
                    h = Math.max(0, yScale.scaleSize(adjHeight));

                    pi.itemAccums[index] = newAccum;
                }

                return y;
            };

            /// public drawShapes() - draw line plot.
            lineSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerLine", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = _this.getX(index, xRecord, xScale, xIsCategoryScale);
                    var y = _this.getY(index, yRecord, yScale, pi);

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        lastx = _this.getX(index - 1, xRecord, xScale, xIsCategoryScale);
                        lasty = _this.getY(index - 1, yRecord, yScale, pi);
                    }

                    elem.from(lastx, lasty).to(x, y).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    firstUpdateCall = false;
                });

                return shapes;
            };
            return lineSuperClass;
        })(vp.layers.baseLayerClass);
        layers.lineSuperClass = lineSuperClass;

        var lineClass = (function (_super) {
            __extends(lineClass, _super);
            function lineClass() {
                _super.apply(this, arguments);
            }
            return lineClass;
        })(lineSuperClass);
        layers.lineClass = lineClass;

        function createLine() {
            return new lineClass();
        }
        layers.createLine = createLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// tile.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a "tile" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a fixed size "tile" layer for a plot.  Tiles are layed out in a grid, starting with the upper left corner of the plot.
        The tile layer supports optional "x" and "y" mapped, which are used only to provide category labels for the x and y axes.
        For a variable sized tile plot, see the "xyTile" class. */
        var tileSuperClass = (function (_super) {
            __extends(tileSuperClass, _super);
            function tileSuperClass() {
                _super.call(this);
                //---- private state ----
                this._numCols = undefined;

                this.layerType("tile").stat(vp.statIdentity()).defaultStackType("dodge").chartName("Tile").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = false;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
            }
            tileSuperClass.prototype.adjustChartOptions = function () {
                //---- when we have no "x" and "y" data, we create some to keep the X and Y scales and gridlines ----
                //---- in sync with how we draw the cells ----
                var data = this.data();

                var count = data.length;
                var numCols = this.getNumCols(data.length, null);
                var numRows = Math.ceil(count / numCols);

                if (!this._xAttr.isMapped()) {
                    //options.xDataOverride = vp.range(1, numCols);
                    this._xDefaults.dataOverride = vp.range(1, numCols);
                }

                if (!this._yAttr.isMapped()) {
                    //options.yDataOverride = vp.range(1, numRows);
                    this._yDefaults.dataOverride = vp.range(1, numRows);
                }

                this._xDefaults.isDiscrete = true;
                this._yDefaults.isDiscrete = true;
                //---- don't hide gridlines, since some tile layers will not be completely full ----
            };

            tileSuperClass.prototype.getNumCols = function (numRows, xRecord) {
                var numCols = this._numCols;
                if (!numCols) {
                    //---- see if we can get from x mapping for labels ----
                    if ((numRows > 0) && (xRecord) && (this._xAttr.isUserMapped())) {
                        var firstCol = xRecord.data[0];
                        numCols = numRows; // default if not found

                        for (var i = 1; i < numRows; i++) {
                            if (firstCol == xRecord.data[i]) {
                                numCols = i;
                                break;
                            }
                        }
                    } else {
                        numCols = Math.floor(Math.sqrt(numRows));
                    }
                }

                return numCols;
            };

            /// public drawShapes() - draw tile plot.
            /// we draw a rectangle whose location is based on the "index" (record number) of the data.  An
            /// optional "numCols" property controls the number of columns in the X dimension.
            tileSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                if (!da) {
                    da = vp.currentTheme().getDrawingAttributes("layerTile", seriesIndex);
                }

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //var xIsCategory = (xScale.mapType() != vp.MapType.lerp);
                //var yIsCategory = (yScale.mapType() != vp.MapType.lerp);
                //---- init these to full data width/height, in case there is only 1 row/col ----
                //var numCols = xRecord.data.distinct().length;   // number of unique values in X
                //var numRows = yRecord.data.distinct().length;   // number of unique values in Y
                var count = filteredData.length;
                var numCols = this.getNumCols(count, xRecord);
                var numRows = Math.ceil(count / numCols);

                var width = layInfo.width / numCols;
                var height = layInfo.height / numRows;

                var start = +Date.now();

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //var elem = vp.select(uelem);
                    //var elem = vp.visuals.createSingleWrapper(uelem);
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var scrLeft = width * (index % numCols);
                    var top = (height * Math.floor(index / numCols));
                    var scrTop = layInfo.height - top - height;

                    //---- apply LAYOUT and attributes ----
                    vp.bounds(uelem, scrLeft, scrTop, width, height);
                    vp.prop(uelem, "updateVisualHint", "fill");

                    vp.applyShapeAttributesU(uelem, da);

                    if (isNewShape) {
                        layer.setElementInfoU(uelem, 1, seriesIndex);
                    }
                });

                var drawElapsed = +Date.now() - start;

                return shapes;
            };

            tileSuperClass.prototype.numCols = function (value) {
                if (arguments.length == 0) {
                    return this._numCols;
                }

                this._numCols = value;
                return this;
            };
            return tileSuperClass;
        })(vp.layers.baseLayerClass);
        layers.tileSuperClass = tileSuperClass;

        var tileClass = (function (_super) {
            __extends(tileClass, _super);
            function tileClass() {
                _super.apply(this, arguments);
            }
            return tileClass;
        })(tileSuperClass);
        layers.tileClass = tileClass;

        function createTile() {
            return new tileClass();
        }
        layers.createTile = createTile;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// xyTile.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a "tile" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** This class is used to draw a variable sized "tile" layer for a plot.
        
        Each data record is expected to provide "x" and "y" offsets, so the resulting plot may
        contain variable width and variable height tiles.  The values of x in the first row determine
        the horizontal offsets of the tiles, and the values of y in the first column determine the
        vertical offsets of the tiles. This is the "mesh data" format typically used to draw a surface plot.
        
        Note that tiles are formed by connecting the x/y points in each record to each other, so if
        you want 4 tiles per row, each row must contain 5 records.
        
        For a simplier and faster tile plot, see the "tileClass" class. */
        var xyTileSuperClass = (function (_super) {
            __extends(xyTileSuperClass, _super);
            //---- private state ----
            function xyTileSuperClass() {
                _super.call(this);

                this.layerType("tile").stat(vp.statIdentity()).defaultStackType("dodge").chartName("Tile").newTagOrFunc("rect");
            }
            xyTileSuperClass.prototype.adjustChartOptions = function () {
            };

            /// public drawShapes() - draw tile plot.
            /// we grab xOffsets from first row and yOffsets from first column, then draw tiles between all
            /// xOffsets and yOffsets.
            xyTileSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- extract xOffsets, based on the first row of data ----
                var xOffsets = [];
                var xData = xRecord.data;
                var lastX = null;

                for (var i = 0; i < xData.length; i++) {
                    if ((i) && (xData[i] < lastX)) {
                        break;
                    }

                    xOffsets.push(xData[i]);
                    var lastX = xData[i];
                }

                var numCols = i;

                //---- extract yOffsets, based on the first column of data ----
                var yOffsets = [];
                var yData = yRecord.data;

                for (var i = 0; i < yData.length; i += numCols) {
                    yOffsets.push(yData[i]);
                }

                var numRows = yOffsets.length;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                if (!da) {
                    da = vp.currentTheme().getDrawingAttributes("layerTile", seriesIndex);
                }

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var xIsCategory = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategory = (yScale.mapType() != vp.MapType.lerp);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var colNum = index % numCols;
                    var rowNum = Math.floor(index / numCols);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var scrLeft = xScale.scale(xOffsets[colNum]);
                    var scrRight = xScale.scale(xOffsets[colNum + 1]);
                    var scrWidth = scrRight - scrLeft;

                    var scrTop = yScale.flipScale(yOffsets[rowNum + 1]);
                    var scrBottom = yScale.flipScale(yOffsets[rowNum]);
                    var scrHeight = scrBottom - scrTop;

                    //---- apply LAYOUT and attributes ----
                    elem.bounds(scrLeft, scrTop, scrWidth, scrHeight).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return xyTileSuperClass;
        })(vp.layers.baseLayerClass);
        layers.xyTileSuperClass = xyTileSuperClass;

        var xyTileClass = (function (_super) {
            __extends(xyTileClass, _super);
            function xyTileClass() {
                _super.apply(this, arguments);
            }
            return xyTileClass;
        })(xyTileSuperClass);
        layers.xyTileClass = xyTileClass;

        function createXyTile() {
            return new xyTileClass();
        }
        layers.createXyTile = createXyTile;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// abLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an abLine layer (set of lines based on slope, y-intercept values) for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an abLine layer (set of lines based on slope, y-intercept values) for a plot.  */
        var abLineClass = (function (_super) {
            __extends(abLineClass, _super);
            //---- private state ----
            function abLineClass() {
                _super.call(this);

                this.layerType("abLine").stat(vp.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");

                //---- defaults for X scale/axis ----
                this._xDefaults.isDiscrete = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.isDiscrete = false;
            }
            abLineClass.prototype.adjustChartOptions = function () {
            };

            abLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- AB LINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerAbLine", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x1 = xScale.domainMin();
                    var x2 = xScale.domainMax();

                    //---- "slope" is an alias for "x" ----
                    //---- "yIntercept" is an alias for "y" ----
                    var slope = xRecord.data[index];
                    if (slope === undefined) {
                        slope = 0;
                    }

                    var b = yRecord.data[index];
                    if (b === undefined) {
                        b = 1;
                    }

                    //---- compute y1, y2 ----
                    var y1 = slope * x1 + b;
                    var y2 = slope * x2 + b;

                    //---- now scale y1, y2 ----
                    y1 = yScale.flipScale(y1);
                    y2 = yScale.flipScale(y2);

                    //---- now scale x1, x2 ----
                    x1 = xScale.scale(x1);
                    x2 = xScale.scale(x2);

                    var elem = vp.select(uelem);

                    elem.from(x1, y1).to(x2, y2).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return abLineClass;
        })(vp.layers.baseLayerClass);
        layers.abLineClass = abLineClass;

        function createAbLine() {
            return new abLineClass();
        }
        layers.createAbLine = createAbLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// area.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots an "area plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var areaClass = (function (_super) {
            __extends(areaClass, _super);
            //---- private state ----
            function areaClass() {
                _super.call(this);

                this.layerType("area").stat(vp.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                this._xDefaults.colNames = ["x"];
                this._yDefaults.colNames = ["y"];
            }
            areaClass.prototype.adjustChartOptions = function () {
                this._xDefaults.zeroAxis = false;
            };

            areaClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            areaClass.prototype.getX = function (index, xRecord, xScale, xIsCategoryScale) {
                //---- since this function is shared by other layer's (see layerPath), we support ----
                //---- both CATEGORY and LINEAR scales for X within this function ----
                var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];

                var x = xScale.scale(xValue);
                if (xIsCategoryScale) {
                    var w = Math.max(.25, xScale.itemWidth());
                    x += w / 2;
                }

                return x;
            };

            areaClass.prototype.getY = function (index, yRecord, yScale, pi) {
                var dataValue = yRecord.data[index];

                var y = yScale.flipScale(dataValue);
                var h = Math.max(0, yScale.scaleSize(dataValue));
                var yZero = yScale.flipScale(0);

                if (pi.stackType == "stack") {
                    var adjValue = dataValue + pi.itemAccums[index];

                    //---- starts at dataValue, offset by previous..  height doesn't change ----
                    y = yScale.flipScale(adjValue);
                    yZero = yScale.flipScale(pi.itemAccums[index]);

                    pi.itemAccums[index] = adjValue;
                } else if (pi.stackType == "fill") {
                    var newAccum = pi.itemAccums[index] + dataValue;
                    var adjValue2 = newAccum / pi.itemTotals[index];
                    var adjZero = pi.itemAccums[index] / pi.itemTotals[index];

                    y = yScale.flipScale(adjValue2);
                    yZero = yScale.flipScale(adjZero);

                    var adjHeight = dataValue / pi.itemTotals[index];
                    h = Math.max(0, yScale.scaleSize(adjHeight));

                    pi.itemAccums[index] = newAccum;
                }

                return { y: y, h: h, yZero: yZero };
            };

            /// public drawShapes() - draw area plot.
            areaClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerArea", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var dataValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    var xLeft = _this.getX(index, xRecord, xScale, xIsCategoryScale);
                    var yyy = _this.getY(index, yRecord, yScale, pi);

                    var y = +yyy.y;
                    var h = +yyy.h;
                    var yZero = +yyy.yZero;

                    firstUpdateCall = false;

                    var w = Math.max(.25, xScale.itemWidth());
                    var x = xLeft;

                    if (index == 0) {
                        lastx = xLeft;
                        lasty = y;
                        lastyZero = yZero;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        lastx = _this.getX(index - 1, xRecord, xScale, xIsCategoryScale);
                        yyy = _this.getY(index - 1, yRecord, yScale, pi);

                        lasty = yyy.y;
                        lastyZero = yyy.yZero;
                    }

                    //---- build string of points ----
                    var points = "";
                    points = _this.addPoint(points, lastx, lastyZero);
                    points = _this.addPoint(points, lastx, lasty);
                    points = _this.addPoint(points, x, y);
                    points = _this.addPoint(points, x, yZero);

                    //---- apply LAYOUT attributes ----
                    elem.attr("points", points).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    lastyZero = yZero;
                });

                return shapes;
            };
            return areaClass;
        })(vp.layers.baseLayerClass);
        layers.areaClass = areaClass;

        function createArea() {
            return new areaClass();
        }
        layers.createArea = createArea;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// attrDefaults.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a structure to hold system-defined default values for attribute fields.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        /** settings for an attribute (value, scaling, legend data, etc).  User settings take precedence over these values. */
        var attrDefaults = (function () {
            function attrDefaults() {
                this.dataMin = undefined;
                this.dataMax = undefined;
                this.isMinMaxSoft = undefined;
                this.tickCount = undefined;
                this.dateFormat = undefined;
                this.zeroAxis = true;
                this.addMaxHeadroom = true;
                this.useNiceNumbers = true;
                this.percentGap = .30;
                this.combineDups = false;
                this.colNames = [];
                this.intOnlyBreaks = false;
            }
            return attrDefaults;
        })();
        layers.attrDefaults = attrDefaults;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// bar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a bar chart type layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
/// layer responsibilities (informal contract/API):
///     - set the stat that matches this layer
///     - set the baseLayer properties for this layer
///     - drawShapes() - draw the shapes for this layer
///     - getDefaultChartType() - get chart type that matches this layer
///     - adjustChartOptions(options) - adjust options to match needs of the layer (e.g., zero x axes)
///     - set the layer "newTagOrFunc" to a tag or function for new elements
///
///     - addSpecialControlsToChart() - optional; add special controls (like slider) to chart
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a layer of vertical columns */
        var barClass = (function (_super) {
            __extends(barClass, _super);
            function barClass() {
                _super.call(this);
                //---- private state ----
                this._percentGap = .30;

                this.layerType("bar").stat(vp.statIdentity()).defaultStackType("stack").chartName("Bar").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = false;
                //---- defaults for Y scale/axis ----
                this._yDefaults.percentGap = this._percentGap;
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = true;
            }
            barClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.shapesEnterFromBottom = true;
            };

            /// public drawShapes() - draw horizontal bar shapes.
            barClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var adjValue = xValue;

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    //---- for BAR LAYER: "x" should be LINEAR, "y" is typically CATEGORY ----
                    var x = xScale.scale(0);
                    var y = yScale.flipScale(yValue);
                    var w = Math.max(0, xScale.scaleSize(xValue));
                    var h = Math.max(.25, yScale.itemWidth());

                    if (pi.stackType == "stack") {
                        var xBase = pi.itemAccums[index];

                        //---- starts at xValue, offset by previous..  height doesn't change ----
                        x = xScale.scale(xBase);

                        pi.itemAccums[index] += xValue;
                    } else if (pi.stackType == "fill") {
                        var newAccum = pi.itemAccums[index];
                        var adjValue2 = newAccum / pi.itemTotals[index];
                        x = xScale.scale(adjValue2);

                        var adjHeight = xValue / pi.itemTotals[index];
                        w = Math.max(0, xScale.scaleSize(adjHeight));

                        pi.itemAccums[index] += xValue;
                    } else if (pi.stackType == "dodge") {
                        y = yScale.flipScale(yValue, seriesIndex);
                        h = Math.max(.25, yScale.seriesItemWidth());
                    }

                    //---- layout elem ----
                    elem.attr("y", y).attr("x", x).attr("height", h).attr("width", w).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            /** the size of the gap between columns (0-1). */
            barClass.prototype.percentGap = function (value) {
                if (arguments.length == 0) {
                    return this._percentGap;
                }

                this._percentGap = value;

                this._yDefaults.percentGap = value;

                this.markRebuildNeeded();
                return this;
            };
            return barClass;
        })(vp.layers.baseLayerClass);
        layers.barClass = barClass;

        function createBar() {
            return new barClass();
        }
        layers.createBar = createBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// boxPlot.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "box plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a "box plot" layer for a plot. */
        var boxPlotClass = (function (_super) {
            __extends(boxPlotClass, _super);
            //---- private state ----
            function boxPlotClass() {
                _super.call(this);

                this.layerType("boxPlot").stat(vp.statBoxPlot()).defaultStackType("identity").chartName("BoxPlot").newTagOrFunc("g");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = true;
                this._xDefaults.zeroAxis = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["lower", "upper", "middle", "ymin", "ymax"];
                this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = true;
            }
            boxPlotClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showLegend = false;
            };

            boxPlotClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- BOX PLOT ----
                var layInfo = layer.info;
                var keyFunc = layInfo.keyFunc;
                var filteredData = layInfo.filteredData;
                var attributes = layer.attributes();

                //---- we only support 1 series but use multi y-cols, so set this explicitly ----
                var seriesIndex = 0;
                var seriesCount = 1;
                var dataId = 1;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daLines = vp.currentTheme().getDrawingAttributes("layerBoxPlot.lines", seriesIndex);
                var daBox = vp.currentTheme().getDrawingAttributes("layerBoxPlot.box", seriesIndex);
                var daOutliers = vp.currentTheme().getDrawingAttributes("layerBoxPlot.outliers", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(daLines, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daBox, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daOutliers, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes([daLines, daBox, daOutliers], seriesIndex, index, filteredData);

                    var group = vp.select(uelem).clear();

                    if (isNewShape) {
                        layer.setElementInfo(group, dataId, seriesIndex);
                    }

                    group.clear(); // remove previous children

                    var xValue = (index + 1);
                    var x = xScale.scale(index);
                    var w = Math.max(.25, xScale.itemWidth());
                    var record = filteredData[index];
                    var xMid = x + w / 2;

                    var y1 = yScale.flipScale(record.highFence);
                    var y2 = yScale.flipScale(record.lowFence);

                    //---- add VERTICAL LINE ----
                    var vline = group.append("line").attr("x1", xMid).attr("x2", xMid).attr("y1", y1).attr("y2", y2).prop("updateVisualHint", "none");

                    layer.applyLineAttributes(vline, daLines);

                    var dataH = Math.max(0, record.upper - record.lower);

                    var y = yScale.flipScale(record.upper);
                    var h = Math.max(0, yScale.scaleSize(dataH));

                    //---- add BOX ----
                    var box = group.append("rect").attr("x", x).attr("width", w).attr("y", y).attr("height", h).prop("updateVisualHint", "both");

                    layer.applyShapeAttributes(box, daBox);

                    var yMedian = yScale.flipScale(record.middle);

                    //---- add MEDIAN LINE ----
                    var mline = group.append("line").attr("x1", x).attr("x2", x + w).attr("y1", yMedian).attr("y2", yMedian).prop("updateVisualHint", "none");

                    layer.applyLineAttributes(mline, daLines);

                    if (attributes._showOutliers) {
                        //---- draw outliers as 1 dim dot plot ----
                        var outliers = record.outliers;
                        outliers.generate(group, "circle", function (elem, yValue, index) {
                            elem.attr("cx", xMid).attr("cy", yScale.flipScale(yValue)).attr("r", daOutliers.shapeSize / 2).prop("updateVisualHint", "fill");

                            layer.applyShapeAttributes(elem, daOutliers);
                        });
                    }
                });

                return shapes;
            };
            return boxPlotClass;
        })(vp.layers.baseLayerClass);
        layers.boxPlotClass = boxPlotClass;

        function createBoxPlot() {
            return new boxPlotClass();
        }
        layers.createBoxPlot = createBoxPlot;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// candlestick.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a candlestick layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a candlestick layer for a plot. */
        var candlestickClass = (function (_super) {
            __extends(candlestickClass, _super);
            //---- private state ----
            function candlestickClass() {
                _super.call(this);

                this.layerType("candleStick").stat(vp.statIdentity()).defaultStackType("identity").chartName("CandleStick").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            candlestickClass.prototype.adjustChartOptions = function () {
            };

            candlestickClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            candlestickClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CANDLESTICK ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerCandlestick", seriesIndex);
                var daUp = vp.currentTheme().getDrawingAttributes("layerCandlestick.upDayBar", seriesIndex);
                var daDown = vp.currentTheme().getDrawingAttributes("layerCandlestick.downDayBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daUp, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daDown, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes([da, daUp, daDown], seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var yOpenCol = attributes._yOpen.getAfterStatsPropName(seriesIndex);
                    var yOpenValue = record[yOpenCol];

                    var yCloseCol = attributes._yClose.getAfterStatsPropName(seriesIndex);
                    var yCloseVal = record[yCloseCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);
                    var yOpen = yScale.flipScale(yOpenValue);
                    var yClose = yScale.flipScale(yCloseVal);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line = g.append("line").from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    var barSize2 = da.shapeSize / 2;

                    //---- open/close box ----
                    var rect = g.append("rect").bounds(x - barSize2, Math.min(yOpen, yClose), da.shapeSize, Math.abs(yOpen - yClose)).prop("updateVisualHint", "stroke");

                    da.fill = (yOpen > yClose) ? daDown.fill : daUp.fill;

                    layer.applyShapeAttributes(rect, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(rect, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return candlestickClass;
        })(vp.layers.baseLayerClass);
        layers.candlestickClass = candlestickClass;

        function createCandlestick() {
            return new candlestickClass();
        }
        layers.createCandlestick = createCandlestick;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// column.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines a column plotLayer.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a layer of vertical columns */
        var columnSuperClass = (function (_super) {
            __extends(columnSuperClass, _super);
            function columnSuperClass() {
                _super.call(this);
                //---- private state ----
                this._percentGap = .30;

                this.layerType("column").stat(vp.statIdentity()).defaultStackType("stack").chartName("Column").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.percentGap = this._percentGap;
                this._xDefaults.isDiscrete = true;
            }
            columnSuperClass.prototype.adjustChartOptions = function () {
            };

            /** draw vertical column shapes.
            NOTE: this is also used by layerHistogram, which sometimes uses a LINEAR XSCALE. */
            columnSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //vp.debug("layerColumn.drawShapes: xRecord.data.length=" + xRecord.data.length);
                if (!da) {
                    //---- get THEME drawing attributes for each of the parts we will draw ----
                    da = vp.currentTheme().getDrawingAttributes("layerColumn", seriesIndex);
                }

                var recordCount = filteredData.length;
                var colWidth = Math.max(.25, xScale.itemWidth());

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);
                    var x = 0;
                    var w = 0;

                    //if (xScale.scaleType == "space")
                    //{
                    //    var record = filteredData[index];
                    //    x = xScale.scale(record.min);
                    //    var x2 = xScale.scale(record.max);
                    //    w = x2 - x;
                    //}
                    //else
                    //{
                    //    x = xScale.scale(index);
                    //    w = colWidth;
                    //}
                    x = xScale.scale(xValue);
                    w = colWidth;

                    var y = yScale.flipScale(yValue);
                    var h = Math.max(0, yScale.scaleSize(yValue));

                    //---- turn off stroke around columns when width < 5 ----
                    if (w < 5) {
                        da.stroke = da.fill;
                    }

                    if (pi.stackType == "stack") {
                        var adjValue = yValue + pi.itemAccums[index];

                        //---- starts at dataValue, offset by previous..  height doesn't change ----
                        y = yScale.flipScale(adjValue);

                        pi.itemAccums[index] = adjValue;
                    } else if (pi.stackType == "fill") {
                        var newAccum = pi.itemAccums[index] + yValue;
                        var adjValue2 = newAccum / pi.itemTotals[index];
                        y = yScale.flipScale(adjValue2);

                        var adjHeight = yValue / pi.itemTotals[index];
                        h = Math.max(0, yScale.scaleSize(adjHeight));

                        pi.itemAccums[index] = newAccum;
                    } else if (pi.stackType == "dodge") {
                        x = xScale.scale(index, seriesIndex);
                        w = Math.max(.25, xScale.seriesItemWidth());
                    }

                    //---- apply LAYOUT attributes ----
                    elem.attr("x", x).attr("y", y).attr("width", w).attr("height", h).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            /** the size of the gap between columns (0-1). */
            columnSuperClass.prototype.percentGap = function (value) {
                if (arguments.length == 0) {
                    return this._percentGap;
                }

                this._percentGap = value;

                this._xDefaults.percentGap = value;

                this.markRebuildNeeded();
                return this;
            };
            return columnSuperClass;
        })(vp.layers.baseLayerClass);
        layers.columnSuperClass = columnSuperClass;

        var columnClass = (function (_super) {
            __extends(columnClass, _super);
            function columnClass() {
                _super.apply(this, arguments);
            }
            return columnClass;
        })(columnSuperClass);
        layers.columnClass = columnClass;

        function createColumn() {
            return new columnClass();
        }
        layers.createColumn = createColumn;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// contour.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "contour plot" layer for a chart.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "line range" layer for a plot. */
        var contourClass = (function (_super) {
            __extends(contourClass, _super);
            function contourClass() {
                _super.call(this);
                //---- private state ----
                this._contourCount = 5;

                var stat = vp.stats.createStatContour().contourCount(this._contourCount);

                this.layerType("contour").stat(stat).defaultStackType("identity").chartName("contour").newTagOrFunc("line");
            }
            contourClass.prototype.calcXScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var min = undefined;
                var max = undefined;

                if (data) {
                    //---- set data MIN/MAX for X attribute/scale ----
                    min = data.min(function (data, index) {
                        return Math.min(data.x1, data.x2);
                    });
                    max = data.max(function (data, index) {
                        return Math.max(data.x1, data.x2);
                    });
                    //---- leave some space around min/max ----
                    //min = (min < 0) ? (1.2 * min) : (.8 * min);
                    //max = (max < 0) ? (.8 * max) : (1.2 * max);
                }

                return { min: min, max: max };
            };

            contourClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var min = undefined;
                var max = undefined;

                if (data) {
                    //---- set data MIN/MAX for Y attribute/scale ----
                    min = data.min(function (data, index) {
                        return Math.min(data.y1, data.y2);
                    });
                    max = data.max(function (data, index) {
                        return Math.max(data.y1, data.y2);
                    });
                    //---- leave some space around min/max ----
                    //min = (min < 0) ? (1.2 * min) : (.8 * min);
                    //max = (max < 0) ? (.8 * max) : (1.2 * max);
                }

                return { min: min, max: max };
            };

            contourClass.prototype.contourCount = function (value) {
                if (arguments.length == 0) {
                    return this._contourCount;
                }

                this._contourCount = value;
                this._stat.contourCount(value);

                return this;
            };

            contourClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CONTOUR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layercontour", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    //var x1Data = record.x1;from =
                    var x1Data = record.x1;
                    var y1Data = record.y1;
                    var x2Data = record.x2;
                    var y2Data = record.y2;

                    var x1 = xScale.scale(x1Data);
                    var x2 = xScale.scale(x2Data);

                    var y1 = yScale.flipScale(y1Data);
                    var y2 = yScale.flipScale(y2Data);

                    //if (xIsCategoryScale)
                    //{
                    //    x += xScale.itemWidth() / 2;
                    //}
                    vp.from(uelem, x1, y1);
                    vp.to(uelem, x2, y2);
                    uelem.updateVisualHint = "stroke";

                    vp.applyLineAttributesU(uelem, da);

                    if (isNewShape) {
                        layer.setElementInfoU(uelem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return contourClass;
        })(vp.layers.baseLayerClass);
        layers.contourClass = contourClass;

        function createContour() {
            return new contourClass();
        }
        layers.createContour = createContour;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// crossBar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a cross bar plot layer (rect with a horizontal line through it).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var crossBarClass = (function (_super) {
            __extends(crossBarClass, _super);
            //---- private state ----
            function crossBarClass() {
                _super.call(this);

                this.layerType("corssBar").stat(vp.statIdentity()).defaultStackType("identity").chartName("CrossBar").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            crossBarClass.prototype.adjustChartOptions = function () {
            };

            crossBarClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            crossBarClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CROSS BAR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerCrossBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    var itemSize = xScale.itemWidth();
                    var barSize2 = itemSize / 2;

                    //---- min/max box ----
                    var rect = g.append("rect").bounds(x - barSize2, yMax, itemSize, yMin - yMax).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(rect, da);

                    //---- y line ----
                    var line = g.append("line").from(x - barSize2, y).to(x + barSize2, y).prop("updateVisualHint", "none");

                    layer.applyLineAttributes(line, da);

                    if (isNewShape) {
                        layer.setElementInfo(rect, 1, seriesIndex);
                        layer.setElementInfo(line, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return crossBarClass;
        })(vp.layers.baseLayerClass);
        layers.crossBarClass = crossBarClass;

        function createCrossBar() {
            return new crossBarClass();
        }
        layers.createCrossBar = createCrossBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// density.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a density layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a density layer for a plot. */
        var densityClass = (function (_super) {
            __extends(densityClass, _super);
            function densityClass() {
                _super.call(this);
                //---- private state ----
                this._binPercent = .03;

                this.layerType("density").stat(vp.statDensity()).defaultStackType("stack").chartName("Density").newTagOrFunc("line");
            }
            densityClass.prototype.adjustChartOptions = function () {
            };

            densityClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- DENSITY ----
                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            densityClass.prototype.onBinPercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.binPercent)) {
                    stat.binPercent(this._binPercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: binPercent ----
            densityClass.prototype.binPercent = function (value) {
                if (arguments.length == 0) {
                    return this._binPercent;
                }

                this._binPercent = value;
                this.onBinPercentChanged();

                return this;
            };
            return densityClass;
        })(vp.layers.lineSuperClass);
        layers.densityClass = densityClass;

        function createDensity() {
            return new densityClass();
        }
        layers.createDensity = createDensity;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// errorBar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an error bar layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var errorBarClass = (function (_super) {
            __extends(errorBarClass, _super);
            //---- private state ----
            function errorBarClass() {
                _super.call(this);

                this.layerType("errorBar").stat(vp.statIdentity()).defaultStackType("identity").chartName("ErrorBar").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            errorBarClass.prototype.adjustChartOptions = function () {
            };

            errorBarClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            errorBarClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- ERROR BAR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerErrorBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line1 = g.append("line").from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    var barSize2 = da.shapeSize;

                    //---- top line ----
                    var line2 = g.append("line").from(x - barSize2, yMax).to(x + barSize2, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    //---- bottom line ----
                    var line3 = g.append("line").from(x - barSize2, yMin).to(x + barSize2, yMin).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line3, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                        layer.setElementInfo(line3, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return errorBarClass;
        })(vp.layers.baseLayerClass);
        layers.errorBarClass = errorBarClass;

        function createErrorBar() {
            return new errorBarClass();
        }
        layers.createErrorBar = createErrorBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// graph.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a node link graph as a layer of a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a node link graph as a layer of a plot. */
        var graphClass = (function (_super) {
            __extends(graphClass, _super);
            function graphClass() {
                _super.call(this);
                //---- private state ----
                this._drawParams = undefined;
                this._group = null;
                this._layoutTimer = null;
                this._padding = 10;
                this._useEllipse = true;

                this.layerType("graph").stat(vp.statIdentity()).defaultStackType("identity").chartName("Graph").newTagOrFunc("g").newTagOrFunc2("g");
            }
            graphClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showLegend = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;
                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            graphClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- save off drawing parameters for later use ----
                this._drawParams = {
                    shapeRoot: shapeRoot, xRecord: xRecord, yRecord: yRecord, seriesIndex: seriesIndex,
                    pi: pi, xScale: xScale, yScale: yScale, stdChart: plot, layer: layer, info: layer.info
                };

                //---- buffer requests for layout so we don't send too many during a RESIZE operation ----
                if (this._layoutTimer) {
                    clearTimeout(this._layoutTimer);
                }

                this._layoutTimer = setTimeout(vp.cb(this, this.startLayout), 125);

                //---- we will draw our shapes aync using "group" ----
                return vp.select();
            };

            graphClass.prototype.startLayout = function () {
                var _this = this;
                clearTimeout(this._layoutTimer);
                this._layoutTimer = null;

                var shapeRoot = this._drawParams.shapeRoot;
                var xRecord = this._drawParams.xRecord;
                var info = this._drawParams.info;

                //---- initiate a async layout from our web service ----
                var urlDir = vp.getUrlDirectory();

                var w = info.width - 2 * this._padding;
                var h = info.height - 2 * this._padding;
                var yCols = this.yAfterStat();

                var idCol = (xRecord) ? xRecord.name : "id";
                var fromCol = ((yCols) && (yCols.length > 0)) ? yCols[0] : "from";
                var toCol = ((yCols) && (yCols.length > 1)) ? yCols[1] : "to";

                var nodeData = this.data();
                var edgeData = this.data2();

                //---- at least 1 node is required (edges are optional) ----
                if ((nodeData) && (nodeData.length > 0)) {
                    //---- set up a temp text element for measuring text ----
                    var tempTextElem = vp.select(document.body).append("text");

                    //---- get theme info (fontSize) for the graph's text element ----
                    var theme = vp.currentTheme();
                    var daText = theme.getDrawingAttributes("layerGraph.text");

                    //---- update with user constants ----
                    var seriesIndex = 1;
                    var filteredData = this.info.filteredData;
                    this.addConstantDrawingAttributes(daText, seriesIndex, filteredData);

                    //---- todo: allow for mapped fontSize attribute here ----
                    tempTextElem.css("font-size", daText.textSize + "pt");

                    //tempTextElem.css("font-family", "Consolas");
                    var nodeIndexes = {};

                    var nodes = nodeData.selectWithFunc(function (data, index) {
                        var idKey = data[idCol];
                        nodeIndexes[idKey] = index;

                        tempTextElem.text(idKey);
                        var bb = vp.getBounds(tempTextElem[0]);

                        //---- adjust returned sizes for tighter fit ----
                        var bw = .90 * bb.width;
                        var bh = .45 * bb.height;

                        var shapeName = (_this._useEllipse) ? "Ellipse" : "Rectangle";

                        //---- todo: we should probably let user optionally specify node size ----
                        return {
                            width: bw, height: bh, shapeType: shapeName, userData: idKey,
                            origWidth: bw, origHeight: bh };
                    });

                    //---- remove temp label created above ----
                    tempTextElem.remove();

                    //---- build the ed list from edgeData ----
                    // EdgeData(int from, int to)
                    var edges = edgeData.selectWithFunc(function (data, index) {
                        var fromKey = data[fromCol];
                        var toKey = data[toCol];

                        var fromIndex = nodeIndexes[fromKey];
                        var toIndex = nodeIndexes[toKey];

                        return { from: fromIndex, to: toIndex };
                    });

                    //---- package up our parameters and data ----
                    var paramPackage = {
                        width: w, height: h, nodes: nodes, edges: edges
                    };

                    var strPackage = JSON.stringify(paramPackage);

                    //---- build our url with strPackage appended ----
                    //http://localhost/VuePlotServices/msaglService.aspx
                    var serviceName = (urlDir.contains("VuePlotDev")) ? "VuePlotServicesDev" : "VuePlotServices";
                    var aspUrl = urlDir + "/../../" + serviceName + "/msaglService.aspx";

                    var fullUrl = aspUrl + "?params=" + strPackage;
                    var safeUrl = encodeURI(fullUrl);

                    vp.httpRead(safeUrl, true, function (xmlhttp) {
                        //---- SUCCESS ----
                        var txt = xmlhttp.responseText;
                        var result = vp.getJsonFromResponse(txt);

                        _this.drawShapesWithLayout(result);
                    }, function (xmlhttp) {
                        //---- FAILED ----
                        alert("Error in layout service call: " + aspUrl);
                    });
                }
            };

            /// called async. when layout info has been returned from the server.  This draws both the nodes
            /// and the links (each a group with multiple child shapes).
            graphClass.prototype.drawShapesWithLayout = function (result) {
                var _this = this;
                //--- GRAPH DRAWING ----
                var nodes = result.nodes;
                var edges = result.edges;
                var arrowHeads = result.arrowHeads;

                var shapes = vp.select();
                var nodeData = this.data();
                var edgeData = this.data2();
                var layInfo = this.info;
                var filteredData = layInfo.filteredData;
                var elemTransform = "translate(" + this._padding + " " + this._padding + ")";

                //---- we only support 1 series but use multi y-cols, so set this explicitly ----
                var seriesIndex = 0;
                var seriesCount = 1;

                var theme = vp.currentTheme();

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daEdge = theme.getDrawingAttributes("layerGraph.edge", seriesIndex);
                var daText = theme.getDrawingAttributes("layerGraph.text", seriesIndex);
                var daArrow = theme.getDrawingAttributes("layerGraph.arrow", seriesIndex);
                var daNode = theme.getDrawingAttributes("layerGraph.node", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                this.addConstantDrawingAttributes(daEdge, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daText, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daArrow, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daNode, seriesIndex, filteredData);

                //---- create and position GROUP 2: EDGES and ARROW HEADS ----
                var edgeShapes = this.dataAnimMgr2().updateShapes(seriesIndex, seriesCount, function (uelem, d, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    _this.updateDrawingAttributes([daEdge, daArrow], seriesIndex, index, filteredData);

                    var data = edges[index];

                    var edgeGroup = vp.select(uelem).clear();

                    if (isNewShape) {
                        _this.setElementInfo(edgeGroup, 2, seriesIndex);
                        edgeGroup.id("edge");
                    }

                    edgeGroup.dataItem().data = edgeData[index]; // point to user data

                    //---- add EDGE path ----
                    var edge = edgeGroup.append("path").attr("d", data.pathData).transform(elemTransform).prop("updateVisualHint", "stroke");

                    _this.applyLineAttributes(edge, daEdge);

                    data = arrowHeads[index]; // point to layout data

                    //---- add ARROW HEAD path ----
                    var arrow = edgeGroup.append("path").attr("d", data.path).transform(elemTransform).prop("updateVisualHint", "fill");

                    _this.applyShapeAttributes(arrow, daArrow);
                });

                //---- create and position GROUP 1: NODES and TEXT ----
                var nodeShapes = this.dataAnimMgr().updateShapes(seriesIndex, seriesCount, function (uelem, d, index, isNewShape) {
                    var nodeGroup = vp.select(uelem).clear();

                    if (isNewShape) {
                        _this.setElementInfo(nodeGroup, 1, seriesIndex);
                        nodeGroup.id("node");
                    }

                    //---- update drawing attributes for this itemIndex ----
                    _this.updateDrawingAttributes([daNode, daText], seriesIndex, index, filteredData);

                    var data = nodes[index];
                    nodeGroup.dataItem().data = nodeData[index]; // point to user data

                    //---- add ELLIPSE and TEXT nodes ----
                    var shapeName = (_this._useEllipse) ? "ellipse" : "rect";

                    var nodeShape = nodeGroup.append(shapeName);
                    var text = nodeGroup.append("text");

                    //---- layout ELLIPSE ----
                    var w2 = data.width / 2;
                    var h2 = data.height / 2;

                    //---- current implementation of graph info doesn't work right for small size canvas, so ----
                    //---- we let user override node size when needed ----
                    if (daNode.shapeSize !== undefined) {
                        //var aspect = w2 / h2;
                        //w2 = daNode.shapeSize / 2;
                        //h2 = w2 / aspect;
                        //---- scale the existing sizes with shapeSize in this case ----
                        w2 *= daNode.shapeSize;
                        h2 *= daNode.shapeSize;
                    }

                    if (_this._useEllipse) {
                        nodeShape.attr("cx", data.x).attr("cy", data.y).attr("rx", w2).attr("ry", h2).transform(elemTransform).prop("updateVisualHint", "stroke");
                    } else {
                        nodeShape.attr("x", data.x - w2).attr("y", data.y - h2).attr("width", data.width).attr("height", data.height).transform(elemTransform).prop("updateVisualHint", "stroke");
                    }

                    _this.applyShapeAttributes(nodeShape, daNode); //, true, false);

                    //---- TODO: somehow scale text as per the layout ----
                    //var strScale = "scale(" + result.scaleX + "," + result.scaleY + "," + data.x + "," + data.y + ")";
                    //elemTransform = strScale + " " + elemTransform;
                    //---- layout TEXT ----
                    text.text(data.userData).position(data.x, data.y).transform(elemTransform).attr("cursor", "default").prop("updateVisualHint", "fill");

                    _this.applyTextAttributes(text, daText); //, false, true);
                });

                //---- tell vvPlot that we generated these shapes ----
                var allShapes = edgeShapes.merge(nodeShapes);
                this._drawParams.stdChart.addDrawnShapes(this, allShapes, seriesIndex);
            };
            return graphClass;
        })(vp.layers.baseLayerClass);
        layers.graphClass = graphClass;

        function createGraph() {
            return new graphClass();
        }
        layers.createGraph = createGraph;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// histogram.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a histogram layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a histogram layer for a plot. */
        var histogramClass = (function (_super) {
            __extends(histogramClass, _super);
            function histogramClass() {
                _super.call(this);
                //---- private state ----
                //---- todo: should we put this into vvMappings someday? ----
                this._binPercent = .03;
                this._forceCategory = false;
                this._usePercent = false;
                this._niceBuckets = false;

                var stat = vp.statBin().binPercent(this._binPercent).forceCategory(this._forceCategory).usePercent(this._usePercent).niceBuckets(this._niceBuckets);

                //---- set base class properties ----
                this.layerType("histogram").stat(stat).defaultStackType("stack").chartName("Histogram").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = true;
                this._xDefaults.percentGap = 0;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                //this._yDefaults.isDiscrete = false;
            }
            histogramClass.prototype.calcXScaleForLayer = function (descRecord) {
                var result = null;

                if (this._xDefaults.dataMin !== undefined) {
                    result = { min: this._xDefaults.dataMin, max: this._xDefaults.dataMax };
                }

                return result;
            };

            histogramClass.prototype.adjustChartOptions = function () {
                //---- make xScale CATEGORY or LINEAR ----
                var dataIsNumeric = (!this._stat.isCategory());

                this._xDefaults.isDiscrete = (!dataIsNumeric);

                if (dataIsNumeric) {
                    //---- build custom "breaks" for a category histogram ----
                    var breaks = [];
                    var data = this.data();
                    var record = null;

                    if (data) {
                        for (var i = 0; i < data.length; i++) {
                            record = data[i];
                            breaks.push(record.min);
                        }

                        //---- push last record.max ----
                        if (record) {
                            breaks.push(record.max);
                        }
                    }

                    this._xDefaults.breaks = breaks;
                    this._xAttr.onBreaksChanged();
                    //layer.xAxisInfo()
                    //    .zeroAxis(false)
                    //    .addMaxHeadroom(false)
                } else {
                    this._xDefaults.breaks = null;
                    this._xAttr.onBreaksChanged();
                }

                this._yDefaults.intOnlyBreaks = (!this._usePercent);
            };

            histogramClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HISTOGRAM ----
                //layer.info.drawBorder = true;
                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerHistogram", seriesIndex);

                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            histogramClass.prototype.onBinPercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.binPercent)) {
                    stat.binPercent(this._binPercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: binPercent ----
            histogramClass.prototype.binPercent = function (value) {
                if (arguments.length == 0) {
                    return this._binPercent;
                }

                this._binPercent = value;
                this.onBinPercentChanged();

                return this;
            };

            histogramClass.prototype.onForceCategoryChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.forceCategory)) {
                    stat.forceCategory(this._forceCategory);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: forceCategory ----
            histogramClass.prototype.forceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._forceCategory;
                }

                this._forceCategory = value;
                this.onForceCategoryChanged();

                return this;
            };

            histogramClass.prototype.onUsePercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.usePercent)) {
                    stat.usePercent(this._usePercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            histogramClass.prototype.onNiceBucketsChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.niceBuckets)) {
                    stat.niceBuckets(this._niceBuckets);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: usePercent ----
            histogramClass.prototype.usePercent = function (value) {
                if (arguments.length == 0) {
                    return this._usePercent;
                }

                this._usePercent = value;
                this.onUsePercentChanged();

                return this;
            };

            //---- property: niceBuckets ----
            histogramClass.prototype.niceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._niceBuckets;
                }

                this._niceBuckets = value;
                this.onNiceBucketsChanged();

                return this;
            };
            return histogramClass;
        })(vp.layers.columnSuperClass);
        layers.histogramClass = histogramClass;

        function createHistogram() {
            return new histogramClass();
        }
        layers.createHistogram = createHistogram;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// histogram2d.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "2d histogram" (aka bin2d or heatmap) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "2d histogram" (aka bin2d or heatmap) layer for a plot. */
        var histogram2dClass = (function (_super) {
            __extends(histogram2dClass, _super);
            function histogram2dClass() {
                _super.call(this);
                //---- private state ----
                this._xBinCount = 9;
                this._xForceCategory = false;
                this._xNiceBuckets = false;
                this._xUsePercent = false;
                this._yBinCount = 9;
                this._yForceCategory = false;
                this._yNiceBuckets = false;
                this._yUsePercent = false;

                var stat = vp.statBin2d();

                this.layerType("histogram2d").stat(stat).defaultStackType("stack").chartName("Histogram2d");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = true;
                this._xDefaults.percentGap = 0;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;
                this._xDefaults.useNiceNumbers = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["x"];

                //this._yDefaults.isDiscrete = true;
                this._yDefaults.percentGap = 0;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
                this._yDefaults.useNiceNumbers = false;

                //---- set up attributes for a histogram2d (fill color is mapped to the total counts for each bin ----
                //---- use a WHITE TO DARK RED color palette ----
                var palette = [vp.colorHelper.colors.white, vp.colorHelper.colors.darkred];
                this._attributes.fill({ colName: "value", palette: palette });
            }
            histogram2dClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.gridLinesOnTop = true;

                var xIsCategory = this._stat.xIsCategory();
                var yIsCategory = this._stat.yIsCategory();

                this._xDefaults.isDiscrete = xIsCategory;
                this._yDefaults.isDiscrete = yIsCategory;

                this._xDefaults.breaks = undefined;
                this._yDefaults.breaks = undefined;

                this._xDefaults.dataOverride = undefined;
                this._yDefaults.dataOverride = undefined;

                var data = this.data();
                if (data) {
                    //----- set up X LABELS ----
                    if (xIsCategory) {
                        //---- data for CATEGORY labels ----
                        var data = this.data();
                        var bins = data.xResult.data;
                        var xColName = this.xBeforeStat().value;
                        var categories = vp.dataSelect(bins, xColName);

                        this._xDefaults.dataOverride = categories;
                    } else {
                        //---- breaks for NUMERIC labels ----
                        this._xDefaults.breaks = this.buildBreaks(data.xResult);
                        this._xAttr.onBreaksChanged();
                    }

                    //----- set up Y LABELS ----
                    if (yIsCategory) {
                        //---- data for CATEGORY labels ----
                        var data = this.data();
                        var bins = data.yResult.data;
                        var yColName = this.yBeforeStat().value;
                        var categories = vp.dataSelect(bins, yColName);

                        this._yDefaults.dataOverride = categories;
                    } else {
                        //---- breaks for NUMERIC labels ----
                        this._yDefaults.breaks = this.buildBreaks(data.yResult);
                        this._yAttr.onBreaksChanged();
                    }
                }

                this._xDefaults.intOnlyBreaks = (!this._xUsePercent);
                this._yDefaults.intOnlyBreaks = (!this._yUsePercent);
            };

            histogram2dClass.prototype.calcXScaleForLayer = function (descRecord) {
                var result = null;

                if (this._xDefaults.dataMin !== undefined) {
                    result = { min: this._xDefaults.dataMin, max: this._xDefaults.dataMax };
                }

                return result;
            };

            histogram2dClass.prototype.calcYScaleForLayer = function (descRecord) {
                var result = null;

                if (this._yDefaults.dataMin !== undefined) {
                    result = { min: this._yDefaults.dataMin, max: this._yDefaults.dataMax };
                }

                return result;
            };

            histogram2dClass.prototype.buildBreaks = function (results) {
                var bin = null;
                var breaks = [];

                if ((results) && (results.data)) {
                    var bins = results.data;

                    for (var i = 0; i < bins.length; i++) {
                        bin = bins[i];
                        breaks.push(bin.min);
                    }

                    //---- push last record.max ----
                    if (bin) {
                        breaks.push(bin.max);
                    }
                }

                return breaks;
            };

            histogram2dClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HISTOGRAM ----
                //layer.info.drawBorder = true;
                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerHistogram2d", seriesIndex);

                var xAttrDefaults = this._attributes._x.layerDefaults;
                if (xAttrDefaults.dataOverride !== undefined) {
                    //---- get from category values ----
                    this._numCols = xAttrDefaults.dataOverride.length;
                } else {
                    //---- get from numeric breaks ----
                    this._numCols = xAttrDefaults.breaks.length - 1;
                }

                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            histogram2dClass.prototype.onStatParamsChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.xBinParams)) {
                    stat.xBinParams(new vp.binParams(this._xBinCount, this._xForceCategory, this._xUsePercent, this._xNiceBuckets));

                    stat.yBinParams(new vp.binParams(this._yBinCount, this._yForceCategory, this._yUsePercent, this._yNiceBuckets));

                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: xBinCount ----
            histogram2dClass.prototype.xBinCount = function (value) {
                if (arguments.length == 0) {
                    return this._xBinCount;
                }

                this._xBinCount = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yBinCount ----
            histogram2dClass.prototype.yBinCount = function (value) {
                if (arguments.length == 0) {
                    return this._yBinCount;
                }

                this._yBinCount = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xForceCategory ----
            histogram2dClass.prototype.xForceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._xForceCategory;
                }

                this._xForceCategory = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yForceCategory ----
            histogram2dClass.prototype.yForceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._yForceCategory;
                }

                this._yForceCategory = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xUsePercent ----
            histogram2dClass.prototype.xUsePercent = function (value) {
                if (arguments.length == 0) {
                    return this._xUsePercent;
                }

                this._xUsePercent = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yUsePercent ----
            histogram2dClass.prototype.yUsePercent = function (value) {
                if (arguments.length == 0) {
                    return this._yUsePercent;
                }

                this._yUsePercent = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xNiceBuckets ----
            histogram2dClass.prototype.xNiceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._xNiceBuckets;
                }

                this._xNiceBuckets = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yNiceBuckets ----
            histogram2dClass.prototype.yNiceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._yNiceBuckets;
                }

                this._yNiceBuckets = value;
                this.onStatParamsChanged();

                return this;
            };
            return histogram2dClass;
        })(vp.layers.tileSuperClass);
        layers.histogram2dClass = histogram2dClass;

        function createHistogram2d() {
            return new histogram2dClass();
        }
        layers.createHistogram2d = createHistogram2d;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// hLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an hLine (set of horizontal lines) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an hLine (set of horizontal lines) layer for a plot. */
        var hLineClass = (function (_super) {
            __extends(hLineClass, _super);
            //---- private state ----
            function hLineClass() {
                _super.call(this);

                this.layerType("hline").stat(vp.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");
            }
            hLineClass.prototype.adjustChartOptions = function () {
            };

            hLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HLINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerHline", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    var xMin = xScale.rangeMin();
                    var xMax = xScale.rangeMax();

                    //---- "yintercept" is an alias for "y" ----
                    var yValue = yRecord.data[index];
                    var y = yScale.flipScale(yValue);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var elem = vp.select(uelem);

                    elem.from(xMin, y).to(xMax, y).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return hLineClass;
        })(vp.layers.baseLayerClass);
        layers.hLineClass = hLineClass;

        function createHLine() {
            return new hLineClass();
        }
        layers.createHLine = createHLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// lineRange.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "line range" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "line range" layer for a plot. */
        var lineRangeClass = (function (_super) {
            __extends(lineRangeClass, _super);
            //---- private state ----
            function lineRangeClass() {
                _super.call(this);

                this.layerType("lineRange").stat(vp.statIdentity()).defaultStackType("identity").chartName("LineRange").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            lineRangeClass.prototype.adjustChartOptions = function () {
            };

            lineRangeClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            lineRangeClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- LINE RANGE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerLineRange", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var elem = g.append("line").from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return lineRangeClass;
        })(vp.layers.baseLayerClass);
        layers.lineRangeClass = lineRangeClass;

        function createLineRange() {
            return new lineRangeClass();
        }
        layers.createLineRange = createLineRange;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// mappings.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a mappings object to hold our plot/layer property/data mappings.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        var mappingsClass = (function () {
            //xEnd = null;
            //yEnd = null;
            function mappingsClass() {
                //---- public ----
                this.ctr = "vp.visuals.vvMappings";
                //---- private state ----
                this._data = undefined;
                this._vvParent = null;
                this._setterReturnValue = null;
                //---- property variables ----
                this._x = undefined;
                this._y = undefined;
                this._yMin = undefined;
                this._yMax = undefined;
                this._yOpen = undefined;
                this._yClose = undefined;
                this._xEnd = undefined;
                this._yEnd = undefined;
                //---- mapped drawing attributes ----
                this._stroke = undefined;
                this._fill = undefined;
                this._opacity = undefined;
                this._lineType = undefined;
                this._shapeType = undefined;
                this._lineSize = undefined;
                this._shapeSize = undefined;
                this._textSize = undefined;
                this._textFill = undefined;
                this._label = undefined;
                //---- constant-only (non-mapped) attributes ----
                this._hAlign = undefined;
                this._vAlign = undefined;
                this._stackType = "";
                this._key = undefined;
                this._key2 = undefined;
                this._showOutliers = false;
                this._direction = "";
                this._fillRule = "";
                //---- aliases ----
                this.yIntercept = null;
                this.xIntercept = null;
                this.slope = null;
                this._setterReturnValue = this;

                //---- pre-create X and Y attributes ----
                this.generalProp("_x", "space");
                this.generalProp("_y", "space");

                //---- assign all aliases ----
                this.yIntercept = this.y;
                this.xIntercept = this.x;
                this.slope = this.x;
            }
            mappingsClass.prototype.vvParent = function (value) {
                if (arguments.length == 0) {
                    return this._vvParent;
                }

                this._vvParent = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            mappingsClass.prototype.pop = function () {
                return this._vvParent;
            };

            mappingsClass.prototype.parentMappings = function (propName) {
                var value = undefined;

                if (this._vvParent) {
                    var layerOrPlot = this._vvParent;
                    if (layerOrPlot.vvParent) {
                        var plot = this._vvParent.vvParent();
                        if (plot) {
                            var pm = plot.mappings();
                            value = pm[propName]();
                        }
                    }
                }

                return this._setterReturnValue;
            };

            mappingsClass.prototype.markRebuildNeeded = function () {
                //---- mapping checks its parent (vvLayer or vvPlot) ----
                if (this._vvParent != null) {
                    this._vvParent.markRebuildNeeded();
                }
            };

            //---- property: x ----
            mappingsClass.prototype.x = function (firstValue) {
                return this.generalProp("_x", "space", arguments);
            };

            //---- property: y ----
            mappingsClass.prototype.y = function (firstValue) {
                return this.generalProp("_y", "space", arguments);
            };

            //---- property: setterReturnValue ----
            mappingsClass.prototype.setterReturnValue = function (value) {
                if (arguments.length == 0) {
                    return this._setterReturnValue;
                }

                this._setterReturnValue = value;

                //---- this setter is special and returns the "vvMapping" object (closure) ----
                return this;
            };

            //---- property: stroke ----
            mappingsClass.prototype.stroke = function (value) {
                return this.generalProp("_stroke", "color", arguments);
            };

            mappingsClass.prototype.capitalize = function (str) {
                return str[0].toUpperCase() + str.substr(1);
            };

            mappingsClass.prototype.generalProp = function (propName, scaleName, args) {
                var firstArg = (args && args.length) ? args[0] : undefined;

                if (firstArg && firstArg.ctr === "vp.scales.attributeClass") {
                    this[propName] = firstArg;

                    this.markRebuildNeeded();
                    return this._setterReturnValue;
                }

                //---- ensure we have a attrbute object (JIT create) ----
                var attribute = this[propName];
                if (!attribute) {
                    var scale = null;

                    if (scaleName) {
                        scale = eval("vp.scales.create" + this.capitalize(scaleName) + "()");
                    }

                    attribute = vp.scales.createAttribute(propName, scale).owner(this._vvParent);

                    var isXOrY = ((propName == "_x") || (propName == "_y"));
                    attribute.layerDefaults.useNiceNumbers = true;
                    attribute.layerDefaults.zeroAxis = isXOrY;
                    attribute.layerDefaults.addMaxHeadroom = false; // let the user adjust this when needed, but default to exact data values as nice numbers     isXOrY;

                    this[propName] = attribute;
                }

                if ((!args) || (args.length === 0)) {
                    return attribute;
                }

                if (true) {
                    args = firstArg;
                }

                attribute.quickSet(args);

                this.markRebuildNeeded();
                return this._setterReturnValue;
            };

            //---- property: fill ----
            mappingsClass.prototype.fill = function (value) {
                return this.generalProp("_fill", "color", arguments);
            };

            //---- property: lineSize ----
            mappingsClass.prototype.lineSize = function (value) {
                return this.generalProp("_lineSize", "size", arguments);
            };

            //---- property: shapeSize ----
            mappingsClass.prototype.shapeSize = function (value) {
                return this.generalProp("_shapeSize", "size", arguments);
            };

            //---- property: textSize ----
            mappingsClass.prototype.textSize = function (value) {
                return this.generalProp("_textSize", "textSize", arguments);
            };

            //---- property: textFill ----
            mappingsClass.prototype.textFill = function (value) {
                return this.generalProp("_textFill", "color", arguments);
            };

            //---- property: lineType ----
            mappingsClass.prototype.lineType = function (value) {
                return this.generalProp("_lineType", "lineType", arguments);
            };

            //---- property: opacity ----
            mappingsClass.prototype.opacity = function (value) {
                return this.generalProp("_opacity", "opacity", arguments);
            };

            //---- property: stackType ----
            mappingsClass.prototype.stackType = function (value) {
                if (arguments.length == 0) {
                    return this._stackType;
                }

                this._stackType = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: key ----
            mappingsClass.prototype.key = function (value) {
                if (arguments.length == 0) {
                    return this._key;
                }

                this._key = value;

                if (this._vvParent) {
                    this._vvParent.onKeyChanged();
                }

                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: key2 ----
            mappingsClass.prototype.key2 = function (value) {
                if (arguments.length == 0) {
                    return this._key2;
                }

                this._key2 = value;

                if (this._vvParent) {
                    this._vvParent.onKey2Changed();
                }

                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: showOutliers ----
            mappingsClass.prototype.showOutliers = function (value) {
                if (arguments.length == 0) {
                    return this._showOutliers;
                }

                this._showOutliers = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: label ----
            mappingsClass.prototype.label = function (value) {
                return this.generalProp("_label", null, arguments);
            };

            //---- property: hAlign ----
            mappingsClass.prototype.hAlign = function (value) {
                if (arguments.length == 0) {
                    return this._hAlign;
                }

                this._hAlign = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: vAlign ----
            mappingsClass.prototype.vAlign = function (value) {
                if (arguments.length == 0) {
                    return this._vAlign;
                }

                this._vAlign = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: yMin ----
            mappingsClass.prototype.yMin = function (value) {
                return this.generalProp("_yMin", "space", arguments);
            };

            //---- property: yMax ----
            mappingsClass.prototype.yMax = function (value) {
                return this.generalProp("_yMax", "space", arguments);
            };

            //---- property: xEnd ----
            mappingsClass.prototype.xEnd = function (value) {
                return this.generalProp("_xEnd", "space", arguments);
            };

            //---- property: yEnd ----
            mappingsClass.prototype.yEnd = function (value) {
                return this.generalProp("_yEnd", "space", arguments);
            };

            //---- property: yOpen ----
            mappingsClass.prototype.yOpen = function (value) {
                return this.generalProp("_yOpen", "space", arguments);
            };

            //---- property: yClose ----
            mappingsClass.prototype.yClose = function (value) {
                return this.generalProp("_yClose", "space", arguments);
            };

            //---- property: direction ----
            mappingsClass.prototype.direction = function (value) {
                if (arguments.length == 0) {
                    return this._direction;
                }

                this._direction = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: fillRule ----
            mappingsClass.prototype.fillRule = function (value) {
                if (arguments.length == 0) {
                    return this._fillRule;
                }

                this._fillRule = value;
                this.markRebuildNeeded();

                return this._setterReturnValue;
            };

            //---- property: shapeType ----
            mappingsClass.prototype.shapeType = function (value) {
                return this.generalProp("_shapeType", "shape", arguments);
            };
            return mappingsClass;
        })();
        layers.mappingsClass = mappingsClass;

        function createMappings() {
            return new mappingsClass();
        }
        layers.createMappings = createMappings;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// openClose.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an "open close" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an "open close" layer for a plot. */
        var openCloseClass = (function (_super) {
            __extends(openCloseClass, _super);
            //---- private state ----
            function openCloseClass() {
                _super.call(this);

                this.layerType("openClose").stat(vp.statIdentity()).defaultStackType("identity").chartName("OpenClose").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            openCloseClass.prototype.adjustChartOptions = function () {
            };

            openCloseClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            openCloseClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- OPEN CLOSE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerOpenClose", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var yOpenCol = attributes._yOpen.getAfterStatsPropName(seriesIndex);
                    var yOpenValue = record[yOpenCol];

                    var yCloseCol = attributes._yClose.getAfterStatsPropName(seriesIndex);
                    var yCloseVal = record[yCloseCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);
                    var yOpen = yScale.flipScale(yOpenValue);
                    var yClose = yScale.flipScale(yCloseVal);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line1 = g.append("line").from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    var barSize2 = da.shapeSize;

                    //---- open line ----
                    var line2 = g.append("line").from(x - barSize2, yOpen).to(x, yOpen).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    //---- close line ----
                    var line3 = g.append("line").from(x, yClose).to(x + barSize2, yClose).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line3, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                        layer.setElementInfo(line3, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return openCloseClass;
        })(vp.layers.baseLayerClass);
        layers.openCloseClass = openCloseClass;

        function createOpenClose() {
            return new openCloseClass();
        }
        layers.createOpenClose = createOpenClose;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// path.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a path plot layer (a set of lines following a path) for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var pathClass = (function (_super) {
            __extends(pathClass, _super);
            //---- private state ----
            function pathClass() {
                _super.call(this);

                this.layerType("path").stat(vp.statIdentity()).defaultStackType("stack").chartName("Path").newTagOrFunc("line");
            }
            pathClass.prototype.adjustChartOptions = function () {
                //options.xScaleOverride = "space";
                this._xDefaults.isDiscrete = false;
            };

            /// public drawShapes() - draw line plot.
            pathClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };
            return pathClass;
        })(vp.layers.lineSuperClass);
        layers.pathClass = pathClass;

        function createPath() {
            return new pathClass();
        }
        layers.createPath = createPath;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// pieSlice.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a "pie chart" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** plots a "pie chart" layer for a plot. */
        var pieSliceClass = (function (_super) {
            __extends(pieSliceClass, _super);
            function pieSliceClass() {
                _super.call(this);
                //---- private state ----
                this._innerRadius = 0;
                this._spacingRadius = 0;

                this.layerType("pieSlice").stat(vp.statIdentity()).defaultStackType("dodge").chartName("Pie").newTagOrFunc("path");
            }
            pieSliceClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;

                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            pieSliceClass.prototype.placeOnCircle = function (ptCenter, radius, rotationDegrees) {
                rotationDegrees -= 90; // make 0 degrees start "12:00" position

                var radians = rotationDegrees * (Math.PI / 180);

                var xEnd = ptCenter.x + Math.cos(radians) * radius;
                var yEnd = ptCenter.y + Math.sin(radians) * radius;

                return { x: xEnd, y: yEnd };
            };

            pieSliceClass.prototype.makeArc = function (arcDegrees, sweepClockwise, radius, ptEnd) {
                var isLarge = (arcDegrees >= 180) ? 1 : 0;
                var sweepFlag = (sweepClockwise) ? 1 : 0;

                var path = "A" + radius + "," + radius + ",0," + isLarge + "," + sweepFlag + "," + ptEnd.x + "," + ptEnd.y + " ";

                return path;
            };

            pieSliceClass.prototype.pointAlongLine = function (ptStart, ptEnd, dist) {
                var x = ptStart.x + dist * (ptEnd.x - ptStart.x);
                var y = ptStart.y + dist * (ptEnd.y - ptStart.y);

                var pt = { x: x, y: y };
                return pt;
            };

            pieSliceClass.prototype.getPieSlicePath = function (xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation) {
                var ptCenter = { x: xCenter, y: yCenter };
                var ptStart = { x: xCenter, y: yCenter };

                if (innerRadius > 0) {
                    //ptStart.x += innerRadius;
                    ptStart = this.placeOnCircle(ptCenter, innerRadius, rotation);
                }

                var path = "M" + ptStart.x + "," + ptStart.y + " ";

                var fullPie = false;
                if (angleDegrees >= 360) {
                    fullPie = true;
                    angleDegrees = 360;
                }

                if (!fullPie) {
                    //---- first line (extends to the start of the arc) ----
                    var ptArc = this.placeOnCircle(ptCenter, outerRadius, rotation);

                    path += "L" + ptArc.x + "," + ptArc.y + " ";
                }

                //---- the arc ----
                var ptArcEnd = this.placeOnCircle(ptCenter, outerRadius, rotation + angleDegrees);

                var arc = this.makeArc(angleDegrees, true, outerRadius, ptArcEnd);
                path += arc;

                if (innerRadius > 0) {
                    var ptEnd = this.placeOnCircle(ptCenter, innerRadius, rotation + angleDegrees);

                    if (fullPie) {
                        //---- need to move to ptEnd ---
                        path += "M" + ptEnd.x + "," + ptEnd.y + " ";
                    } else {
                        //---- draw a line to ptEnd ----
                        path += "L" + ptEnd.x + "," + ptEnd.y + " ";
                    }

                    //---- reverse, innner arc ----
                    var arc2 = this.makeArc(angleDegrees, false, innerRadius, ptStart);
                    path += arc2;
                }

                path += "Z"; // close path

                //---- test ----
                //path = "M 100 100 L 300 100 L 200 300 z";
                return path;
            };

            /// public drawShapes() - draw area plot.
            pieSliceClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerPieSlice", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var left = xScale.rangeMin();
                var right = xScale.rangeMax();
                var top = yScale.rangeMin();
                var bottom = yScale.rangeMax();

                var margin = 6;
                var rotation = 0;
                var xCenter = (left + right) / 2;
                var yCenter = (top + bottom) / 2;

                var seriesCount = layInfo.seriesCount;
                var finalRadius = Math.min(right - left, bottom - top) / 2;
                finalRadius -= margin;

                var availRadius = Math.max(0, finalRadius - this._innerRadius);
                var eachRadius = availRadius / seriesCount;
                var myRadius = (seriesCount > 1) ? Math.max(0, eachRadius - this._spacingRadius) : eachRadius;

                var innerRadius = this._innerRadius + seriesIndex * eachRadius;
                var outerRadius = innerRadius + myRadius;

                //---- sum up all data values for this series ----
                var seriesSum = yRecord.data.sum();

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var dataValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    var angle = 360 * (dataValue / seriesSum);

                    var path = _this.getPieSlicePath(xCenter, yCenter, innerRadius, outerRadius, angle, rotation);
                    elem.attr("d", path);

                    //if (pi.stackType == "stack")
                    //{
                    //    var adjValue = dataValue + pi.itemAccums[index];
                    //    //---- starts at dataValue, offset by previous..  height doesn't change ----
                    //    y = yScale.flipScale(adjValue);
                    //    yZero = yScale.flipScale(pi.itemAccums[index]);
                    //    pi.itemAccums[index] = adjValue;
                    //}
                    //---- apply LAYOUT attributes ----
                    elem.prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    rotation += angle;
                });

                return shapes;
            };

            /** the radius of the center hole in the pie slice. */
            pieSliceClass.prototype.innerRadius = function (value) {
                if (arguments.length == 0) {
                    return this._innerRadius;
                }

                this._innerRadius = value;

                return this;
            };

            /** the space between rings, for multiple series */
            pieSliceClass.prototype.spacingRadius = function (value) {
                if (arguments.length == 0) {
                    return this._spacingRadius;
                }

                this._spacingRadius = value;

                return this;
            };
            return pieSliceClass;
        })(vp.layers.baseLayerClass);
        layers.pieSliceClass = pieSliceClass;

        function createPieSlice() {
            return new pieSliceClass();
        }
        layers.createPieSlice = createPieSlice;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// plotDefaults.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a structure to hold system-defined default values for the plot object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        /** default settings for the plot object (set internally).  User settings take precedence over these values.  */
        var plotDefaults = (function () {
            function plotDefaults() {
                this.shapesEnterFromBottom = false;
                this.showLegend = true;
                this.gridLinesOnTop = false;
                this.showXAxis = true;
                this.showYAxis = true;
                this.showXTitle = true;
                this.showYTitle = true;
                this.showXGridLines = true;
                this.showYGridLines = true;
            }
            return plotDefaults;
        })();
        layers.plotDefaults = plotDefaults;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// point.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "scatter plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "scatter plot" layer for a plot. */
        var pointClass = (function (_super) {
            __extends(pointClass, _super);
            function pointClass() {
                _super.call(this);
                //---- private state ----
                this._da = null;

                this._dodgeAxis = 0 /* none */;

                this.layerType("point").stat(vp.statIdentity()).defaultStackType("identity").chartName("Scatter").newTagOrFunc(vp.cb(this, this.createElem));

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
            }
            pointClass.prototype.createElem = function (dataRecord, index, seriesIndex, filteredData) {
                //da = vp.currentTheme().getDrawingAttributes("layerPoint", seriesIndex);
                var da = this._da;

                //---- update drawing attributes for this itemIndex ----
                this.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                //var shapeType = layer.getItemShape(seriesIndex, index, filteredData);
                var shapeType = da.shapeType;

                var elem = null;
                var shapeName = null;
                var pathData = null;

                if (vp.isNumber(shapeType)) {
                    if (shapeType == vp.shapeType.circle) {
                        shapeName = "circle";
                    } else if (shapeType == vp.shapeType.square) {
                        shapeName = "rect";
                    } else {
                        //---- path ----
                        shapeName = "path";
                    }
                } else {
                    elem = shapeName = "text";
                }

                elem = vp.createSvg(shapeName);
                elem.shapeType = shapeType;

                /// note: for path shapes, we generate data to fit desired bounds.  We avoid the
                /// alternate method of applying a transform because it conflicts with animation
                /// transforms and it scales the line width (which we don't want).
                return elem;
            };

            pointClass.prototype.adjustChartOptions = function () {
            };

            pointClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //--- POINT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- is scale one of the category types? ----
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- should scale use DATA or INDEX? ----
                var xUsesIndex = (xScale.mapType() == vp.MapType.category);
                var yUsesIndex = (yScale.mapType() == vp.MapType.category);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerPoint", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);
                this._da = da;

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var xValue = (xUsesIndex) ? (index) : xRecord.data[index];
                    var yValue = (yUsesIndex) ? (index) : yRecord.data[index];

                    //var xValue = xRecord.data[index];
                    //var yValue = yRecord.data[index];
                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    //---- even though we don't stack scatter plots, this layer is also used to add ----
                    //---- markers to LINE layers, so we DO honor the stackType ----
                    if (pi.stackType == "stack") {
                        var adjValue = yValue + pi.itemAccums[index];

                        //---- starts at dataValue, offset by previous..  height doesn't change ----
                        y = yScale.flipScale(adjValue);

                        pi.itemAccums[index] = adjValue;
                    } else if (pi.stackType == "fill") {
                        var newAccum = pi.itemAccums[index] + yValue;
                        var adjValue2 = newAccum / pi.itemTotals[index];
                        y = yScale.flipScale(adjValue2);

                        var adjHeight = yValue / pi.itemTotals[index];

                        pi.itemAccums[index] = newAccum;
                    } else if (pi.stackType == "dodge") {
                        if (_this._dodgeAxis == 1 /* x */) {
                            x = xScale.scale(xValue, seriesIndex);
                        }
                        if (_this._dodgeAxis == 2 /* y */) {
                            y = yScale.flipScale(yValue, seriesIndex);
                        }
                    }

                    if (xIsCategoryScale) {
                        //---- center shape on width of X band ----
                        x += xScale.itemWidth() / 2;
                    }

                    if (yIsCategoryScale) {
                        //---- center shape on height of Y band ----
                        y += yScale.itemWidth() / 2;
                    }

                    var shapeType = uelem.shapeType;
                    var isFilled = false;
                    var isStroked = true;

                    var itemSize = da.shapeSize;
                    var itemSize2 = itemSize / 2;

                    //---- handle all circle-based shapes ----
                    if (shapeType == vp.shapeType.circle) {
                        elem.attr("cx", x).attr("cy", y).attr("r", itemSize / 2);
                    } else if (vp.isString(shapeType)) {
                        //---- text ----
                        elem.attr("x", x - itemSize2 + 2).attr("y", y + itemSize2 - 1).text(shapeType).attr("font-size", itemSize);
                    } else if (uelem.tagName == "path") {
                        var pathData = vp.layers.getPathDataForShape(shapeType, x, y, da.shapeSize, itemSize);
                        vp.attr(uelem, "d", pathData);
                    } else {
                        //---- square ----
                        elem.bounds(x - itemSize2, y - itemSize2, itemSize, itemSize);
                    }

                    isStroked = (da.stroke != "transparent");
                    isFilled = (da.fill != "transparent");

                    if ((isStroked) && (isFilled)) {
                        elem.prop("updateVisualHint", "fill");
                    } else if (isStroked) {
                        elem.prop("updateVisualHint", "stroke");
                    } else {
                        elem.prop("updateVisualHint", "fill");
                    }

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return pointClass;
        })(vp.layers.baseLayerClass);
        layers.pointClass = pointClass;

        function createPoint() {
            return new pointClass();
        }
        layers.createPoint = createPoint;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));

var vp;
(function (vp) {
    //---- outside of layers namespace ----
    (function (shapeType) {
        shapeType[shapeType["asterisk"] = 0] = "asterisk";
        shapeType[shapeType["circle"] = 1] = "circle";
        shapeType[shapeType["diamond"] = 2] = "diamond";
        shapeType[shapeType["hexagram"] = 3] = "hexagram";
        shapeType[shapeType["pentagram"] = 4] = "pentagram";
        shapeType[shapeType["plus"] = 5] = "plus";
        shapeType[shapeType["plusInDiamond"] = 6] = "plusInDiamond";
        shapeType[shapeType["plusInCircle"] = 7] = "plusInCircle";
        shapeType[shapeType["plusInSquare"] = 8] = "plusInSquare";
        shapeType[shapeType["square"] = 9] = "square";
        shapeType[shapeType["triangleUp"] = 10] = "triangleUp";
        shapeType[shapeType["triangleDown"] = 11] = "triangleDown";
        shapeType[shapeType["triangleLeft"] = 12] = "triangleLeft";
        shapeType[shapeType["triangleRight"] = 13] = "triangleRight";
        shapeType[shapeType["triangleUpDown"] = 14] = "triangleUpDown";
        shapeType[shapeType["triangleInSquare"] = 15] = "triangleInSquare";
        shapeType[shapeType["x"] = 16] = "x";
        shapeType[shapeType["xInCircle"] = 17] = "xInCircle";
        shapeType[shapeType["xInSquare"] = 18] = "xInSquare";
    })(vp.shapeType || (vp.shapeType = {}));
    var shapeType = vp.shapeType;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// pointRange.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "point range" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "point range" layer for a plot. */
        var pointRangeClass = (function (_super) {
            __extends(pointRangeClass, _super);
            //---- private state ----
            function pointRangeClass() {
                _super.call(this);

                this.layerType("pointRange").stat(vp.statIdentity()).defaultStackType("identity").chartName("PointRange").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            pointRangeClass.prototype.adjustChartOptions = function () {
            };

            pointRangeClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- POINT RANGE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerPointRange", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line = g.append("line").from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    //---- circle ----
                    var circle = g.append("circle").attr("cx", x).attr("cy", y).attr("r", da.shapeSize / 2).prop("updateVisualHint", "stroke");

                    layer.applyShapeAttributes(circle, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(circle, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return pointRangeClass;
        })(vp.layers.baseLayerClass);
        layers.pointRangeClass = pointRangeClass;

        function createPointRange() {
            return new pointRangeClass();
        }
        layers.createPointRange = createPointRange;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// polygon.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a polygon layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a polygon layer for a plot. */
        var polygonClass = (function (_super) {
            __extends(polygonClass, _super);
            //---- private state ----
            function polygonClass() {
                _super.call(this);

                this.layerType("area").stat(vp.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = false;
            }
            polygonClass.prototype.adjustChartOptions = function () {
                this._xDefaults.isDiscrete = false;
            };

            polygonClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            /// public drawShapes() - draw polygon plot.
            polygonClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;
                var pts = "";
                var fillRule = layer.attributes().fillRule().value;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerPolygon", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var xValue = xRecord.data[index];
                    var yValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    pts = _this.addPoint(pts, x, y);

                    var lastPt = (index == filteredData.length - 1);
                    if (lastPt) {
                        //---- apply LAYOUT attributes ----
                        elem.attr("points", pts);

                        elem.prop("updateVisualHint", "both");

                        layer.applyShapeAttributes(elem, da);

                        if (isNewShape) {
                            layer.setElementInfo(elem, 1, seriesIndex);
                        }
                    }
                });

                return shapes;
            };
            return polygonClass;
        })(vp.layers.baseLayerClass);
        layers.polygonClass = polygonClass;

        function createPolygon() {
            return new polygonClass();
        }
        layers.createPolygon = createPolygon;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// ribbon.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a ribbon layer of a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var ribbonClass = (function (_super) {
            __extends(ribbonClass, _super);
            //---- private state ----
            function ribbonClass() {
                _super.call(this);

                this.layerType("ribbon").stat(vp.statIdentity()).defaultStackType("identity").chartName("Ribbon").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            ribbonClass.prototype.adjustChartOptions = function () {
            };

            ribbonClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            ribbonClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            ribbonClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //--- RIBBON ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                var lastx = 0;
                var lastyMin = 0;
                var lastyMax = 0;
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var dax = (da) ? da : vp.currentTheme().getDrawingAttributes("layerRibbon", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(dax, seriesIndex, filteredData);

                var attributes = layer.attributes();
                var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var g = vp.select(uelem);
                    g.clear();

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(dax, seriesIndex, index, filteredData);

                    var itemOpacity = layer.getItemOpacity(seriesIndex, index, filteredData, dax.opacity);

                    var record = filteredData[index];

                    //---- NOTE: ribbon only supports "dodge" stackType ----
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var x = xScale.scale(xValue);
                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    var yMinValue = record[yMinCol];
                    var yMaxValue = record[yMaxCol];
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (index == 0) {
                        lastx = x;
                        lastyMin = yMin;
                        lastyMax = yMax;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        var lastxValue = (xIsCategoryScale) ? (index - 1) : xRecord.data[index - 1];

                        lastx = xScale.scale(lastxValue);
                        if (xIsCategoryScale) {
                            lastx += xScale.itemWidth() / 2;
                        }

                        var lastRecord = filteredData[index - 1];

                        var lastyMinValue = lastRecord[yMinCol];
                        var lastyMaxValue = lastRecord[yMaxCol];

                        lastyMin = yScale.flipScale(lastyMinValue);
                        lastyMax = yScale.flipScale(lastyMaxValue);
                    }

                    firstUpdateCall = false;

                    //---- build string of points ----
                    var points = "";
                    points = _this.addPoint(points, lastx, lastyMin);
                    points = _this.addPoint(points, lastx, lastyMax);
                    points = _this.addPoint(points, x, yMax);
                    points = _this.addPoint(points, x, yMin);

                    //---- ribbon polygon ----
                    var elem = g.append("polygon").attr("points", points).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, dax);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lastyMin = yMin;
                    lastyMax = yMax;
                });

                return shapes;
            };
            return ribbonClass;
        })(vp.layers.baseLayerClass);
        layers.ribbonClass = ribbonClass;

        function createRibbon() {
            return new ribbonClass();
        }
        layers.createRibbon = createRibbon;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// segment.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a segment layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a set of lines as a layer of a plot. */
        var segmentClass = (function (_super) {
            __extends(segmentClass, _super);
            //---- private state ----
            function segmentClass() {
                _super.call(this);

                this.layerType("segment").stat(vp.statIdentity()).defaultStackType("stack").chartName("Segment").newTagOrFunc("line");
            }
            segmentClass.prototype.calcXScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var xMinCol = attributes._x.getAfterStatsPropName(0);
                var xMaxCol = attributes._xEnd.getAfterStatsPropName(0);

                var xMin = data.min(function (data) {
                    return data[xMinCol];
                });
                var xMax = data.max(function (data) {
                    return data[xMaxCol];
                });

                return { min: xMin, max: xMax };
            };

            segmentClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._y.getAfterStatsPropName(0);
                var yMaxCol = attributes._yEnd.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            segmentClass.prototype.adjustChartOptions = function () {
            };

            /// public drawShapes() - draw LAYER SEGMENT.
            segmentClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerSegment", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var attributes = layer.attributes();

                    //var itemOpacity = layer.getItemOpacity(seriesIndex, index, filteredData);
                    var xEndCol = attributes._xEnd.getAfterStatsPropName(seriesIndex);
                    var yEndCol = attributes._yEnd.getAfterStatsPropName(seriesIndex);

                    var xValue = xRecord.data[index];
                    var yValue = yRecord.data[index];

                    var xEndValue = filteredData[index][xEndCol];
                    var yEndValue = filteredData[index][yEndCol];

                    var x = xScale.scale(xValue);
                    var xEnd = xScale.scale(xEndValue);
                    var y = yScale.flipScale(yValue);
                    var yEnd = yScale.flipScale(yEndValue);

                    //---- apply LAYOUT attributes ----
                    elem.from(x, y).to(xEnd, yEnd);

                    //---- apply BASIC attributes ----
                    elem.prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return segmentClass;
        })(vp.layers.baseLayerClass);
        layers.segmentClass = segmentClass;

        function createSegment() {
            return new segmentClass();
        }
        layers.createSegment = createSegment;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// shapeData.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///    - uses to create paths for our set of shapeTypes.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        function getPathDataForShape(shapeType, x, y, w, h) {
            var move = function (str, x, y) {
                str += " M " + x + " " + y;
                return str;
            };

            var line = function (str, x, y) {
                str += " L " + x + " " + y;
                return str;
            };

            var circle = function (str, cx, cy, r) {
                str += " M " + (cx - r) + " " + cy + " a " + r + " " + r + " 0 1 0 " + (2 * r) + " 0" + " a " + r + " " + r + " 0 1 0 " + (-2 * r) + " 0";

                return str;
            };

            var close = function (str) {
                str += " z";
                return str;
            };

            var d = "";

            //---- scale our 0..1 vars as per the desired bounds ----
            var x0 = x - w / 2;
            var x1 = x + w / 2;
            var x5 = x;

            var y0 = y - h / 2;
            var y1 = y + h / 2;
            var y5 = y;

            switch (shapeType) {
                case 10 /* triangleUp */: {
                    //---- triangle ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);
                    break;
                }

                case 5 /* plus */: {
                    //---- plus sign ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 16 /* x */: {
                    //---- big X ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);
                    break;
                }

                case 2 /* diamond */: {
                    //---- diamond ----
                    d = move(d, x5, y0);
                    d = line(d, x0, y5);
                    d = line(d, x5, y1);
                    d = line(d, x1, y5);
                    d = line(d, x5, y0);
                    d = close(d);
                    break;
                }

                case 11 /* triangleDown */: {
                    //---- upside down triangle ----
                    d = move(d, x0, y0);
                    d = line(d, x5, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 12 /* triangleLeft */: {
                    //---- left pointing triangle ----
                    d = move(d, x5, y0);
                    d = line(d, x5, y1);
                    d = line(d, x0, y5);
                    d = close(d);
                    break;
                }

                case 13 /* triangleRight */: {
                    //---- right pointing triangle ----
                    d = move(d, x5, y0);
                    d = line(d, x5, y1);
                    d = line(d, x1, y5);
                    d = close(d);
                    break;
                }

                case 4 /* pentagram */: {
                    //---- for pentagram ----
                    var y3 = y0 + .36 * h;
                    var y6 = y0 + .62 * h;
                    var y7 = y0 + .76 * h;

                    var x2 = x0 + .19 * w;
                    var x3 = x0 + .31 * w;
                    var x4 = x0 + .37 * w;
                    var x6 = x0 + .63 * w;
                    var x7 = x0 + .69 * w;
                    var x8 = x0 + .85 * w;

                    //---- 5 point star ----
                    d = move(d, x5, y0);
                    d = line(d, x6, y3);
                    d = line(d, x1, y3);
                    d = line(d, x7, y6);
                    d = line(d, x8, y1);
                    d = line(d, x5, y7);
                    d = line(d, x2, y1);
                    d = line(d, x3, y6);
                    d = line(d, x0, y3);
                    d = line(d, x4, y3);
                    d = close(d);
                    break;
                }

                case 3 /* hexagram */: {
                    //---- for hexagram ----
                    var y2 = y0 + .25 * h;
                    var y7 = y0 + .75 * h;

                    var x2 = x0 + .21 * w;
                    var x3 = x0 + .36 * w;
                    var x6 = x0 + .64 * w;
                    var x8 = x0 + .80 * w;

                    //---- 5 point star ----
                    d = move(d, x5, y0);
                    d = line(d, x6, y2);
                    d = line(d, x1, y2);
                    d = line(d, x8, y5);
                    d = line(d, x1, y7);
                    d = line(d, x6, y7);
                    d = line(d, x5, y1);
                    d = line(d, x3, y7);
                    d = line(d, x0, y7);
                    d = line(d, x2, y5);
                    d = line(d, x0, y2);
                    d = line(d, x3, y2);
                    d = close(d);
                    break;
                }

                case 18 /* xInSquare */: {
                    //---- X in square ----
                    //---- X-part ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);

                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 0 /* asterisk */: {
                    //---- asterisk ----
                    //---- make diagonals a bit smaller ----
                    var x2 = x0 + .2 * w;
                    var x8 = x1 - .2 * w;

                    var y2 = y0 + .2 * h;
                    var y8 = y1 - .2 * h;

                    d = move(d, x5, y0);
                    d = line(d, x5, y1);

                    d = move(d, x8, y2);
                    d = line(d, x2, y8);

                    d = move(d, x1, y5);
                    d = line(d, x0, y5);

                    d = move(d, x8, y8);
                    d = line(d, x2, y2);
                    break;
                }

                case 6 /* plusInDiamond */: {
                    //---- diamond with a plus inside ----
                    //---- diamond-part ----
                    d = move(d, x5, y0);
                    d = line(d, x0, y5);
                    d = line(d, x5, y1);
                    d = line(d, x1, y5);
                    d = line(d, x5, y0);
                    d = close(d);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 7 /* plusInCircle */: {
                    //---- plus in a circle ----
                    //---- circle-part ----
                    d = circle(d, x5, y5, w / 2);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 14 /* triangleUpDown */: {
                    //---- 2 triangles ----
                    //---- triangle-part ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);

                    //---- down-triangle-part ----
                    d = move(d, x0, y0);
                    d = line(d, x5, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 8 /* plusInSquare */: {
                    //---- square with plus ----
                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 17 /* xInCircle */: {
                    //---- X in a circle ----
                    //---- circle-part ----
                    d = circle(d, x5, y5, w / 2);

                    //---- X-part ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);
                    break;
                }

                case 15 /* triangleInSquare */: {
                    //---- triangle in a square ----
                    //---- triangle-part ----
                    //---- triangle-part ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);

                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }
            }

            return d;
        }
        layers.getPathDataForShape = getPathDataForShape;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// spaceFill.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a space filling layer to draw treemaps and other space filling plots.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a space filling layer to draw treemaps and other space filling plots. */
        var spaceFillClass = (function (_super) {
            __extends(spaceFillClass, _super);
            //---- private state ----
            function spaceFillClass() {
                _super.call(this);

                this.layerType("spaceFill").stat(vp.statSpaceFill()).defaultStackType("stack").chartName("SpaceFill").newTagOrFunc("rect");
            }
            spaceFillClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showYTitle = false;
                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            /// public drawShapes() - layout and draw space fill rectangles.
            spaceFillClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerSpaceFill", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- for SPACEFILL LAYER: we don't use x/y scales; we layout directly in pixel space ----
                var xMin = xScale.rangeMin();
                var xMax = xScale.rangeMax();

                var yMin = yScale.rangeMin();
                var yMax = yScale.rangeMax();

                var xRange = xMax - xMin;
                var yRange = yMax - yMin;

                //var rects = computeRects(xRecord.data, bounds, da, filteredData);
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    //---- get layout of element in unit bounds ----
                    var ub = filteredData[index]._bounds;

                    //---- scale to screen bounds ----
                    var x = xMin + ub.left * xRange;
                    var y = yMin + ub.top * yRange;
                    var w = xMin + ub.width * xRange;
                    var h = yMin + ub.height * yRange;

                    //---- layout elem ----
                    elem.attr("x", x).attr("y", y).attr("width", w).attr("height", h).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            //---- property: startLoc ----
            spaceFillClass.prototype.startLoc = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.startLoc();
                }

                stat.startLoc(value);
                return this;
            };

            //---- property: chunking ----
            spaceFillClass.prototype.chunking = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.chunking();
                }

                stat.chunking(value);
                return this;
            };

            //---- property: phrasing ----
            spaceFillClass.prototype.phrasing = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.phrasing();
                }

                stat.phrasing(value);
                return this;
            };
            return spaceFillClass;
        })(vp.layers.baseLayerClass);
        layers.spaceFillClass = spaceFillClass;

        function createSpaceFill() {
            return new spaceFillClass();
        }
        layers.createSpaceFill = createSpaceFill;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// stem.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a stem layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a stem layer for a plot. */
        var stemClass = (function (_super) {
            __extends(stemClass, _super);
            //---- private state ----
            function stemClass() {
                _super.call(this);

                this.layerType("stem").stat(vp.statIdentity()).defaultStackType("identity").chartName("Stem").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            stemClass.prototype.adjustChartOptions = function () {
            };

            stemClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- STEM ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerStem", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yZero = yScale.flipScale(0);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- line from zero to Y ----
                    var line = g.append("line").from(x, yZero).to(x, y).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    //---- circle ----
                    var circle = g.append("circle").attr("cx", x).attr("cy", y).attr("r", da.shapeSize / 2).prop("updateVisualHint", "stroke");

                    layer.applyShapeAttributes(circle, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(circle, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return stemClass;
        })(vp.layers.baseLayerClass);
        layers.stemClass = stemClass;

        function createStem() {
            return new stemClass();
        }
        layers.createStem = createStem;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// step.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a step layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var stepClass = (function (_super) {
            __extends(stepClass, _super);
            //---- private state ----
            function stepClass() {
                _super.call(this);

                this.layerType("step").stat(vp.statIdentity()).defaultStackType("identity").chartName("Step").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            stepClass.prototype.adjustChartOptionsfunction = function () {
            };

            stepClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- STEP ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                var lastx = 0;
                var lasty = 0;

                //---- get stair direction ("vh" or "hv") ----
                var direction = layer.attributes()._direction;
                direction = (direction === undefined) ? "vh" : direction;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerStep", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    //.attr("opacity", itemOpacity)
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = yRecord.data[index];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                    }

                    var line1 = null;
                    var line2 = null;

                    if (direction == "vh") {
                        //---- step vertical ----
                        line1 = g.append("line").from(lastx, lasty).to(lastx, y);

                        //---- step horizontal ----
                        line2 = g.append("line").from(lastx, y).to(x, y);
                    } else {
                        //---- step horizontal ----
                        line1 = g.append("line").from(lastx, lasty).to(x, lasty);

                        //---- step vertical ----
                        line2 = g.append("line").from(x, lasty).to(x, y);
                    }

                    line1.prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    line2.prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                });

                return shapes;
            };
            return stepClass;
        })(vp.layers.baseLayerClass);
        layers.stepClass = stepClass;

        function createStep() {
            return new stepClass();
        }
        layers.createStep = createStep;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// streamGraph.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a stream plot layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a stream plot layer for a plot. */
        var streamGraphClass = (function (_super) {
            __extends(streamGraphClass, _super);
            function streamGraphClass() {
                _super.call(this);
                //---- private state ----
                this._useSmoothing = false;
                this._lastTopSegments = null;

                this.layerType("streamGraph").stat(vp.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                //---- defaults for X scale/axis ----
                //this._xDefaults.scaleDefault("date")
                this._xDefaults.isDiscrete = true; // doesn't draw correctly unless X values are evenly spaced
                this._xDefaults.dateFormat = "string";

                this._xDefaults.colNames = ["x"];
                this._xDefaults.zeroAxis = false;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._xDefaults.isDiscrete = false;
                this._xDefaults.colNames = ["y"];

                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showYGridLines = false;
            }
            streamGraphClass.prototype.adjustChartOptions = function () {
            };

            streamGraphClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            streamGraphClass.prototype.addPoints = function (str, pts, reverseOrder) {
                if (pts) {
                    if (reverseOrder) {
                        for (var i = pts.length - 1; i >= 0; i--) {
                            var pt = pts[i];
                            str += pt.x + "," + pt.y + " ";
                        }
                    } else {
                        for (var i = 0; i < pts.length; i++) {
                            var pt = pts[i];
                            str += pt.x + "," + pt.y + " ";
                        }
                    }
                }

                return str;
            };

            /// public drawShapes() - draw streamPlot.
            /// series are drawn from top to bottom.
            streamGraphClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerStreamGraph", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- remember the x and y values that we generate for later interpolation ----
                var xa = [];
                var ya = [];
                var yz = [];

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var xDataValue = xRecord.data[index];
                    var yDataValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    //var xLeft = xScale.scale(index, -1);
                    //var w = Math.max(.25, xScale.itemWidth());
                    //var x = xLeft + w / 2;
                    var x = xScale.scale(xDataValue);

                    var y = yScale.flipScale(yDataValue);
                    var yZero = yScale.flipScale(0);
                    var h = Math.max(0, yScale.scaleSize(yDataValue));

                    var plotHeight = layInfo.height;
                    var halfHeight = plotHeight / 2;

                    //---- we use "yBaseLine" to center stack of polygons at each point ----
                    var yBaseLine = halfHeight - yScale.scaleSize(pi.itemTotals[index]) / 2;

                    if (true) {
                        var adjValue = yDataValue + pi.itemAccums[index];

                        //---- starts at yDataValue, offset by previous..  height doesn't change ----
                        y = -yBaseLine + yScale.flipScale(adjValue);
                        yZero = -yBaseLine + yScale.flipScale(pi.itemAccums[index]);

                        pi.itemAccums[index] = adjValue;
                    }

                    xa[index] = x;
                    ya[index] = y;
                    yz[index] = yZero;

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                        lastyZero = yZero;
                    }

                    //---- build string of points ----
                    var points = "";
                    points = _this.addPoint(points, lastx, lastyZero);
                    points = _this.addPoint(points, lastx, lasty);
                    points = _this.addPoint(points, x, y);
                    points = _this.addPoint(points, x, yZero);

                    //---- apply LAYOUT attributes ----
                    elem.attr("points", points).prop("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    lastyZero = yZero;
                });

                if (this._useSmoothing) {
                    //---- test ----
                    var testPts = [
                        { x: 20, y: 10 }, { x: 20.1, y: 12 }, { x: 20.5, y: 14 },
                        { x: 21, y: 16 }, { x: 24, y: 18 }, { x: 24.2, y: 20 }, { x: 26, y: 22 }];
                    var result = this.computeYByCol(testPts);

                    //---- smooth bottom and top of each rectangle ----
                    lastx = 0;
                    lasty = 0;
                    lastyZero = 0;

                    //---- calc the TOP interpolated points for this rect ----
                    var topSegments = vp.curveFitting.spline(xa, ya);

                    //---- calc the BOTTOM interpolated points for this rect ----
                    var bottomSegments = (seriesIndex) ? this._lastTopSegments : vp.curveFitting.spline(xa, yz);

                    for (var i = 0; i < shapes.length; i++) {
                        var x = xa[i];
                        var y = ya[i];
                        var yZero = yz[i];

                        if ((y == yZero) && (lasty == lastyZero)) {
                            //---- ensure that we never draw a curve shape for zero height area ----
                            var shape = shapes[i];
                            vp.attr(shape, "points", "");

                            //---- shift up the segment from the bottom line for next series ----
                            topSegments[i - 1] = bottomSegments[i - 1];
                        } else {
                            //---- skip the first shape (0-width) ----
                            if (i > 0) {
                                //---- ensure bottom line doesn't cross above top line ----
                                var topSegment = topSegments[i - 1];
                                var botSegment = bottomSegments[i - 1];

                                var crossing = false;

                                if (!crossing) {
                                    var shape = shapes[i];
                                    var points = "";

                                    //---- add the points that define the rect ----
                                    points = this.addPoint(points, lastx, lastyZero);
                                    points = this.addPoint(points, lastx, lasty);
                                    points = this.addPoints(points, topSegment, false);
                                    points = this.addPoint(points, x, y);
                                    points = this.addPoint(points, x, yZero);
                                    points = this.addPoints(points, botSegment, true);

                                    vp.attr(shape, "points", points);
                                } else {
                                    bottomSegments[i] = null;
                                }
                            }
                        }

                        lastx = x;
                        lasty = y;
                        lastyZero = yZero;
                    }

                    this._lastTopSegments = topSegments;
                }

                return shapes;
            };

            //---- map ordered but arbitrary X/Y pairs to one x per pixel & corresponding y value ----
            streamGraphClass.prototype.computeYByCol = function (pts, fromCol, toCol) {
                var newPts = [];
                var curr = null;
                var last = null;
                var nextIndex = 0;
                curr = pts[nextIndex++];
                var col = fromCol;

                while (col <= toCol) {
                    //--- get y for "col" ---
                    if (Math.floor(curr.x) == col) {
                        var total = 0;
                        var count = 0;
                        var needOuterBreak = false;

                        while (Math.floor(curr.x) == col) {
                            total += curr.y;
                            count++;
                            last = curr;

                            if (nextIndex == pts.length) {
                                needOuterBreak = true;
                                break;
                            }

                            curr = pts[nextIndex++];
                        }

                        newPts.push({ x: col, y: total / count });
                        col++;

                        if (needOuterBreak) {
                            break;
                        }
                    } else if (Math.floor(curr.x) < col) {
                        //---- ran out of data - just use last ----
                        newPts.push({ x: col, y: last.y });
                        col++;
                    } else {
                        //---- must interpolate Y from last/curr ----
                        var m = (curr.y - last.y) / (curr.x - last.x);
                        var b = curr.y - m * curr.x;

                        var y = m * col + b;
                        newPts.push({ x: col, y: y });
                        col++;
                    }
                }

                return newPts;
            };

            streamGraphClass.prototype.checkForCrossing = function (topPoints, botPoints) {
                var isCrossing = ((!topPoints) || (!botPoints));
                if (!isCrossing) {
                    var fromCol = Math.floor(Math.min(topPoints[0].x, botPoints[0].x));
                    var toCol = Math.floor(Math.min(topPoints[topPoints.length - 1].x, botPoints[botPoints.length - 1].x));

                    var topByCol = this.computeYByCol(topPoints, fromCol, toCol);
                    var botByCol = this.computeYByCol(botPoints, fromCol, toCol);

                    if (topByCol.length != botByCol.length) {
                        vp.error("internal error in streamGraph");
                    }

                    for (var i = 0; i < topByCol.length; i++) {
                        var top = topByCol[i];
                        var bot = botByCol[i];

                        if (bot.y < top.y) {
                            //---- we can only change the top data (since we are drawing each series from bottom to top), so, ----
                            //---- where top is too low, just use bottom ----
                            isCrossing = true;
                            top.y = bot.y;
                        }
                    }
                }

                if (isCrossing) {
                    //---- substitute the new bottom data ----
                    botPoints = botByCol;
                }

                return false;
            };

            //---- property: useSmoothing ----
            streamGraphClass.prototype.useSmoothing = function (value) {
                if (arguments.length == 0) {
                    return this._useSmoothing;
                }

                this._useSmoothing = value;

                return this;
            };
            return streamGraphClass;
        })(vp.layers.baseLayerClass);
        layers.streamGraphClass = streamGraphClass;

        function createStreamGraph() {
            return new streamGraphClass();
        }
        layers.createStreamGraph = createStreamGraph;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// text.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots text strings at specified x/y locations as a plot layer.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** plots text strings at specified x/y locations as a plot layer. */
        var textClass = (function (_super) {
            __extends(textClass, _super);
            function textClass() {
                _super.call(this);

                this._dodgeAxis = 0 /* none */;

                this.layerType("text").stat(vp.statIdentity()).defaultStackType("identity").chartName("Text").newTagOrFunc("text");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = false;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];

                //this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
            }
            textClass.prototype.adjustChartOptions = function () {
            };

            textClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //---- TEXT PLOT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- is scale one of the category types? ----
                var xIsCategoryScale = (xScale.mapType() != vp.MapType.lerp);
                var yIsCategoryScale = (yScale.mapType() != vp.MapType.lerp);

                //---- should scale use DATA or INDEX? ----
                var xUsesIndex = (xScale.mapType() == vp.MapType.category);
                var yUsesIndex = (yScale.mapType() == vp.MapType.category);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerText");

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var xValue = (xUsesIndex) ? (index) : xRecord.data[index];
                    var yValue = (yUsesIndex) ? (index) : yRecord.data[index];

                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    //---- this layer is used to add markers to layers that stack, so we DO honor the stackType ----
                    if (pi.stackType == "stack") {
                        var adjValue = yValue + pi.itemAccums[index];

                        //---- starts at dataValue, offset by previous..  height doesn't change ----
                        y = yScale.flipScale(adjValue);

                        pi.itemAccums[index] = adjValue;
                    } else if (pi.stackType == "fill") {
                        var newAccum = pi.itemAccums[index] + yValue;
                        var adjValue2 = newAccum / pi.itemTotals[index];
                        y = yScale.flipScale(adjValue2);

                        var adjHeight = yValue / pi.itemTotals[index];

                        pi.itemAccums[index] = newAccum;
                    } else if (pi.stackType == "dodge") {
                        if (_this._dodgeAxis == 1 /* x */) {
                            x = xScale.scale(xValue, seriesIndex);
                        }
                        if (_this._dodgeAxis == 2 /* y */) {
                            y = yScale.flipScale(yValue, seriesIndex);
                        }
                    }

                    if (xIsCategoryScale) {
                        //---- center shape on width of X band ----
                        x += xScale.itemWidth() / 2;
                    }

                    if (yIsCategoryScale) {
                        //---- center shape on height of Y band ----
                        y += yScale.itemWidth() / 2;
                    }

                    var xMid = x;
                    var yMid = y;

                    if (layInfo.swapAxes) {
                        var t = xMid;
                        xMid = yMid;
                        yMid = t;
                    }

                    elem.attr("x", xMid).attr("y", yMid).attr("cursor", "default").prop("updateVisualHint", "fill");

                    layer.applyTextAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            textClass.prototype.dodgeAxis = function (value) {
                if (arguments.length == 0) {
                    return this._dodgeAxis;
                }

                this._dodgeAxis = value;

                this.markRebuildNeeded();
                return this;
            };
            return textClass;
        })(vp.layers.baseLayerClass);
        layers.textClass = textClass;

        function createText() {
            return new textClass();
        }
        layers.createText = createText;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));

//---- outer namespace ----
var vp;
(function (vp) {
    (function (dodgeAxis) {
        dodgeAxis[dodgeAxis["none"] = 0] = "none";
        dodgeAxis[dodgeAxis["x"] = 1] = "x";
        dodgeAxis[dodgeAxis["y"] = 2] = "y";
    })(vp.dodgeAxis || (vp.dodgeAxis = {}));
    var dodgeAxis = vp.dodgeAxis;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// treeMap.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a treemap layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a treemap layer for a plot. */
        var treeMapClass = (function (_super) {
            __extends(treeMapClass, _super);
            function treeMapClass() {
                _super.call(this);
                //---- private state ----
                this._rootCount = 0;
                this._leaveCount = 0;
                this._maxDepth = 0;
                this._nameColCount = 0;
                this._namesWithBlanks = 0;
                this._statsCallBack = null;
                this._colorAttribute = null;
                this._sizeCol = null;

                this.layerType("treemap").stat(vp.statIdentity()).defaultStackType("identity").chartName("treemap").newTagOrFunc("null");

                //---- use a WHITE TO DARK RED color palette ----
                var palette = [vp.colorHelper.colors.white, vp.colorHelper.colors.darkred];

                this._attributes.fill({ palette: palette });
            }
            treeMapClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showLegend = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;

                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            treeMapClass.prototype.toSysColor = function (cr) {
                var rgb = vp.colorHelper.getColorFromString(cr);
                var sysColor = System.Drawing.Color.FromArgb4(rgb[0], rgb[1], rgb[2]);

                return sysColor;
            };

            treeMapClass.prototype.getTreeStats = function () {
                return {
                    rootCount: this._rootCount, leaveCount: this._leaveCount, maxDepth: this._maxDepth,
                    nameColCount: this._nameColCount, namesWithBlanks: this._namesWithBlanks };
            };

            treeMapClass.prototype.statsCallBack = function (callback) {
                this._statsCallBack = callback;
            };

            /// watch out for rootNode which has no "SizeMetric" property.
            treeMapClass.prototype.addChildSizesToParent = function (parentNode, depth) {
                var kids = parentNode.Nodes.ToArray();
                var isRootNode = (parentNode.SizeMetric === undefined);

                var fillAttribute = this._attributes._fill;
                var isFillMapped = fillAttribute.isMapped();
                var colorScale = fillAttribute.scale();

                var isSizeMapped = (parentNode.sizeValue !== undefined);
                this._maxDepth = Math.max(this._maxDepth, depth);

                var selfSize = 0;
                if (!isRootNode) {
                    var defaultSize = (kids.length > 0) ? 0 : 100;
                    selfSize = (isSizeMapped) ? parentNode.sizeValue : defaultSize;

                    //---- don't allow negative sizes (flag as error in client/app) ----
                    if (selfSize < 0) {
                        selfSize = 0;
                    }
                }

                var selfColor = (isFillMapped) ? parentNode.colorValue : 0;
                var totalSize = selfSize;

                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    var kidSize = this.addChildSizesToParent(kid, depth + 1);

                    totalSize += kidSize;
                    //totalColor += result.color;
                }

                parentNode.Nodes.EmptySpace.SizeMetric = selfSize; // node's "self" size

                if (!isRootNode) {
                    parentNode.SizeMetric = totalSize; // self + child sizes

                    //---- build TOOLTIP ----
                    var str = parentNode.Text + ": size=" + totalSize;
                    if (true) {
                        str += ", color=" + selfColor;
                    }

                    parentNode.SetToolTip(str);

                    //---- set fill color ----
                    var cr = (isFillMapped) ? colorScale.scale(selfColor) : "white";

                    //var cr = colorScale.scale(selfColor);
                    parentNode.AbsoluteColor = this.toSysColor(cr);
                }

                return totalSize;
            };

            treeMapClass.prototype.makeNode = function (name, nodeSize, fill, record, daNode, daText) {
                var node = new Microsoft.Treemap.Generator.Node(name, nodeSize, fill, record);

                node.PenWidthPx = 1;

                var textFill = daText.textFill;
                if (textFill) {
                    var sysColorText = this.toSysColor(textFill);
                    node.SetTextColor(sysColorText);
                }

                //node.colorValue = (record && this._colorAttribute.isMapped()) ? record[this._colorAttribute.colName()] : 0;
                node.colorValue = 0;

                if (record && this._colorAttribute.isMapped()) {
                    var colName = this._colorAttribute.colName();
                    node.colorValue = record[colName];
                }

                node.sizeValue = daNode.shapeSize; // (record) ? record[this._sizeCol] : 0;

                if (record) {
                    this._leaveCount++;
                }

                return node;
            };

            treeMapClass.prototype.ensureNodeExists = function (parentNode, name, nodeSize, fill, record, daNode, daText) {
                var node = null;

                //---- search parent ----
                var kids = parentNode.Nodes.ToArray();

                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    if (kid.Text == name) {
                        node = kid;
                        break;
                    }
                }

                if (!node) {
                    node = this.makeNode(name, nodeSize, fill, record, daNode, daText);
                    parentNode.Nodes.Add(node);
                }

                return node;
            };

            treeMapClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //---- clear stats ----
                this._rootCount = 0;
                this._leaveCount = 0;
                this._maxDepth = 0;
                this._nameColCount = 0;
                this._namesWithBlanks = 0;

                this._colorAttribute = this._attributes._fill;
                var lineSizeAttribute = this._attributes._lineSize;

                //---- set up SIZE for identity scaling ----
                if (lineSizeAttribute && lineSizeAttribute.isMapped()) {
                    lineSizeAttribute.isScalingEnabled(false);
                }

                //---- TREEMAP PLOT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                var htmlRoot = layInfo.htmlShapesGroup;

                //---- make it visible (it is normally hidden) ----
                htmlRoot.css("display", "block");

                var w = htmlRoot.width();
                var h = htmlRoot.height();

                var generator = new Microsoft.Treemap.Generator.TreemapGenerator(htmlRoot);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daNode = vp.currentTheme().getDrawingAttributes("layerTreemap");
                var daText = daNode;

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(daNode, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daText, seriesIndex, filteredData);

                var rootNode = generator;
                var nodesByName = {};

                var lineColor = this.toSysColor(daNode.stroke);
                generator.BorderColor = lineColor;
                generator.PenWidthPx = 1; //daNode.lineSize;
                generator.IsAnimationEnabled = plot.isAnimEnabled();

                var fontSize = daText.textSize;
                if (fontSize.endsWith && fontSize.endsWith("pt")) {
                    fontSize = fontSize.substr(0, fontSize.length - 2);
                }
                generator.FontNormSizePt = +fontSize;
                generator.FontFamily = daText.fontFamily;
                generator.FontSolidColor = this.toSysColor(daText.stroke);

                var nameList = filteredData.nameList;
                if (nameList) {
                    this._nameColCount = nameList.length;
                }

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(daNode, seriesIndex, index, filteredData);
                    layer.updateDrawingAttributes(daText, seriesIndex, index, filteredData);

                    var fontSize = daText.textSize;
                    if (fontSize.endsWith && fontSize.endsWith("pt")) {
                        fontSize = fontSize.substr(0, fontSize.length - 2);
                    }
                    generator.FontNormSizePt = +fontSize;
                    generator.FontFamily = daText.fontFamily;
                    generator.FontSolidColor = _this.toSysColor(daText.stroke);

                    var fill = _this.toSysColor(daNode.fill);
                    var nodeSize = +daNode.shapeSize;
                    var record = filteredData[index];

                    if (nameList) {
                        var parent = rootNode;

                        //---- find index of last valid (non-blank) name in this record ----
                        var lastValidIndex = nameList.length - 1;
                        while (lastValidIndex >= 0) {
                            var colName = nameList[lastValidIndex];
                            var value = record[colName];

                            if (value == "") {
                                lastValidIndex--;
                            } else {
                                break;
                            }
                        }

                        var foundOneOrMoreBlanks = (lastValidIndex < nameList.length - 1);

                        for (var n = 0; n <= lastValidIndex; n++) {
                            var colName = nameList[n];
                            var value = record[colName];

                            if (value != "") {
                                var rec = (n < lastValidIndex) ? null : record;
                                parent = _this.ensureNodeExists(parent, value, nodeSize, fill, rec, daNode, daText);
                            } else {
                                foundOneOrMoreBlanks = true;
                            }
                        }

                        if (foundOneOrMoreBlanks) {
                            _this._namesWithBlanks++;
                        }
                    } else {
                        var id = xRecord.data[index];

                        //var parent = yRecord.data[index];
                        var node = _this.makeNode(id, nodeSize, fill, record, daNode, daText);
                        nodesByName[id] = node;
                    }
                    // var elem = vp.select(uelem)
                    //elem
                    //    .attr("x", xMid)
                    //    .attr("y", yMid)
                    //    .attr("cursor", "default")
                    //    .prop("updateVisualHint", "fill")
                    //layer.applyTextAttributes(elem, da);
                    //if (isNewShape)
                    //{
                    //    layer.setElementInfo(elem, 1, seriesIndex);
                    //}
                });

                if (!nameList) {
                    for (var i = 0; i < filteredData.length; i++) {
                        var id = xRecord.data[i];
                        var parent = yRecord.data[i];

                        var childNode = nodesByName[id];
                        var parentNode = nodesByName[parent];

                        if (!parentNode) {
                            parentNode = rootNode;
                        }

                        parentNode.Nodes.Add(childNode);
                    }
                }

                this._rootCount = rootNode.Nodes.ToArray().length;

                //---- add all child values to each parent ----
                this.addChildSizesToParent(rootNode, 0);
                generator.Draw();

                if (this._statsCallBack) {
                    this._statsCallBack();
                }

                return shapes;
            };
            return treeMapClass;
        })(vp.layers.baseLayerClass);
        layers.treeMapClass = treeMapClass;

        function createTreeMap() {
            return new treeMapClass();
        }
        layers.createTreeMap = createTreeMap;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an vLine (set of vertical lines) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an vLine (set of vertical lines) layer for a plot. */
        var vLineClass = (function (_super) {
            __extends(vLineClass, _super);
            //---- private state ----
            function vLineClass() {
                _super.call(this);

                this.layerType("vline").stat(vp.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");
            }
            vLineClass.prototype.adjustChartOptions = function () {
            };

            vLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- VLINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.currentTheme().getDrawingAttributes("layerVline", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    var yMin = yScale.rangeMin();
                    var yMax = yScale.rangeMax();

                    //---- "xIntercept" is an alias for "x" ----
                    var xValue = xRecord.data[index];
                    var x = xScale.scale(xValue);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var elem = vp.select(uelem);

                    elem.from(x, yMin).to(x, yMax).prop("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return vLineClass;
        })(vp.layers.baseLayerClass);
        layers.vLineClass = vLineClass;

        function createVLine() {
            return new vLineClass();
        }
        layers.createVLine = createVLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// baseLayout.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - base class for layouts.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        var baseLayoutClass = (function () {
            function baseLayoutClass() {
                //---- private state ----
                this._width = 100;
                this._height = 100;
                this._count = 1;
                this._useCenter = false;
            }
            baseLayoutClass.prototype.getBoundsByIndex = function (index) {
                return this.makeBounds(0, 0, this._width, this._height);
            };

            baseLayoutClass.prototype.makeBounds = function (x, y, w, h) {
                if (this._useCenter) {
                    x += w / 2;
                    y += h / 2;
                }

                return { x: x, y: y, width: w, height: h };
            };

            baseLayoutClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._width;
                } else {
                    //--- SET value ----
                    this._width = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._height;
                } else {
                    //--- SET value ----
                    this._height = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.count = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._count;
                } else {
                    //--- SET value ----
                    this._count = Math.round(value);
                    return this;
                }
            };

            baseLayoutClass.prototype.useCenter = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._useCenter;
                } else {
                    //--- SET value ----
                    this._useCenter = value;
                    return this;
                }
            };
            return baseLayoutClass;
        })();
        layouts.baseLayoutClass = baseLayoutClass;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dock.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items within a docking container.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /**  returns a path layout object that will layout items within a docking container. */
        var dockClass = (function (_super) {
            __extends(dockClass, _super);
            //_childDatas = [];
            //_layoutNeeded = false;
            function dockClass() {
                _super.call(this);
                //---- private state ----
                this._needInit = true;
                this._left = 0;
                this._top = 0;
                this._right = 0;
                this._bottom = 0;
            }
            dockClass.prototype.init = function () {
                this._left = 0;
                this._top = 0;
                this._right = _super.prototype.width.call(this) - 1;
                this._bottom = _super.prototype.height.call(this) - 1;

                this._needInit = false;
            };

            dockClass.prototype.getBounds = function (itemWidth, itemHeight, dockType) {
                if (this._needInit) {
                    this.init();
                }

                var x = this._left;
                var y = this._top;

                if (dockType == "left") {
                    this._left += itemWidth;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "top") {
                    this._top += itemHeight;
                    itemWidth = this.makeSize(this._right - this._left);
                } else if (dockType == "right") {
                    x = this._right - itemWidth;
                    this._right = x;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "bottom") {
                    y = this._bottom - itemHeight;
                    this._bottom = y;
                    itemWidth = this.makeSize(this._right - this._left);
                } else {
                    itemWidth = this.makeSize(this._right - this._left);
                    itemHeight = this.makeSize(this._bottom - this._top);
                }
                ;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            dockClass.prototype.makeSize = function (value) {
                return Math.max(0, value);
            };
            return dockClass;
        })(vp.layouts.baseLayoutClass);
        layouts.dockClass = dockClass;

        function createDock() {
            return new dockClass();
        }
        layouts.createDock = createDock;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// grid.ts.  Copyright (c) 2012 Microsoft Corporation.
///           Part of the vuePlot library - lays out items in an X/Y grid.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see layouts.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a grid layout object that will layout items in a rectangular grid shape. */
        var gridClass = (function (_super) {
            __extends(gridClass, _super);
            function gridClass() {
                _super.call(this);
                //---- private state ----
                this._userRows = undefined;
                this._userColumns = undefined;
                this._rows = 1;
                this._columns = 1;
                this._layoutNeeded = true;
            }
            gridClass.prototype.getBoundsByIndex = function (index) {
                if (this._layoutNeeded) {
                    this.computeLayout();
                }

                var width = _super.prototype.width.call(this);
                var height = _super.prototype.height.call(this);

                if ((this._rows < 1) || (this._columns < 1) || (_super.prototype.count.call(this) <= 1)) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = width / this._columns;
                var itemHeight = height / this._rows;

                var row = Math.floor(index / this._columns);
                var col = index % this._columns;

                var x = col * itemWidth;
                var y = row * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            gridClass.prototype.markLayoutNeeded = function () {
                this._layoutNeeded = true;
            };

            //---- private: computeLayout() ----
            gridClass.prototype.computeLayout = function () {
                this._layoutNeeded = false;
                var count = _super.prototype.count.call(this);

                if (vp.isDefined(this._userRows)) {
                    this._rows = this._userRows;
                    this._columns = (this._userColumns === undefined) ? Math.ceil(this._count / this._rows) : this._userColumns;
                } else {
                    this._columns = (this._userColumns === undefined) ? Math.ceil(Math.sqrt(count)) : this._userColumns;
                    this._rows = Math.ceil(this._count / this._columns);
                }
            };

            gridClass.prototype.rowCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userRows;
                } else {
                    //--- SET value ----
                    this._userRows = value;
                    return this;
                }
            };

            gridClass.prototype.colCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userColumns;
                } else {
                    //--- SET value ----
                    this._userColumns = value;
                    return this;
                }
            };
            return gridClass;
        })(vp.layouts.baseLayoutClass);
        layouts.gridClass = gridClass;

        function createGrid() {
            return new gridClass();
        }
        layouts.createGrid = createGrid;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// horizontal.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the horizontal direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a horizontal object closure that will layout items from left to right. */
        var horizontalClass = (function (_super) {
            __extends(horizontalClass, _super);
            function horizontalClass() {
                _super.call(this);
            }
            horizontalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this) / _super.prototype.count.call(this);
                var itemHeight = _super.prototype.height.call(this);

                var x = index * itemWidth;
                var y = 0;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return horizontalClass;
        })(vp.layouts.baseLayoutClass);
        layouts.horizontalClass = horizontalClass;

        function createHorizontal() {
            return new horizontalClass();
        }
        layouts.createHorizontal = createHorizontal;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// path.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items along an SVG layeretry path.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a path layout object that will layout items along an SVG layeretry path. */
        var pathClass = (function (_super) {
            __extends(pathClass, _super);
            function pathClass() {
                _super.call(this);
                //---- private state ----
                this._path = null;
                this._itemWidth = 100;
                this._itemHeight = 100;
                this._atStart = true;
                this._atEnd = true;
            }
            pathClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                //---- NOTE: this is NOT supported on IE9 (but IE10 supports it) ----
                var bounds = null;

                if (this._path.getTotalLength) {
                    var total = this._path.getTotalLength();
                    var pcount = _super.prototype.count.call(this);
                    if (!this._atEnd) {
                        pcount++;
                    }

                    if (!this._atStart) {
                        index++;
                        pcount++;
                    }

                    var percent = index / (pcount - 1);

                    var pt = this._path.getPointAtLength(percent * total);

                    bounds = _super.prototype.makeBounds.call(this, pt.x, pt.y, this._itemWidth, this._itemHeight);
                } else {
                    //---- not yet implemented ----
                    bounds = _super.prototype.makeBounds.call(this, 0, 0, 100, 100);
                }

                return bounds;
            };

            pathClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            pathClass.prototype.path = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._path;
                } else {
                    //--- SET value ----
                    this._path = value;
                    return this;
                }
            };

            pathClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            pathClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };

            pathClass.prototype.atStart = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atStart;
                } else {
                    //--- SET value ----
                    this._atStart = value;
                    return this;
                }
            };

            pathClass.prototype.atEnd = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atEnd;
                } else {
                    //--- SET value ----
                    this._atEnd = value;
                    return this;
                }
            };
            return pathClass;
        })(vp.layouts.baseLayoutClass);
        layouts.pathClass = pathClass;

        function createPath() {
            return new pathClass();
        }
        layouts.createPath = createPath;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// random.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in random places.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a random layout object that will layout items in random (overlapping) places. */
        var randomClass = (function (_super) {
            __extends(randomClass, _super);
            function randomClass() {
                _super.call(this);
                //---- private state ----
                this._itemWidth = 100;
                this._itemHeight = 100;
            }
            randomClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var x = this.rand(0, _super.prototype.width.call(this) - this._itemWidth);
                var y = this.rand(0, _super.prototype.height.call(this) - this._itemHeight);

                return _super.prototype.makeBounds.call(this, x, y, this._itemWidth, this._itemHeight);
            };

            randomClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            randomClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            randomClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };
            return randomClass;
        })(vp.layouts.baseLayoutClass);
        layouts.randomClass = randomClass;

        function createRandom() {
            return new randomClass();
        }
        layouts.createRandom = createRandom;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vertical.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the vertical direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a vertical layout object that will layout items from top to bottom. */
        var verticalClass = (function (_super) {
            __extends(verticalClass, _super);
            function verticalClass() {
                _super.call(this);
            }
            verticalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this);
                var itemHeight = _super.prototype.height.call(this) / _super.prototype.count.call(this);

                var x = 0;
                var y = index * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return verticalClass;
        })(vp.layouts.baseLayoutClass);
        layouts.verticalClass = verticalClass;

        function createVertical() {
            return new verticalClass();
        }
        layouts.createVertical = createVertical;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// shapeData.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - provides path data for different shape types.
///-----------------------------------------------------------------------------------------------------------------
/// layer responsibilities: see layerBar.js
///-----------------------------------------------------------------------------------------------------------------
vp.getPathDataForShape = function (shapeType, x, y, w, h)
{
    var move = function (str, x, y)
    {
        str += " M " + x + " " + y;
        return str;
    }

    var line = function (str, x, y)
    {
        str += " L " + x + " " + y;
        return str;
    }

    var circle = function (str, cx, cy, r)
    {
        str += " M " + (cx - r) + " " + cy +
            " a " + r + " " + r + " 0 1 0 " + (2 * r) + " 0" +
            " a " + r + " " + r + " 0 1 0 " + (-2 * r) + " 0";

        return str;
        
    }

    var close = function (str)
    {
        str += " z";
        return str;
    }

    var d = "";

    //---- scale our 0..1 vars as per the desired bounds ----
    var x0 = x - w / 2;
    var x1 = x + w / 2;
    var x5 = x;

    var y0 = y - h / 2;
    var y1 = y + h / 2;
    var y5 = y;

    switch (shapeType)
    {
        case 2:
        case 17:
        case 24:
            {
                //---- triangle ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);
                break;
            }

        case 3:
            {
                //---- plus sign ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 4:
            {
                //---- big X ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);
                break;
            }

        case 5:
        case 18:
        case 23:
            {
                //---- diamond ----
                d = move(d, x5, y0);
                d = line(d, x0, y5);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = line(d, x5, y0);
                d = close(d);
                break;
            }

        case 6:
        case 25:
            {
                //---- upside down triangle ----
                d = move(d, x0, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 30:
            {
                //---- left pointing triangle ----
                d = move(d, x5, y0);
                d = line(d, x5, y1);
                d = line(d, x0, y5);
                d = close(d);
                break;
            }

        case 31:
            {
                //---- left pointing triangle ----
                d = move(d, x5, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = close(d);
                break;
            }

        case 32:
            {
                //---- for pentagram ----
                var y3 = y0 + .36 * h;
                var y6 = y0 + .62 * h;
                var y7 = y0 + .76 * h;

                var x2 = x0 + .19 * w;
                var x3 = x0 + .31 * w;
                var x4 = x0 + .37 * w;
                var x6 = x0 + .63 * w;
                var x7 = x0 + .69 * w;
                var x8 = x0 + .85 * w;

                //---- 5 point star ----
                d = move(d, x5, y0);
                d = line(d, x6, y3);
                d = line(d, x1, y3);
                d = line(d, x7, y6);
                d = line(d, x8, y1);
                d = line(d, x5, y7);
                d = line(d, x2, y1);
                d = line(d, x3, y6);
                d = line(d, x0, y3);
                d = line(d, x4, y3);
                d = close(d);
                break;
            }

        case 33:
            {
                //---- for hexagram ----
                var y2 = y0 + .25 * h;
                var y7 = y0 + .75 * h;

                var x2 = x0 + .21 * w;
                var x3 = x0 + .36 * w;
                var x6 = x0 + .64 * w;
                var x8 = x0 + .80 * w;

                //---- 5 point star ----
                d = move(d, x5, y0);
                d = line(d, x6, y2);
                d = line(d, x1, y2);
                d = line(d, x8, y5);
                d = line(d, x1, y7);
                d = line(d, x6, y7);
                d = line(d, x5, y1);
                d = line(d, x3, y7);
                d = line(d, x0, y7);
                d = line(d, x2, y5);
                d = line(d, x0, y2);
                d = line(d, x3, y2);
                d = close(d);
                break;
            }

        case 7:
            {
                //---- X in square ----
                //---- X-part ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);

                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 8:
            {
                //---- asterisk ----

                //---- make diagonals a bit smaller ----
                var x2 = x0 + .2 * w;
                var x8 = x1 - .2 * w;

                var y2 = y0 + .2 * h;
                var y8 = y1 - .2 * h;

                d = move(d, x5, y0);
                d = line(d, x5, y1);

                d = move(d, x8, y2);
                d = line(d, x2, y8);

                d = move(d, x1, y5);
                d = line(d, x0, y5);

                d = move(d, x8, y8);
                d = line(d, x2, y2);
                break;
            }


        case 9:
            {
                //---- diamond with a plus inside ----
                //---- diamond-part ----
                d = move(d, x5, y0);
                d = line(d, x0, y5);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = line(d, x5, y0);
                d = close(d);

                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 10:
            {
                //---- plus in a circle ----
                //---- circle-part ----
                d = circle(d, x5, y5, w/2);

                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 11:
            {
                //---- 2 triangles ----
                //---- triangle-part ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);
                //---- down-triangle-part ----
                d = move(d, x0, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 12:
            {
                //---- square with plus ----
                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 13:
            {
                //---- X in a circle ----
                //---- circle-part ----
                d = circle(d, x5, y5, w / 2);

                //---- X-part ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);
                break;
            }

        case 14:
            {
                //---- triangle in a square ----
                //---- triangle-part ----
                //---- triangle-part ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);

                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }
    }

    return d;
}

﻿///-----------------------------------------------------------------------------------------------------------------
/// statBin.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - bins the data as a vvPlot stat.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     - statX()   - optional; return new "x" column name
///     - statY()   - optional; return new "y" column names
///     - calcXScaleForLayer() - optional; take over responsiblity for calculating yMin, yMax for this layer.
///     - calcYScaleForLayer() - optional; take over responsiblity for calculating yMin, yMax for this layer.
///-----------------------------------------------------------------------------------------------------------------
vp.statBin = function ()
{
    //---- private state ----
    var binPercent = .3;
    var forceCategory = false;
    var usePercent = false;
    var isCategory = false;
    var dataUsed = null;
    var niceBuckets = false;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statBin";

    closure.isCategory = function()
    {
        return isCategory;
    }

    closure.data = function ()
    {
        return dataUsed;
    }

    //---- property: forceCategory ----
    closure.forceCategory = function (value)
    {
        if (arguments.length == 0)
        {
            return forceCategory;
        }

        forceCategory = value;

        return closure;
    };

    //---- property: usePercent ----
    closure.usePercent = function (value)
    {
        if (arguments.length == 0)
        {
            return usePercent;
        }

        usePercent = value;

        return closure;
    };

    //---- property: binPercent ----
    closure.binPercent = function (value)
    {
        if (arguments.length == 0)
        {
            return binPercent;
        }

        binPercent = value;

        return closure;
    };

    //---- property: niceBuckets ----
    closure.niceBuckets = function (value)
    {
        if (arguments.length == 0)
        {
            return niceBuckets;
        }

        niceBuckets = value;

        return closure;
    };

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        var xColName = ["name"];

        if ((data) && (data.length > 0))
        {
            if (xCol)
            {
                //---- if array, get first element ----
                //xCol = (xCol.length) ? (xCol[0]) : xCol;

                var xdata = data.selectWithFunc(function (data, index) { return data[xCol]; });
                var isNumeric = ((!forceCategory) && (vp.isDataNumeric(xdata)));

                var binCount = Math.max(1, Math.round(1 / binPercent));

                if (isNumeric)
                {
                    //---- compute min/max for our properties ----
                    dataUsed = xdata;

                    //---- numeric bin ----
                    data = vp.createBins(xdata, binCount, false, niceBuckets);
                    isCategory = false;
                    xColName = ["min"];
                }
                else
                {
                    //---- category bin ----
                    data = vp.createCategoryBins(xdata, xCol);
                    isCategory = true;

                    xColName = xCol;
                }
            }
        }

        var yColName = (usePercent) ? "density" : "count";

        return { xCol: xColName, yCols: [yColName], data: data };

    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// statBin2d.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - bins the data in both X and Y data.
///-----------------------------------------------------------------------------------------------------------------

/// a struct to hold bin parameters.
vp.binParams = function (binCount, forceCategory, usePercent, niceBuckets)
{
    this.binCount = binCount;
    this.forceCategory = forceCategory;
    this.usePercent = usePercent;
    this.niceBuckets = niceBuckets;
};

vp.statBin2d = function ()
{
    //---- private state ----
    var xBinParams = new vp.binParams(9, false, false, false);
    var yBinParams = new vp.binParams(9, false, false, false);
    var dataUsed = null;

    //---- values after running bin ----
    var xIsCategory = false;
    var yIsCategory = false;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statBin2d";

    closure.xIsCategory = function ()
    {
        return xIsCategory;
    }

    closure.yIsCategory = function ()
    {
        return yIsCategory;
    }

    closure.data = function ()
    {
        return dataUsed;
    }

    //---- property: xBinParams ----
    closure.xBinParams = function (value)
    {
        if (arguments.length == 0)
        {
            return xBinParams;
        }

        xBinParams = value;

        return closure;
    };

    //---- property: yBinParams ----
    closure.yBinParams = function (value)
    {
        if (arguments.length == 0)
        {
            return yBinParams;
        }

        yBinParams = value;

        return closure;
    };

    var binCol = function (data, colName, binParams)
    {
        var vector = data.selectWithFunc(function (data, index) { return data[colName]; });
        var newData = null;
        var xColName = ["name"];

        var isNumeric = ((! binParams.forceCategory) && (vp.isDataNumeric(vector)));

        var binCount = Math.max(1, Math.round(binParams.binCount));
        var isCategory = false;

        if (isNumeric)
        {
            //---- compute min/max for our properties ----
            dataUsed = vector;

            //---- numeric bin ----
            newData = vp.createBins(vector, binCount, false, binParams.niceBuckets, true);
            isCategory = false;
            xColName = ["min"];
        }
        else
        {
            //---- category bin ----
            newData = vp.createCategoryBins(vector, colName, true);
            isCategory = true;

            xColName = colName;
        }

        var yColName = (binParams.usePercent) ? "density" : "count";

        return { xCol: xColName, yCols: [yColName], data: newData, isCategory: isCategory };
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        var result = { rowCount: 0, colCount: 0, data: null };

        if ((data) && (data.length > 0))
        {
            var dataCount = data.length;

            if ((xCol) && (yCols.length > 0))
            {
                var yCol = yCols[0];

                //---- if array, get first element ----
                xCol = (xCol.length) ? (xCol[0]) : xCol;

                var xResult = binCol(data, xCol, xBinParams);
                xIsCategory = xResult.isCategory;

                var yResult = binCol(data, yCol, yBinParams);
                yIsCategory = yResult.isCategory;

                //---- set up counters for each row/col bucket ----
                var colCount = xResult.data.length;
                var rowCount = yResult.data.length;
                var gridTotals = [];

                for (var r = 0; r < rowCount; r++)
                {
                    var row = [];

                    for (var c = 0; c < colCount; c++)
                    {
                        row.push(0);
                    }

                    gridTotals.push(row);
                }

                var xAssignments = xResult.data.assignments;
                var yAssignments = yResult.data.assignments;

                //---- now, count the number of data items in "data" in each row/col bucket ----
                for (var i = 0; i < data.length; i++)
                {
                    var colIndex = xAssignments[i];
                    var rowIndex = yAssignments[i];

                    gridTotals[rowIndex][colIndex]++;
                }

                //---- build data from gridTotals, centered in X and Y data spaces ----
                if (xIsCategory)
                {
                    xMin = 0;;
                    xMax = colCount - 1;
                }
                else
                {
                    var xMin = xResult.data[0].min;
                    var xMax = xResult.data[colCount - 1].max;
                    var xSize = xResult.data[0].max - xResult.data[0].min;

                    //---- center points ----
                    xMin += xSize / 2;
                    xMax -= xSize / 2;
                }

                if (yIsCategory)
                {
                    yMin = 0;
                    yMax = rowCount - 1;
                }
                else
                {
                    var yMin = yResult.data[0].min;
                    var yMax = yResult.data[rowCount - 1].max;
                    var ySize = yResult.data[0].max - yResult.data[0].min;

                    //---- center points ----
                    yMin += ySize / 2;
                    yMax -= ySize / 2;
                }

                var newData = [];
                var x, y;

                for (var r = 0; r < rowCount; r++)
                {
                    if (yIsCategory)
                    {
                        y = yResult.data[r][yCol];
                    }
                    else
                    {
                        y = yResult.data[r].name;
                    }

                    for (var c = 0; c < colCount; c++)
                    {
                        //---- center the tiles in the data X and Y spaces ----
                        //var x = vp.mapValue(c, 0, colCount - 1, xMin, xMax);
                        //var y = vp.mapValue(r, 0, rowCount - 1, yMin, yMax);

                        if (xIsCategory)
                        {
                            x = xResult.data[c][xCol];
                        }
                        else
                        {
                            x = xResult.data[c].name;
                        }

                        var value = gridTotals[r][c];

                        var record = { x: x, y:y, value: value, percent: 100*value/dataCount };
                        newData.push(record);
                    }
                }

                newData.xResult = xResult;
                newData.yResult = yResult;

                result =
                {
                    rowCount: rowCount, colCount: colCount,
                    totals: gridTotals, data: newData, xCol: "x", yCols: ["y"]
                };
            }
        }

        return result;
    };


    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// statBoxPlot.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a vvPlot stat object that creates boxPlot quartile data 
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.statBoxPlot = function ()
{
    //---- private state ----

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statBoxPlot";

    /// calcYScaleForLayer()
    closure.calcYScaleForLayer = function (layer)
    {
        var thisMin = +9999999;
        var thisMax = -9999999;
        var layInfo = layer.info;

        //---- compute ymin/ymax from "yMin", "yMax" fields on each data record ----
        var records = layInfo.filteredData;

        //---- special min/max requirements ----
        for (var i = 0; i < records.length; i++)
        {
            var record = records[i];

            thisMin = Math.min(thisMin, record.yMin);
            thisMax = Math.max(thisMax, record.yMax);
        }

        return { min: thisMin, max: thisMax };
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length > 0))
        {
            if ((xCol) && (yCols.length > 0))
            {
                data = vp.createBoxPlotData(data, xCol, yCols[0]);
            }
        };

        return {
            xCol: ["name"],
            yCols: ["lower", "middle", "upper", "yMin", "yMax", "lowFence", "highFence", "outliers"],
            data: data };
    }

    return closure;
};

///-----------------------------------------------------------------------------------------------------------------
/// statContour.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - converts a flat set of records (with fields x, y, z) into a set of from/to point records (x1, y1, x2, y2).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (stats) {
        /** settings for an attribute (value, scaling, and legend data). */
        var statContourClass = (function () {
            function statContourClass() {
                //---- private state ----
                this._contourCount = 5;
                this._colCount = undefined;
                this._xColName = "";
                this._yColName = "";
                this._zColName = "";
                this.runStatOnData = function (xCol, yCols, data, layer) {
                    var lineRecords = [];
                    var result = { data: lineRecords, xCol: [], yCol: ["x1", "y1", "x2", "y2"] };

                    if ((xCol) && (yCols.length > 1)) {
                        var rows = data;
                        var count = rows.length;

                        var colCount = this._colCount;
                        if (colCount === undefined) {
                            colCount = Math.floor(Math.sqrt(count));
                        }

                        var rowCount = Math.ceil(count / colCount);
                        var contourCount = this._contourCount;

                        this._xColName = (xCol.length) ? (xCol[0]) : xCol;
                        this._yColName = yCols[0];
                        this._zColName = yCols[1];
                        var zColName = this._zColName;

                        //---- find ZMIN and ZMAX ----
                        var zMin = Number.MAX_VALUE;
                        var zMax = -zMin;
                        var index = 0;

                        for (var r = 0; r < rowCount - 1; r++) {
                            for (var c = 0; c < colCount - 1; c++) {
                                var z = rows[index++][zColName];
                                if (z < zMin) {
                                    zMin = z;
                                }

                                if (z > zMax) {
                                    zMax = z;
                                }
                            }
                        }

                        //---- build contour heights ----
                        var contourHeights = [];
                        var zRange = zMax - zMin;

                        for (var k = 0; k < contourCount; k++) {
                            contourHeights[k] = zMin + k * zRange / (contourCount - 1);
                        }

                        var index = 0;

                        for (var r = 0; r < rowCount - 1; r++) {
                            for (var c = 0; c < colCount - 1; c++) {
                                var pt1 = rows[index];
                                var pt2 = rows[index + 1];
                                var pt3 = rows[index + colCount];
                                var pt4 = rows[index + colCount + 1];

                                for (var k = 0; k < contourCount; k++) {
                                    this.addLineDataForLeftTriangle(lineRecords, contourHeights[k], pt1, pt3, pt4);

                                    this.addLineDataForRightTriangle(lineRecords, contourHeights[k], pt1, pt2, pt4);
                                }

                                index++;
                            }
                        }
                    }

                    return result;
                };
            }
            statContourClass.prototype.contourCount = function (value) {
                if (arguments.length == 0) {
                    return this._contourCount;
                }

                this._contourCount = value;
                return this;
            };

            statContourClass.prototype.isBetween = function (k, pt1, pt2) {
                var zCol = this._zColName;

                var isBet = ((k >= pt1[zCol] && k < pt2[zCol]) || (k >= pt2[zCol] && k < pt1[zCol]));
                return isBet;
            };

            statContourClass.prototype.zFactor = function (k, pt1, pt2) {
                var zCol = this._zColName;

                var zfactor = (k - pt1[zCol]) / (pt2[zCol] - pt1[zCol]);
                return zfactor;
            };

            statContourClass.prototype.addLine = function (lineRecords, x1, y1, x2, y2) {
                var record = { x1: x1, y1: y1, x2: x2, y2: y2 };
                lineRecords.push(record);
            };

            statContourClass.prototype.lerp = function (percent, a, b) {
                return a + percent * (b - a);
            };

            /// "k" is the coutour level.
            statContourClass.prototype.addLineDataForLeftTriangle = function (lineRecords, k, pt0, pt1, pt2) {
                var xCol = this._xColName;
                var yCol = this._yColName;

                //--- left triangle ----
                var isBet01 = this.isBetween(k, pt0, pt1);
                var isBet12 = this.isBetween(k, pt1, pt2);
                var isBet02 = this.isBetween(k, pt0, pt2);

                if (isBet01 && isBet12) {
                    //---- case c: DIAGONAL line in left triangle ----
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = pt0[xCol];
                    var y1 = this.lerp(percent1, pt0[yCol], pt1[yCol]);
                    var x2 = this.lerp(percent2, pt1[xCol], pt2[xCol]);
                    var y2 = pt1[yCol];

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet02 && isBet12) {
                    //---- case b: VERTICAL line in left triangle ----
                    var percent1 = this.zFactor(k, pt0, pt2);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt2[xCol]);
                    var y1 = this.lerp(percent1, pt0[yCol], pt2[yCol]);
                    var x2 = this.lerp(percent2, pt1[xCol], pt2[xCol]);
                    var y2 = pt1[yCol];

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet01 && isBet02) {
                    //---- case a: HORIZONTAL line in left triangle ---
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt0, pt2);

                    var x1 = pt0[xCol];
                    var y1 = this.lerp(percent1, pt0[yCol], pt1[yCol]);
                    var x2 = this.lerp(percent2, pt0[xCol], pt2[xCol]);
                    var y2 = this.lerp(percent2, pt0[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                }
            };

            /// "k" is the coutour level.
            statContourClass.prototype.addLineDataForRightTriangle = function (lineRecords, k, pt0, pt1, pt2) {
                var xCol = this._xColName;
                var yCol = this._yColName;

                //--- right triangle ----
                var isBet01 = this.isBetween(k, pt0, pt1);
                var isBet12 = this.isBetween(k, pt1, pt2);
                var isBet02 = this.isBetween(k, pt0, pt2);

                if (isBet01 && isBet12) {
                    //---- case c: DIAGONAL line in right triangle ----
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt1[xCol]);
                    var y1 = pt0[yCol];
                    var x2 = pt1[xCol];
                    var y2 = this.lerp(percent2, pt1[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet02 && isBet12) {
                    //---- case b: VERTICAL line in right triangle ----
                    var percent1 = this.zFactor(k, pt0, pt2);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt2[xCol]);
                    var y1 = this.lerp(percent1, pt0[yCol], pt2[yCol]);
                    var x2 = pt1[xCol];
                    var y2 = this.lerp(percent2, pt1[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet01 && isBet02) {
                    //---- case a: HORIZONTAL line in right triangle ---
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt0, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt1[xCol]);
                    var y1 = pt0[yCol];
                    var x2 = this.lerp(percent2, pt0[xCol], pt2[xCol]);
                    var y2 = this.lerp(percent2, pt0[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                }
            };
            return statContourClass;
        })();
        stats.statContourClass = statContourClass;

        function createStatContour() {
            return new statContourClass();
        }
        stats.createStatContour = createStatContour;
    })(vp.stats || (vp.stats = {}));
    var stats = vp.stats;
})(vp || (vp = {}));
﻿///-----------------------------------------------------------------------------------------------------------------
/// statDensity.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - current method is to use a normalize bin of the data.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.statDensity = function ()
{
    //---- private state ----
    var binPercent = .3;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statDensity";

    //---- property: binPercent ----
    closure.binPercent = function (value)
    {
        if (arguments.length == 0)
        {
            return binPercent;
        }

        binPercent = value;

        return closure;
    };

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length > 0))
        {
            if (xCol)
            {
                var xdata = data.selectWithFunc(function (data, index) { return data[xCol]; });
                var isNumeric = vp.isDataNumeric(xdata);

                if (isNumeric)
                {
                    //var max = xdata.max();
                    //var min = xdata.min();
                    //var binSize = (max - min) * binPercent;
                    var binCount = 1 / binPercent;

                    //---- numeric bin ----
                    data = vp.createBins(xdata, binCount);
                }
                else
                {
                    //---- category bin ----
                    data = vp.createCategoryBins(xdata);
                }
            }
        }

        return { xCol: ["name"], yCols: ["ndensity"], data: data };

    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// statIdentity.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a bar chart type layer for vvPlot.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.statIdentity = function ()
{
    //---- private state ----

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statIdentity";
    closure.statType = "identity";

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        return {xCol: xCol, yCols: yCols, data: data };
    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// statSpaceFill.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - computes the rectangle positions of each item.
///-----------------------------------------------------------------------------------------------------------------
vp.statSpaceFill = function ()
{
    //---- private state ----
    var startLoc = "left";      // side to start placing blocks  (left, top, right, bottom)
    var chunking = null;
    var phrasing = "strip";

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.statSpaceFill";

    var computeRects = function (data, bounds, da, filteredData, layer)
    {
        var seriesIndex = 0;
        var items = [];
        var totalSize = 0;
        var phrase = { side: startLoc, forward: true };

        if (phrasing == "spikes")
        {
            phrase.forward = false;
        }

        //---- first pass - compute size of each item ----
        for (var i = 0; i < data.length; i++)
        {
            //---- update drawing attributes for this itemIndex ----
            layer.updateDrawingAttributes(da, seriesIndex, i, filteredData);

            var size = da.shapeSize;        // constant, mapped, "childCount", "allChildCount"
            var sz = size;

            if (size == "childCount")
            {
            }
            else if (size == "allChildCount")
            {
            }

            var item = filteredData[i];        // we will add on to original data
            item._size = sz;

            items.push(item);

            totalSize += sz;
        }

        var maxItems = (chunking) ? chunking : 1;
        var chunk = null;

        //---- second pass - compute rect of each item ----
        for (var i = 0; i < data.length; i++)
        {
            var item = items[i];

            var size = item._size;

            //---- start new chunk ----
            if ((!chunk) || (chunk.items.length >= maxItems))
            {
                if (chunk)
                {
                    layoutChunk(chunk, bounds, phrase, totalSize);

                    //---- update width/height of bounds after each chunk is layed out ----
                    bounds.width = bounds.right - bounds.left;
                    bounds.height = bounds.bottom - bounds.top;

                    //---- get new phrase value ----
                    if (phrasing == "zigzag")
                    {
                        phrase.forward = (!phrase.forward);
                    }
                    else if (phrasing == "spiral")
                    {
                        phrase.side = getNextSide(phrase.side);
                    }
                    else if (phrasing == "spikes")
                    {
                        phrase.side = getAdjacentSide(phrase.side);
                        phrase.forward = (!phrase.forward);
                    }

                    totalSize -= chunk.size;
                }

                var isVert = ((phrase.side == "left") || (phrase.side == "right"));

                chunk = { dir: "up", items: [], size: 0, isVert: isVert };
            }

            addToChunk(chunk, item);
        }

        //---- layout last chunk ----
        if (chunk)
        {
            layoutChunk(chunk, bounds, phrase, totalSize);
        }

        //---- do final adjustments based on total vertical/horizontal layouts ----

        return items;
    };

    var addToChunk = function (chunk, item)
    {
        chunk.size += item._size;
        chunk.items.push(item);
    };

    var getDirName = function (side, forward)
    {
        var name = "";

        if (side == "left")
        {
            name = (forward) ? "top" : "bottom";
        }
        else if (side == "right")
        {
            name = (forward) ? "bottom" : "top";
        }
        else if (side == "top")
        {
            name = (forward) ? "right" : "left";
        }
        else if (side == "bottom")
        {
            name = (forward) ? "left" : "right";
        }

        return name;
    }

    var getNextSide = function (side)
    {
        var name = "";

        if (side == "left")
        {
            name = "bottom";
        }
        else if (side == "bottom")
        {
            name = "right";
        }
        else if (side == "right")
        {
            name = "top";
        }
        else if (side == "top")
        {
            name = "left";
        }

        return name;
    }

    var getAdjacentSide = function (side)
    {
        var name = "";

        if (side == "left")
        {
            name = "bottom";
        }
        else if (side == "bottom")
        {
            name = "left";
        }
        else if (side == "right")
        {
            name = "top";
        }
        else if (side == "top")
        {
            name = "right";
        }

        return name;
    }

    var layoutChunk = function (chunk, bounds, phrase, totalSize)
    {
        var chunkPercent = chunk.size / totalSize;

        //---- first, layout the chunk rect within "bounds" ----
        var cb = layoutInBounds(chunk, bounds, phrase.side, chunkPercent);
        var dirName = getDirName(phrase.side, phrase.forward);

        //---- now layout each item of the chunk within "cb" (the chunk bounds) ----
        for (var i = 0; i < chunk.items.length; i++)
        {
            var item = chunk.items[i];

            var rect = layoutInBounds(item, cb, dirName, item._size / chunk.size);
            item._bounds = rect;
        }
    };

    var layoutInBounds = function (item, bounds, side, sizePercent)
    {
        var rect = null;

        if (side == "left")
        {
            var w = bounds.width * sizePercent;
            rect = vp.rect(bounds.left, bounds.top, w, bounds.height);
            bounds.left += w;
        }
        else if (side == "right")
        {
            var w = bounds.width * sizePercent;
            rect = vp.rect(bounds.right - w, bounds.top, w, bounds.height);
            bounds.right -= w;
        }
        else if (side == "top")
        {
            var h = bounds.height * sizePercent;
            rect = vp.rect(bounds.left, bounds.top, bounds.width, h);
            bounds.top += h;
        }
        else if (side == "bottom")
        {
            var h = bounds.height * sizePercent;
            rect = vp.rect(bounds.left, bounds.bottom - h, bounds.width, h);
            bounds.bottom -= h;
        }

        return rect;
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length))
        {
            var seriesIndex = 1;

            //---- get THEME drawing attributes for each of the parts we will draw ----
            var da = vp.currentTheme().getDrawingAttributes("layerSpaceFill", seriesIndex);

            //---- update the drawing attributes with CONSTANT attribute values from client code ----
            layer.addConstantDrawingAttributes(da, seriesIndex, data);

            var bounds = vp.rect(0, 0, 1, 1);
            var items = null;

            if (xCol)
            {
                var xData = vp.dataSelect(data, xCol[0]);

                //---- since this stat is a 1-to-1 mapping to the data, we add a "._bounds" property to the original data ----
                //---- instead of creating a new data stream.  this allows the caller to do attribute mapping on the original ----
                //---- field names. ----
                items = computeRects(xData, bounds, da, data, layer);
            }
        }

        var newData = { xCol: xCol, yCols: yCols, data: items };

        return newData;
    };

    //---- property: startLoc ----
    closure.startLoc = function (value)
    {
        if (arguments.length == 0)
        {
            return startLoc;
        }

        startLoc = value;
        return closure;
    };

    //---- property: chunking ----
    closure.chunking = function (value)
    {
        if (arguments.length == 0)
        {
            return chunking;
        }

        chunking = value;
        return closure;
    };

    //---- property: phrasing ----
    closure.phrasing = function (value)
    {
        if (arguments.length == 0)
        {
            return phrasing;
        }

        phrasing = value;
        return closure;
    };

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// uiStateMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - manages interaction on a StdChart (vvPlot).
///    - maintains list of all hover shapes (typically 0 or 1)
///    - maintains list of all selected shapes (from different layers, different series)
///    - maintains list of all records being filtered OUT of current view (multiple data sources)
///-----------------------------------------------------------------------------------------------------------------
vp.uiStateMgr = function (viewName, appName, dragContainer, kidsContainer,
    updateVisualsCallback, filterChangedCallback, queryFromElementsInBounds)
{
    //---- private state ----
    var highlight = null;
    var selection = null;
    var filter = null;
    var plotShapes = null;
    var changeAgent = null;
    var selectionCount = 0;
    var shareName = "";
    var isUiEnabled = true;
    var isSelectionEnabled = true;
    var rubberBand = null;
    var container = vp.unwrap(dragContainer);
    var shapeContainer = vp.unwrap(kidsContainer);

    var zoomBoxHelper = null;
    var dragMode = "select";        // "select", "panAndZoom", "none"
    var isMouseDown = false;
    var mouseX = 0;
    var mouseY = 0;
    var dragToKidsOffset = null;
    var selectCallback = null;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.uiStateMgr";

    /// private: initBuild()
    closure.initBuild = function ()
    {
        highlight = vp.query();
        selection = vp.query();
        filter = vp.query();        // when filter is empty, all elements are included 

        if (dragContainer)
        {
            closure.initRubberBand();

            closure.initPanAndZoom();

            closure.dragMode(dragMode);
        }
    };

    /// private: onDragModeChanged().
    closure.onDragModeChanged = function ()
    {
        var isSelect = (dragMode == "select");

        rubberBand.isEnabled(isSelect);
    };

    var adjustBoundsToKidsContainer = function (rcBand)
    {
        if (dragToKidsOffset)
        {
            //---- we don't currently have correct support for finding doc offset for nested svg docs, so let caller specify ----
            rcBand = vp.offsetRect(rcBand, dragToKidsOffset.left, dragToKidsOffset.top);
        }
        else
        {
            var off = vp.docOffset(container);
            var off2 = vp.docOffset(shapeContainer);

            var xdiff = off.left - off2.left;
            var ydiff = off.top - off2.top;

            rcBand = vp.offsetRect(rcBand, xdiff, ydiff);
        }

        return rcBand;
    };

    /// call this as late as possible, so that sizes will be stable.
    var initZoomIfNeeded = function ()
    {
        if (!zoomBoxHelper)
        {
            zoomBoxHelper = vp.zoomBoxHelper(kidsContainer);
        }
    };

    closure.initPanAndZoom = function ()
    {
        //---- capture mouse on left mouse down ----
        vp.attach(document, "mousedown", function (evt)
        {
            if (dragMode == "panAndZoom")
            {
                initZoomIfNeeded();

                var button = ('which' in evt) ? evt.which : evt.button;
                if (button == 1)        // left
                {
                    if (evt.detail == 2)        // double clicked 
                    {
                        zoomBoxHelper.reset();
                    }
                    else
                    {
                        isMouseDown = true;
                        //document.body.style.cursor = "move";

                        if (document.body.setCapture)
                        {
                            document.body.setCapture();
                        }
                    }
                }
            }
        });

        vp.attach(document, "mouseup", function (evt)
        {
            if (dragMode == "panAndZoom")
            {
                initZoomIfNeeded();

                isMouseDown = false;
                //document.body.style.cursor = "default";

                if (document.body.releaseCapture)
                {
                    document.body.releaseCapture();
                }
            }
        });

        //---- hook mouse move at root ----
        vp.attach(document, "mousemove", function (evt)
        {
            if (dragMode == "panAndZoom")
            {
                initZoomIfNeeded();

                var pos = vp.mousePosition(evt);

                var newX = pos.x;
                var newY = pos.y;

                if (isMouseDown)
                {
                    zoomBoxHelper.pan(mouseX - newX, mouseY - newY);
                }

                mouseX = newX;
                mouseY = newY;
            }
        });

        //---- hook mouse wheel at root ----
        vp.attach(document, "mousewheel", function (evt)
        {
            if (dragMode == "panAndZoom")
            {
                initZoomIfNeeded();

                var factor = (vp.wheelDelta(evt) > 0) ? 1.25 : 1 / 1.25;

                var svgoff = vp.docOffset(root[0]);
                var svgX = mouseX - svgoff.left;
                var svgY = mouseY - svgoff.top;

                //vp.debug("svgoff: x=" + svgoff.left + ", y=" + svgoff.top);

                zoomBoxHelper.zoom(factor, svgX, svgY);

                return vp.cancelEvent(evt);
            }
        });
    };

    closure.initRubberBand = function ()
    {
        rubberBand = vp.rubberBandSelector(container, function (rcBand, toggle)
        {
            toggle = (!toggle);     // in stdChart, we add to selection by default

            var elems = getElementsInBounds(rcBand);

            var query = null;

            //---- see if host can build query from the elements in the bounds ----
            if ((elems.length) && (queryFromElementsInBounds))
            {
                query = queryFromElementsInBounds(rcBand, toggle);
            }

            if (query)
            {
                closure.setSelectionFromBoundsQuery(query);
            }
            else
            {
                closure.selectElementsFromBounds(elems, toggle);
            }
        });
    };

    /// public: selectByKeys(keys)
    closure.selectByKeys = function (keys)
    {
        var query = "";

        for (var i = 0; i < keys.length; i++)
        {
            var key = keys[i];
            if (query != "")
            {
                query += " && ";
            }

            query += "(data.key=='" + key + "')";
        }

        closure.setSelectionFromBoundsQuery(query);
    };

    ///------------------------------------------------------------------------------------------------------
    /// TODO: this should eventually use "documentRoot.getIntersectionList(rc, null)" to efficently and correctly
    /// get the elements in the specified rectangle on IE and Chrome.  As of 8/7/2013, "getIntersectionList" 
    /// was not yet working on FireFox.
    ///------------------------------------------------------------------------------------------------------
    var getElementsInBounds = function (rcBand)
    {
        var elems = [];

        if ((rcBand.width) && (rcBand.height))
        {
            rcBand = adjustBoundsToKidsContainer(rcBand);

            var svgIntersectCount = 0;
            var kids = vp.children(shapeContainer);

            for (var k = 0; k < kids.length; k++)
            {
                var kid = kids[k];
                var rc = vp.getBounds(kid, true);

                ////---- convert to real rect ----
                //rc = vp.rect(rc.x, rc.y, rc.width, rc.height);

                var intersects = vp.rectIntersectsRect(rcBand, rc);

                if (intersects)
                {
                    elems.push(kid);

                    if (vp.isSvgElement(kid))
                    {
                        svgIntersectCount++;
                    }
                }
            }

            //---- we can do more precise testing on SVG shapes, but limit shapes to prevent long waits ----
            if ((svgIntersectCount > 0) && (svgIntersectCount <= 10))
            {
                //---- do a more precise test using inkHitTest --
                elems = getElementsInkHitTest(rcBand, elems);
            }

            elems = removeDupElems(elems);
        }
        else
        {
            //---- band is too small; just get element at single point ----
            var offset = vp.docOffset(container);
            var elem = vp.elementFromPoint(rcBand.left + offset.left, rcBand.top + offset.top);
            if ((elem) && (elem.dataItem))
            {
                elems.push(elem);
            }
        }

        return elems;
    }

    /// compare elements by dataItem.key and dataItem.dataId - remove duplicates
    var removeDupElems = function (elems)
    {
        var newElems = elems.distinct(function (e)
        {
            return e.dataItem.dataId + "," + e.dataItem.key + ", " + e.dataItem.shapeId;
        });

        return newElems;
    }

    var getElementsInkHitTest = function (rcBand, elems)
    {
        var newElems = [];
        var inkHitTest = null;

        try
        {
            //---- currently, we select any partial overlap with rcBand and shapes ----
            for (var k = 0; k < elems.length; k++)
            {
                var elem = elems[k];
                var intersects = true;      // until proven otherwise

                if (vp.isSvgElement(elem))
                {
                    var tag = elem.tagName;
                    if ((tag != "rect") && (tag != "image") && (tag != "text"))
                    {
                        //---- complex shape passes bounding box test ----
                        //---- we need to draw shape on a temp canvas to see if it overlaps rect ----
                        if (!inkHitTest)
                        {
                            //--- small tweak required to rcBand for inkHit testing (why?) ----
                            var rcInk = vp.rect(rcBand.left, rcBand.top + 4, rcBand.width, rcBand.height);
                            inkHitTest = vp.inkHitTest(rcInk);
                        }

                        intersects = inkHitTest.doesShapeOverlap(elem);
                    }
                }

                if (intersects)
                {
                    newElems.push(elem);
                }

            }
        }
        finally
        {
            if (inkHitTest)
            {
                inkHitTest.close();
            }
        }

        return newElems;
    }

    closure.selectElementsFromBounds = function (elems, toggle)
    {
        if (!toggle)
        {
            closure.resetSelection(false, false);
        }

        if (elems.length == 0)
        {
            //---- user clicked on non-shape; means "reset selection" ----
            closure.resetSelection();
        }
        else
        {
            for (var e = 0; e < elems.length; e++)
            {
                closure.toggleSelectionOnShape(elems[e], false, false);
            }

            closure.onSelectionChanged();
        }
    };

    /// public: shareName()
    closure.shareName = function(value)
    {
        if (arguments.length == 0)
        {
            return shareName;
        }

        //---- get new share name ----
        shareName = value;

        closure.onShareInfoChanged();

        return closure;
    }

    closure.onShareInfoChanged = function ()
    {
        //---- remove old share name
        if (changeAgent)
        {
            changeAgent.unregister();
            changeAgent = null;
        }

        if (isUiEnabled)
        {
            if ((shareName.length) && (shareName.length > 0))
            {
                changeAgent = vp.changeAgent(viewName, shareName, appName, true, onUiStateReceived);
            }
        }
    };

    /// private: onUiStateReceived().
    var onUiStateReceived = function(uiState, info) 
    {
        if (isUiEnabled)
        {
            //---- update our local query terms with new data received from CHANGE MGR web service ----
            highlight.terms(uiState.highlight);
            selection.terms(uiState.selection);

            //---- update HIGHLIGHT property on shapes ----
            applyQuery(highlight, "isHighlighted");

            //---- update SELECTION property on shapes ----
            selectionCount = applyQuery(selection, "isSelected").count;

            updateShapeVisuals();

            var myTerms = filter.terms();
            var uiTerms = uiState.filter;       // already an array

            var filterHasChanged = filter.termsAreEqual(myTerms, uiTerms);
            if (filterHasChanged)
            {
                filter.terms(uiState.filter);

                triggerFilterChangedCallback();
            }
        }
    }

    /// private: applyQuery().
    var applyQuery = function(query, matchAttribute)
    {
        var matchCount = 0;
        var changed = false;

        if (plotShapes)
        {
            for (var i = 0; i < plotShapes.length; i++)
            {
                var elem = plotShapes[i];
                var dataRecord = vp.dataItem(elem);

                var isIn = query.test(dataRecord);
                if (isIn)
                {
                    matchCount++;
                }

                if (elem[matchAttribute] != isIn)
                {
                    elem[matchAttribute] = isIn;
                    changed = true;

                    //---- if selected changed while highlighted, turn on a special flag ----
                    if ((matchAttribute == "isSelected") && (elem.isHighlighted))
                    {
                        elem.selectChangedDuringHighlight = true;
                    }
                    else
                    {
                        elem.selectChangedDuringHighlight = false;
                    }
                }
            }
        }

        return { count: matchCount, changed: changed };
    }

    /// public: resetFilter() - remove all items from the filter.
    closure.resetFilter = function()
    {
        if (isUiEnabled)
        {
            if (filter.terms().length > 0)
            {
                filter.reset();
                onFilterChanged();
            }
        }

        return closure;
    }

    /// public: invertFilter() - swap the filtered IN and filtered OUT records with each other.
    closure.invertFilter = function()
    {
        if (isUiEnabled)
        {
            //---- all terms in the filter query should be groups ----
            filter.addGroup(null, true);

            onFilterChanged();
        }

        return closure;
    }

    ///public: hideFilter()  - hide the currently selected records (set filtered OUT records to selection) 
    closure.hideFilter = function ()
    {
        if (isUiEnabled)
        {
            filter.addGroup(selection, false);

            //---- always clear selection when filter changes ----
            closure.resetSelection(true, false);

            onFilterChanged();
        }

        return closure;
    }

    /// public: isolateFilter() - hide the currently unselected records.
    closure.isolateFilter = function ()
    {
        if (isUiEnabled)
        {
            filter.addGroup(selection, true);

            //---- always clear selection when filter changes ----
            closure.resetSelection(true, false);

            onFilterChanged();
        }

        return closure;
    }

    ///  public: resetSelection() - clear the current selection.
    closure.resetSelection = function (processSelection, tellOthers)
    {
        //---- apply param defaults ----
        if (processSelection === undefined)
        {
            processSelection = true;
        }
        if (tellOthers === undefined)
        {
            tellOthers = true;
        }

        if ((isUiEnabled) && (isSelectionEnabled))
        {
            if (selection.terms().length > 0)
            {
                selection.reset();

                if (processSelection)
                {
                    closure.onSelectionChanged(tellOthers);
                }
            }
        }

        return closure;
    }

    /// public: toggleSelection().
    closure.toggleSelection = function ()
    {
        if ((isUiEnabled) && (isSelectionEnabled))
        {
            selection.invert();
            closure.onSelectionChanged();
        }

        return closure;
    }

    /// private: getId(elem).
    var getId = function (elem)  
    {
        var str = null;

        // "data" looks like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord };

        if ((elem) && (elem.dataItem) && (elem.dataItem.dataId))
        {
            var data = elem.dataItem;
            var exp = "data.key == \"" + data.key + "\"";

            str = "vp.queryShapeTest(data, " + exp + ", " + data.dataId + ", " + data.shapeId + ")";
        }

        return str;
    }


    /// public property: plotShapes.
    closure.plotShapes = function (value)
    {
        if (arguments.length == 0)
        {
            return plotShapes;
        }

        plotShapes = value;
        return closure;
    };

    /// public property: isUiEnabled.
    closure.isUiEnabled = function (value)
    {
        if (arguments.length == 0)
        {
            return isUiEnabled;
        }

        isUiEnabled = value;
        closure.onShareInfoChanged();

        return closure;
    };

    /// public property: isSelectionEnabled.
    closure.isSelectionEnabled = function (value)
    {
        if (arguments.length == 0)
        {
            return isSelectionEnabled;
        }

        isSelectionEnabled = value;
        rubberBand.isEnabled(value);

        closure.onShareInfoChanged();

        return closure;
    };

    /// public property: dragMode.
    closure.dragMode = function (value)
    {
        if (arguments.length == 0)
        {
            return dragMode;
        }

        dragMode = value;
        closure.onDragModeChanged();

        return closure;
    };

    /// public property: dragToKidsOffset.
    closure.dragToKidsOffset = function (value)
    {
        if (arguments.length == 0)
        {
            return dragToKidsOffset;
        }

        dragToKidsOffset = value;

        return closure;
    };

    /// public: highlightShape(elem).
    closure.highlightShape = function (elem)
    {
        if (isUiEnabled)
        {
            var id = getId(elem);
            if (id)
            {
                highlight.reset();
                highlight.orWith(id);

                onHighlightChanged();
            }
        }

        return closure;
    };

    /// public: toggleSelectionOnShape(elem).
    closure.toggleSelectionOnShape = function (elem, processSelection, tellOthers)
    {
        //---- apply param defaults ----
        processSelection = (processSelection === undefined) ? true : processSelection;
        tellOthers = (tellOthers === undefined) ? true : tellOthers;

        if ((isUiEnabled) && (isSelectionEnabled))
        {
            var id = getId(elem);
            if (id)
            {
                selection.toggleTo(id);

                if (processSelection)
                {
                    closure.onSelectionChanged(tellOthers);
                }
            }
        }

        return closure;
    };

    /// private: setSelectionFromBoundsQuery 
    closure.setSelectionFromBoundsQuery = function (query)
    {
        if ((isUiEnabled) && (isSelectionEnabled))
        {
            selection.boundsQuery(query);
            closure.onSelectionChanged(true);
        }

        return closure;
    };

    /// public: selectShape(elem).
    closure.selectShape = function (elem)
    {
        if ((isUiEnabled) && (isSelectionEnabled))
        {
            var id = getId(elem);
            if (id)
            {
                selection.reset();
                selection.orWith(id);

                closure.onSelectionChanged();
            }
        }

        return closure;
    };

    /// private: updateShapeVisuals()
    var updateShapeVisuals = function ()
    {
        if (updateVisualsCallback)
        {
            updateVisualsCallback(selectionCount);
        }
    }
    
    /// public: resetHighlight().
    closure.resetHighlight = function ()
    {
        if (isUiEnabled)
        {
            if (highlight.terms().length > 0)
            {
                highlight.reset();
                onHighlightChanged();
            }
        }
    };

    /// public readonly property: filter
    closure.filter = function ()
    {
        return filter;
    };

    closure.selection = function ()
    {
        return selection;
    };

    /// private: sendChangesToAgent()
    var sendChangesToAgent = function()
    {
        var data =
        {
            /// note: for "highlight", "selection", and "filter", we just send the terms 
            /// not the whole object.  So, when we receive a change, we need to beware its
            /// not the full object we are getting! 
            dataSourceName: "tbd",
            highlight: highlight.terms(),
            selection: selection.terms(),
            filter: filter.terms()
        };

        //---- tell changeAgent the data changed ----
        if (changeAgent != null)
        {
            changeAgent.data(data);
        }
    }

    /// private: onHighlightChanged()
    var onHighlightChanged = function()
    {
        if (isUiEnabled)
        {
            applyQuery(highlight, "isHighlighted");
            updateShapeVisuals();

            sendChangesToAgent();
        }
    }

    /// private: onSelectionChanged(tellOthersAndUpdate)
    closure.onSelectionChanged = function(tellOthersAndUpdate)
    {
        if (tellOthersAndUpdate === undefined)
        {
            tellOthersAndUpdate = true;
        }

        selectionCount = applyQuery(selection, "isSelected").count;

        if (tellOthersAndUpdate)
        {
            updateShapeVisuals();
            sendChangesToAgent();

            closure.triggerSelectCallback();
        }
    }

    closure.selectionCount = function ()
    {
        return selectionCount;
    }

    closure.triggerSelectCallback = function ()
    {
        if (selectCallback)
        {
            //---- collect keys of all selected records ----
            var keys = [];

            for (var i = 0; i < plotShapes.length; i++)
            {
                var elem = plotShapes[i];
                if (elem.isSelected)
                {
                    keys.push(elem.dataItem.key);
                }
            }

            selectCallback(keys);
        }
    }

    /// private: onFilterChanged()
    var onFilterChanged = function()
    {
        applyQuery(filter, "isFilteredOut");

        sendChangesToAgent();

        triggerFilterChangedCallback();

        //---- ensure visual changes before filter still are in effect ----
        updateShapeVisuals();
    }

    /// private: triggerFilterChangedCallback()
    var triggerFilterChangedCallback = function ()
    {
        if (filterChangedCallback)
        {
            filterChangedCallback();
        }
    }

    /// public: selectCallback
    closure.selectCallback = function (value)
    {
        if (arguments.length == 0)
        {
            return selectCallback;
        }

        selectCallback = value;

        return closure;
    };

    //---- init code ----
    closure.initBuild();

    return closure;
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// animMgmt.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - functions to managage shader-based WebGL animations.
///-----------------------------------------------------------------------------------------------------------------
/// manages the attribute animations that are running on the GL shader.
vp.shaderAnimationManager = function ()
{
    this.children = [];
    this.glHelper = null;
    this.newAnimations = [];
    this.duration = 0;
    this.addNewAnimation = function (anim)
    {
        this.newAnimations.push(anim);
    };

    this.processNewAnimations = function (newAnimations)
    {
        //---- make sure we are not already running animations in the shader ----
        if (false)  //(this.newAnimations.length > 0) && (this.children.length == 0))
        {
            //---- find most popular duration (we can only do 1 of them) ----
            var counts = {};    // find counts, by duration
            for (var i = 0; i < this.newAnimations.length; i++)
            {
                var animate = this.newAnimations[i];
                var duration = animate.parent.duration;

                if (!counts[duration])
                {
                    counts[duration] = 1;
                }
                else
                {
                    var count = counts[duration];
                    counts[duration] = count + 1;
                }
            }

            duration = Math.max(vp.keys(counts));
            this.glHelper = null;

            //---- now, move all attribute animations of "duration" to our list ----
            for (var i = 0; i < this.newAnimations.length; i++)
            {
                var animate = this.newAnimations[i];
                if (animate.parent.duration == duration)
                {
                    var addIt = true;

                    //---- ensure they all have the same glHelper object ----
                    if (this.glHelper == null)
                    {
                        this.glHelper = animate.element.rootContainer.glHelper;
                    }
                    else if (this.glHelper != animate.element.rootContainer.glHelper)
                    {
                        addIt = false;
                    }

                    if (addIt)
                    {
                        //---- add to our list ----
                        this.children.push(animate);

                        //---- remove from its orginal animation ----
                        animate.parent.remove(animate);
                    }
                }
            }

            //---- now, tell glHelper to rebuild the mesh.  it will use this list to build next color/position values ----
            this.duration = duration;
            this.glHelper.initShaderAnimations(duration);
        }

        //---- no matter what else happens, we always clear the new animations list ----
        this.newAnimations = [];
    };

    /// called by glHelper when animations are completed.
    this.onCompleted = function ()
    {
        this.children = [];     // marks us as being available for new set of animations
    };

    /// stop: will stop all shader animations (may not be a logical set to the calling app) if
    /// any belong to "parent".
    this.stopAnimations = function (parent)
    {
        for (var i = 0; i < this.children.length; i++)
        {
            if (this.children[i].parent == parent)
            {
                this.glHelper.stopShaderAnimations();
                this.onCompleted();
                break;
            }
        }
    };
};

/// create a global instance of the shaderAnimationManager to manager shader animations ----
vp.shaderAnimationMgr = new vp.shaderAnimationManager();
﻿///-----------------------------------------------------------------------------------------------------------------
/// glHelper.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - manages mesh, shaders, and drawing for WEBGL-based canvases.
///-----------------------------------------------------------------------------------------------------------------
/// internal class to help draw on 3d canvas. Currently, only simple rectangles drawing is supported.
vp.glHelper = function (canvasContainer)
{
    this.canvasContainer = canvasContainer;
    this.gl = null;
    this.canvas = null;
    this.program = null;
    this.mvMatrix = vp.matrix4.identity();
    this.pMatrix = vp.matrix4.identity();
    this.frameRateFunc = null;

    this.fromBuffer = null;
    this.toBuffer = null;
    this.fromColorBuffer = null;
    this.toColorBuffer = null;

    this.frameCount = 0;
    this.lastTime = new Date();
    this.cycleCount = 0;
    this.lastError = null;
    this.pointSizeValue = 4;
    this.usingPointSprites = true;

    this.isAnimating = false;
    this.timeStarted = 0;
    this.duration = 0;
    this.percent = 0;
    this.onCompletedCallback = null;
    this._usePointSize = false;

    this.frameRateChanged = function (func)
    {
        this.frameRateFunc = func;
    };

    this.initProgram = function (gl)
    {
        var vs = (this._usePointSize) ? vp.vsRectWithPointSize : vp.vsRect;

        var compiledVsRect = this.compileShader(gl, vs, true);
        var compiledFsRect = this.compileShader(gl, vp.fsRect, false);

        //---- build our program ----
        var program = gl.createProgram();
        this.program = program;

        gl.attachShader(program, compiledVsRect);
        gl.attachShader(program, compiledFsRect);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, this.gl.LINK_STATUS))
        {
            alert("Could not compile/link VuePlot shaders");
            return false;
        }

        //---- init program custom properties ----
        gl.useProgram(program);

        program.attrLocFrom = gl.getAttribLocation(program, "from");
        program.attrLocTo = gl.getAttribLocation(program, "to");
        program.attrLocFromColor = gl.getAttribLocation(program, "fromColor");
        program.attrLocToColor = gl.getAttribLocation(program, "toColor");

        //---- enable use of UNIFORM variables in vertex shader ----
        gl.enableVertexAttribArray(program.attrLocFrom);
        gl.enableVertexAttribArray(program.attrLocTo);
        gl.enableVertexAttribArray(program.attrLocFromColor);
        gl.enableVertexAttribArray(program.attrLocToColor);

        //---- store logical locations of UNIFORM variables in vertex shader ----
        program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
        program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
        program.uflPercent = gl.getUniformLocation(program, "fltPercent");
        program.pointSize = gl.getUniformLocation(program, "pointSize");
    };

    this.usePointSize = function (value)
    {
        if (arguments.length == 0)
        {
            return this._usePointSize;
        }

        this._usePointSize = value;
        this.init(this.canvas, this.gl);
    };

    this.updateBounds = function (w, h)
    {
        this.gl.viewportWidth = w;
        this.gl.viewportHeight = h;
    };

    this.init = function (canvas, gl)
    {
        if (gl == null)
        {
            try
            {
                gl = canvas.getContext("experimental-webgl");
            }
            catch (err)
            {
                this.lastError = err;
            }
        }

        this.gl = gl;
        this.canvas = canvas;

        if (this.gl == null)
        {
            //alert("Sorry, this browser doesn't support WebGL.");
            return false;
        }

        this.gl.viewportWidth = canvas.width;
        this.gl.viewportHeight = canvas.height;

        this.initProgram(this.gl);

        //---- temp fix for drawing with point sprites ----
        //---- this causes an "INVALID_ENUM" warning in Chrome, but seems to do no harm ----
        gl.enable(0x8642);

        return true;
    };

    this.drawScene = function ()
    {
        if (this.fromBuffer)
        {
            var gl = this.gl;

            var color = vp.css(this.canvasContainer.canvas, "backgroundColor");
            //vp.debug("drawScene: color=" + color);

            var parts = vp.colorHelper.getColorFromString(color);
            this.gl.clearColor(parts[0] / 255, parts[1] / 255, parts[2] / 255, 1);   // use canvas.fill here?

            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            //---- enable blending ----
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            //gl.depthMask(false);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            this.pMatrix = vp.matrix4.createOrthographicOffCenter(0, gl.viewportWidth - 1, gl.viewportHeight - 1, 0,
                0.1, 100.0);

            if (this.isAnimating)
            {
                //---- increment "percent" ----
                var elapsed = new Date() - this.timeStarted;
                this.percent = elapsed / this.duration;

                if (this.percent > 1)
                {
                    this.percent = 1;
                }
                else if (this.percent < 0)
                {
                    this.percent = 0;
                }
                else
                {
                    //---- apply easing fuction ----
                    if (this.easeObj != null)
                    {
                        this.percent = this.easeObj.ease(this.percent);
                    }
                }
            }

            //---- draw MESH ----
            gl.useProgram(this.program);

            this.mvMatrix = vp.matrix4.identity();

            gl.bindBuffer(gl.ARRAY_BUFFER, this.fromBuffer);
            gl.vertexAttribPointer(this.program.attrLocFrom, this.fromBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.toBuffer);
            gl.vertexAttribPointer(this.program.attrLocTo, this.toBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.fromColorBuffer);
            gl.vertexAttribPointer(this.program.attrLocFromColor, this.fromColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.toColorBuffer);
            gl.vertexAttribPointer(this.program.attrLocToColor, this.toColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            this.setVertexUniformValues(gl, this.percent);

            if (this.usingPointSprites)
            {
                gl.drawArrays(gl.POINTS, 0, this.fromBuffer.numVertices);
            }
            else
            {
                gl.drawArrays(gl.TRIANGLES, 0, this.fromBuffer.numVertices);
            }

            //---- call "vp.shaderAnimationsMgr.onCompleted()" when percent=1 ----
            if (this.isAnimating)
            {
                if (this.percent == 1)
                {
                    vp.shaderAnimationMgr.onCompleted();

                    this.isAnimating = false;
                    this.percent = 1;

                    if (this.onCompletedCallback)
                    {
                        this.onCompletedCallback();
                    }
                }
            }
        }
    };

    this.setVertexUniformValues = function (gl, percent)
    {
        gl.uniformMatrix4fv(this.program.pMatrixUniform, false, this.pMatrix);
        gl.uniformMatrix4fv(this.program.mvMatrixUniform, false, this.mvMatrix);
        gl.uniform1f(this.program.uflPercent, percent);
        gl.uniform1f(this.program.pointSize, this.pointSizeValue);
    };

    /// find 2d/3d element that intersects with x,y at z=0.  return that element.
    this.hitTest = function (children, x, y)
    {
        var elem = null;
        //vp.debug("glHelper.hitTest: x=" + x + ", y=" + y);

        //---- for now, we test each child.  may use color-based bitmap in future. ----
        for (var i = 0; i < children.length; i++)
        {
            var child = children[i];
            elem = child.hitTest(x, y);

            if (elem)
            {
                break;
            }
        }

        return elem;
    };

    this.initShaderAnimations = function (duration, onCompletedCallback)
    {
        // 1. set shader params for duration of animation (vp.shaderAnimationsMgr.duration)
        this.timeStarted = new Date();
        this.isAnimating = true;
        this.duration = duration;
        this.onCompletedCallback = onCompletedCallback;

        // 2. rebuildBuffers and add "to" color/position values for elements in vp.shaderAnimationsMgr.children
        this.canvasContainer.markRebuildNeeded();
    };

    this.stopShaderAnimations = function ()
    {
        //---- set the "percent" for shader animations to "1".
        this.duration = 1;      // force it to complete on next frame
    };

    this.resetShaderAnimations = function ()
    {
        //---- set the "percent" for shader animations to "1".
        this.isAnimating = false;
        this.percent = 0;
    };

    this.pointSize = function (value)
    {
        if (arguments.length == 0)
        {
            return this.pointSizeValue;
        }

        this.pointSizeValue = value;
    };

    this.usePointSprites = function (value)
    {
        if (arguments.length == 0)
        {
            return this.usingPointSprites;
        }

        this.usingPointSprites = value;
    };

    this.rebuildBuffers = function (children)
    {
        var mb = new vp.meshBuilder(this.usingPointSprites);
        var gl = this.gl;

        for (var c = 0; c < children.length; c++)
        {
            var elem = children[c];
            mb.addMeshForElem(elem);
        }

        var start = new Date();

        var vertexCount = (this.usingPointSprites) ? mb.itemCount : 3 * mb.itemCount;

        //---- create FROM buffer ----
        this.fromBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.fromBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mb.fromVertices), gl.STATIC_DRAW);
        this.fromBuffer.itemSize = 3;            // 3 numbers per vertex
        this.fromBuffer.numVertices = vertexCount;

        //---- create TO buffer ----
        this.toBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.toBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mb.toVertices), gl.STATIC_DRAW);
        this.toBuffer.itemSize = 3;            // 3 numbers per vertex
        this.toBuffer.numVertices = vertexCount;

        //---- create FROM COLOR buffer ----
        this.fromColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.fromColorBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mb.fromColorVertices), gl.STATIC_DRAW);
        this.fromColorBuffer.itemSize = 4;            // 4 numbers per vertex
        this.fromColorBuffer.numVertices = vertexCount;

        //---- create TO COLOR buffer ----
        this.toColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.toColorBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mb.toColorVertices), gl.STATIC_DRAW);
        this.toColorBuffer.itemSize = 4;            // 4 numbers per vertex
        this.toColorBuffer.numVertices = vertexCount;

        //logTime(start, "MESH TRANSFER");
    };

    this.compileShader = function (gl, str, isVertex)
    {
        var shader;
        if (isVertex)
        {
            shader = gl.createShader(gl.VERTEX_SHADER);
        }
        else
        {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    };
};
﻿///-----------------------------------------------------------------------------------------------------------------
/// meshBuilder.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - builds mesh data for shapes.
///-----------------------------------------------------------------------------------------------------------------

/// class "meshBuilder": a helper class for building webGL meshes for shapes.
vp.meshBuilder = function (usingPointSprites)
{
    //---- make these typed arrays for fastest perf (are they truly faster?) ----
    //var count = 60000 * 6;;

    this.fromVertices = [];         //new Float32Array(count);
    this.toVertices = [];           // new Float32Array(count);
    this.fromColorVertices = [];    // new Float32Array(count);
    this.toColorVertices = [];      // new Float32Array(count);

    this.usingPointSprites = usingPointSprites;

    this.square =
    [
        //---- first triangle ----
        1.0, 1.0, 0.0,
        -1.0, 1.0, 0.0,
        1.0, -1.0, 0.0,

        //---- second triangle ----
        1.0, -1.0, 0.0,
        -1.0, 1.0, 0.0,
        -1.0, -1.0, 0.0,
    ];

    //---- make upper/left corner = 0,0 ----
    for (var i = 0; i < this.square.length; i++)
    {
        //---- we need to add "2" (vs. "1") to get correct result, but why? ----
        //this.square[i] = (this.square[i] + 1) / 2;
        this.square[i] = (this.square[i] + 2) / 2;
    }

    this.itemCount = 0;
    this.vertexIndex = 0;
    this.colorIndex = 0;

    //---- FROM COLOR (each component: 0..1) ----
    this.currentColor = "";
    this.r = 0;
    this.g = 0;
    this.b = 0;

    //---- TO COLOR (each component: 0..1) ----
    this.toColor = "";
    this.torr = 0;
    this.togg = 0;
    this.tobb = 0;

    this.addMeshForElem = function (elem)
    {
        if (elem instanceof vp.canvasGroupElement)
        {
            //---- call recursively to add for this group's children ----
            for (var e = 0; e < elem.children.length; e++)
            {
                var child = elem.children[e];
                this.addMeshForElem(child);
            }
        }
        else
        {
            if (elem.visibility != "hidden")
            {

                //---- for now, draw circles as rectangles ----
                var isRect = (elem instanceof vp.canvasRectElement);
                var isCircle = (elem instanceof vp.canvasCircleElement);
                var isLine = (elem instanceof vp.canvasLineElement);

                //---- process BEFORE COLOR ----
                var cr = (isLine) ? elem.stroke : elem.fill;

                if (cr != this.currentColor)
                {
                    var parts = vp.colorHelper.getColorFromString(cr);
                    this.currentColor = cr;

                    if ((parts) && (parts.length == 3))
                    {
                        this.r = parts[0] / 255;
                        this.g = parts[1] / 255;
                        this.b = parts[2] / 255;
                    }
                    else
                    {
                        this.r = 0;
                        this.g = 0;
                        this.b = 0;
                    }
                }

                //---- process TO COLOR ----
                var toCr = elem.toColor;

                if (toCr != this.toColor)
                {
                    var parts = vp.colorHelper.getColorFromString(toCr);
                    this.toColor = toCr;

                    if ((parts) && (parts.length == 3))
                    {
                        this.torr = parts[0] / 255;
                        this.togg = parts[1] / 255;
                        this.tobb = parts[2] / 255;
                    }
                    else
                    {
                        this.torr = 0;
                        this.togg = 0;
                        this.tobb = 0;
                    }

                    this.tozz = 1;
                }

                if (isRect || isCircle)
                {
                    //---- x,y specifies where the upper/left of the rect should be drawn ----
                    var x = elem.x;
                    var y = elem.y;
                    var w = elem.width;
                    var h = elem.height;

                    var toX = elem.toX;
                    var toY = elem.toY;
                    var toW = elem.toWidth;
                    var toH = elem.toHeight;

                    if (isCircle)
                    {
                        w = elem.r * 2;
                        h = w;

                        toW = elem.toR * 2;
                        toH = toW;

                        x = elem.cx - elem.r;
                        y = elem.cy - elem.r;

                        toX = elem.toCx - elem.toR;
                        toY = elem.toCy - elem.toR;
                    }

                    var vertexCount = 6;
                    var startIndex = 0;

                    if (this.usingPointSprites)
                    {
                        vertexCount = 1;
                        startIndex = 15;        // this has x=0, y=0, z=.5
                    }

                    var si = startIndex;
                    for (var s = 0; s < vertexCount; s++)     // for each of 6 vertices (in 2 triangles)
                    {
                        var xx = this.square[si] * w + x;
                        var toXx = this.square[si] * toW + toX;
                        si++;

                        var yy = this.square[si] * h + y;
                        var toYy = this.square[si] * toH + toY;
                        si++;

                        si++;       // skip over square[] z entry

                        var toZz = -1;

                        this.addVertex(xx, yy, -1, this.r, this.g, this.b, elem.opacity, toXx, toYy, toZz,
                            this.torr, this.togg, this.tobb, elem.toOpacity);
                    }

                    //---- increment the count of primitives generated ----
                    if (this.usingPointSprites)
                    {
                        this.itemCount++;       // 1 point generated
                    }
                    else
                    {
                        this.itemCount += 2;    // 2 triangles generated
                    }
                }
                else if (isLine)
                {
                    var quad = this.getQuadForLine(elem.x1, elem.y1, elem.x2, elem.y2, elem["stroke-width"]);

                    //---- first triangle ----
                    this.addVertex(quad.ll.x, quad.ll.y, -1, this.r, this.g, this.b, elem.opacity);
                    this.addVertex(quad.ul.x, quad.ul.y, -1, this.r, this.g, this.b, elem.opacity);
                    this.addVertex(quad.ur.x, quad.ur.y, -1, this.r, this.g, this.b, elem.opacity);

                    //---- second triangle ----
                    this.addVertex(quad.ur.x, quad.ur.y, -1, this.r, this.g, this.b, elem.opacity);
                    this.addVertex(quad.lr.x, quad.lr.y, -1, this.r, this.g, this.b, elem.opacity);
                    this.addVertex(quad.ll.x, quad.ll.y, -1, this.r, this.g, this.b, elem.opacity);

                    this.itemCount += 2;
                }
            }
        }
    };

    /// compute the quad for the line from x1,y1 to x2,y2 with the specified thickness.
    this.getQuadForLine = function (x1, y1, x2, y2, thickness)
    {
        var myStart = new vp.vector2(x1, y1);
        var myEnd = new vp.vector2(x2, y2);

        var vLine = myEnd.subtract(myStart);
        vLine = vLine.normalize();

        //---- create a line perpendicular to vLine ----
        var vpLine = new vp.vector2(-vLine.y, vLine.x);
        //vpLine.Normalize();
        var vpSeg = vpLine.multiply(thickness / 2);   // try not to scale Thickness in some later transform....

        var ptUL = myStart.add(vpSeg);
        var ptLL = myStart.subtract(vpSeg);

        var ptUR = myEnd.add(vpSeg);
        var ptLR = myEnd.subtract(vpSeg);

        return { ll: ptLL, ul: ptUL, ur: ptUR, lr: ptLR };
    };

    /// add data for a single vertext that is not being animated.
    this.addVertex = function (xx, yy, zz, rr, gg, bb, aa, toxx, toyy, tozz, torr, togg, tobb, toaa)
    {
        if (arguments.length == 7)
        {
            toxx = xx;
            toyy = yy;
            tozz = zz;

            torr = rr;
            togg = gg;
            tobb = bb;
            toaa = aa;
        }

        //---- from/to POSITION ----
        //---- x ----
        this.fromVertices[this.vertexIndex] = xx;
        this.toVertices[this.vertexIndex] = toxx;
        this.vertexIndex++;

        //---- y ----
        this.fromVertices[this.vertexIndex] = yy;
        this.toVertices[this.vertexIndex] = toyy;
        this.vertexIndex++;

        //---- z ----
        this.fromVertices[this.vertexIndex] = zz;
        this.toVertices[this.vertexIndex] = tozz;
        this.vertexIndex++;

        //---- from/to COLOR ----
        this.fromColorVertices[this.colorIndex] = rr;
        this.toColorVertices[this.colorIndex] = torr;
        this.colorIndex++;

        this.fromColorVertices[this.colorIndex] = gg;
        this.toColorVertices[this.colorIndex] = togg;
        this.colorIndex++;

        this.fromColorVertices[this.colorIndex] = bb;
        this.toColorVertices[this.colorIndex] = tobb;;
        this.colorIndex++;

        this.fromColorVertices[this.colorIndex] = aa;
        this.toColorVertices[this.colorIndex] = toaa;
        this.colorIndex++;
    };
};

﻿///-----------------------------------------------------------------------------------------------------------------
/// shaders.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - the WEBGL shaders we define for drawing our shapes.
///-----------------------------------------------------------------------------------------------------------------
//---- we define shaders as strings so we can included them in our js file.  note, comments ----
//---- should be include a "\n \n" character at the end (since all lines are joined together as one) ----

//---- fragment shader: fsRect ----
vp.fsRect = '         \n \
    precision mediump float;  \n \
    \n \
    varying vec4 vColor;      \n \
    \n \
    void main(void)           \n \
    {  \n \
        gl_FragColor = vColor;     \n \
    }    \n \
    ';

//---- vertex shader: vsRect ----
vp.vsRectWithPointSize = '                     \n \
    attribute vec3 from;            \n \
    attribute vec3 to;              \n \
    attribute vec4 fromColor;       \n \
    attribute vec4 toColor;         \n \
    \n \
    uniform mat4 uMVMatrix;         \n \
    uniform mat4 uPMatrix;          \n \
    uniform float fltPercent;       \n \
    uniform float pointSize;       \n \
    \n \
    varying vec4 vColor;            \n \
    \n \
    void main(void)             \n \
    {   \n \
        float percent = smoothstep(0.0, 1.0, fltPercent);   \n \
        \n \
        gl_PointSize = pointSize;     \n \
        \n \
        vec3 vec = from + percent * (to - from);            \n \
        \n \
        gl_Position = uPMatrix * uMVMatrix * vec4(vec, 1.0);    \n \
        \n \
        vColor = fromColor + percent * (toColor - fromColor);  \n \
    }   \n \
';

//---- vertex shader: vsRect ----
vp.vsRect = '                     \n \
    attribute vec3 from;            \n \
    attribute vec3 to;              \n \
    attribute vec4 fromColor;       \n \
    attribute vec4 toColor;         \n \
    \n \
    uniform mat4 uMVMatrix;         \n \
    uniform mat4 uPMatrix;          \n \
    uniform float fltPercent;       \n \
    uniform float pointSize;       \n \
    \n \
    varying vec4 vColor;            \n \
    \n \
    void main(void)             \n \
    {   \n \
        float percent = smoothstep(0.0, 1.0, fltPercent);   \n \
        \n \
        vec3 vec = from + percent * (to - from);            \n \
        \n \
        gl_Position = uPMatrix * uMVMatrix * vec4(vec, 1.0);    \n \
        \n \
        vColor = fromColor + percent * (toColor - fromColor);  \n \
    }   \n \
';
﻿///-----------------------------------------------------------------------------------------------------------------
/// vpEnd.js.  Copyright (c) 2012 Microsoft Corporation.
///    - last file of VuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vuePlot = vp;       // "vuePlot" is required to be defined by TypeScript wrappers for VuePlot

vuePlot.dataStuff.dataFrame = vp.dataFrame;
vuePlot.dataStuff.httpRead = vp.httpRead;
vuePlot.dataStuff.csvToJson = vp.csvToJson;
vuePlot.dataStuff.range = vp.range;

vuePlot.colorStuff.themeMgr = function ()
{
    return vp.themeMgr();
};
vuePlot.colorStuff.currentTheme = vp.currentTheme;

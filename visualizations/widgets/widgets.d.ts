/// <reference path="../../core/scripts/d3.d.ts" />
/// <reference path="../../core/networkcube.d.ts" />
declare class Slider {
    BAR_WIDTH: number;
    RADIUS_HANDLE: number;
    LEFT: number;
    RIGHT: number;
    HEIGHT: number;
    TOP: number;
    max: number;
    min: number;
    value: number;
    stepWidth: number;
    svg: D3.Selection;
    x: number;
    y: number;
    width: number;
    g: D3.Selection;
    dragEndCallBackFn: Function;
    constructor(x: number, y: number, width: number, minValue: number, maxValue: number, stepWidth: number);
    setDragEndCallBack(fn: Function): void;
    valueRange: any;
    drag: any;
    bar: any;
    knob: any;
    rect: any;
    appendTo(svg: D3.Selection): void;
    dragStartXMouse: any;
    dragStartXBar: any;
    dragObj: any;
    currentBarLength: any;
    dragStart(): void;
    dragMove(): void;
    dragEnd(): void;
    getRelX(): number;
    set(value: number): void;
}
declare module networkcube {
    function makeSlider(d3parent: D3.Selection, label: string, width: number, height: number, value: number, min: number, max: number, f: Function): void;
    class RadioButton {
        private checked;
        circle: D3.Selection;
        label: D3.Selection;
        color: string;
        text: string;
        RADIUS: number;
        clickHandler: Function;
        constructor(color: string, text?: string);
        appendTo(x: number, y: number, svg: D3.Selection): void;
        isChecked(): boolean;
        addClickHandler(f: Function): void;
    }
    function makeCheckBox(d3parent: any, label: string, callback: Function): void;
    function makeButton(d3parent: any, label: string, callback: Function): void;
}
declare class TimeSlider {
    MARGIN_SLIDER_RIGHT: number;
    MARGIN_SLIDER_LEFT: number;
    TICK_GAP: number;
    TICK_LABEL_GAP: number;
    SLIDER_TOP: number;
    HEIGHT: number;
    dgraph: networkcube.DynamicGraph;
    slider: SmartSlider;
    times: networkcube.Time[];
    sliderWidth: number;
    widgetWidth: number;
    callBack: any;
    propagateButton: networkcube.RadioButton;
    labelStart: D3.Selection;
    labelEnd: D3.Selection;
    tickScale: Function;
    tickHeightFunction: Function;
    constructor(dgraph: networkcube.DynamicGraph, width: number, callBack?: Function);
    appendTo(svg: D3.Selection, x?: number, y?: number): void;
    drawTickmarks(granularity: number, tickTimes: networkcube.Time[], svg: D3.Selection): void;
    formatAtGranularity(time: any, granualarity: number): any;
    formatForGranularities(time: any, gran_min: number, gran_max: number): any;
    getGranularityFormattingString(granualarity: any, separator: boolean): string;
    updateTime(minUnix: number, maxUnix: number, single: number): void;
    set(startUnix: number, endUnix: number): void;
}
declare class SmartSlider {
    BAR_WIDTH: number;
    RADIUS_HANDLE: number;
    LEFT: number;
    RIGHT: number;
    HEIGHT: number;
    TOP: number;
    max: number;
    min: number;
    stepWidth: number;
    hasTickmarks: boolean;
    isInverted: boolean;
    svg: D3.Selection;
    x: number;
    y: number;
    width: number;
    g: D3.Selection;
    dragEndCallBackFn: Function;
    constructor(x: number, y: number, width: number, minValue: number, maxValue: number, stepWidth: number, tickMarks?: boolean);
    setDragEndCallBack(fn: Function): void;
    valueRange: D3.Scale.QuantitiveScale;
    val2spaceScale: D3.Scale.QuantitiveScale;
    drag: D3.Behavior.Drag;
    bar0: D3.Selection;
    bar1: D3.Selection;
    circleMin: any;
    circleMax: any;
    circleSingle: any;
    rect: any;
    singleTimeStepX: number;
    appendTo(svg: D3.Selection): void;
    dragStartXMouse: number;
    dragStartXBar: number;
    dragObj: any;
    currentBarLength: number;
    dragStart(): void;
    dragMove(): void;
    dragEnd(): void;
    getRelX(): number;
    set(min: number, max: number): void;
    setIsInverted(inv: boolean): void;
}
declare class Timeline {
    TICK_MIN_DIST: number;
    LABEL_MIN_DIST: number;
    WIDTH: number;
    HEIGHT: number;
    webgl: glutils.WebGL;
    network: networkcube.DynamicGraph;
    x: number;
    y: number;
    position_x: any;
    position_y: any;
    label_opacity: any;
    minTimeId: any;
    maxTimeId: any;
    timeObjects: Moment[];
    highlightPointer: any;
    highlightLabel: any;
    minGran: number;
    maxGran: number;
    granules: any;
    tickmarks: glutils.WebGLElementQuery;
    timeLabels: glutils.WebGLElementQuery;
    tick_minGran_visible: any;
    tick_minGran_visible_prev: number;
    label_minGran_visible: any;
    constructor(webgl: glutils.WebGL, network: networkcube.DynamicGraph, x: number, y: number, width: number, height: number);
    timeGranularities: any;
    visualize(): void;
    update(startUnix: any, endUnix: any): void;
    updateWithIds(minTimeId: any, maxTimeId: any): void;
    formatTime(index: any): string;
    highlightId: number;
    highlight(unixTime?: number): void;
}
declare class RangeSlider {
    BAR_WIDTH: number;
    RADIUS_HANDLE: number;
    LEFT: number;
    RIGHT: number;
    HEIGHT: number;
    TOP: number;
    max: number;
    min: number;
    stepWidth: number;
    hasTickmarks: boolean;
    isInverted: boolean;
    svg: D3.Selection;
    x: number;
    y: number;
    width: number;
    g: D3.Selection;
    dragEndCallBackFn: Function;
    constructor(x: number, y: number, width: number, minValue: number, maxValue: number, stepWidth: number, tickMarks?: boolean);
    setDragEndCallBack(fn: Function): void;
    valueRange: D3.Scale.QuantitiveScale;
    val2spaceScale: D3.Scale.QuantitiveScale;
    drag: D3.Behavior.Drag;
    bar0: D3.Selection;
    bar1: D3.Selection;
    circleMin: any;
    circleMax: any;
    rect: any;
    appendTo(svg: D3.Selection): void;
    dragStartXMouse: number;
    dragStartXBar: number;
    dragObj: any;
    currentBarLength: number;
    dragStart(): void;
    dragMove(): void;
    dragEnd(): void;
    getRelX(): number;
    set(min: number, max: number): void;
    setIsInverted(inv: boolean): void;
}
